<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Controller/GameController.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Controller/GameController.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;namespace App\Controller;&#10;&#10;use App\Service\PedantixService;&#10;use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;&#10;use Symfony\Component\HttpFoundation\Request;&#10;use Symfony\Component\HttpFoundation\Response;&#10;use Symfony\Component\HttpFoundation\JsonResponse;&#10;use Symfony\Component\Routing\Annotation\Route;&#10;&#10;class GameController extends AbstractController&#10;{&#10;    public function __construct(&#10;        private PedantixService $pedantixService&#10;    ) {}&#10;&#10;    #[Route('/', name: 'app_home')]&#10;    public function index(): Response&#10;    {&#10;        return $this-&gt;render('game/index.html.twig');&#10;    }&#10;&#10;    #[Route('/create-room', name: 'app_create_room', methods: ['POST'])]&#10;    public function createRoom(Request $request): JsonResponse&#10;    {&#10;        $data = json_decode($request-&gt;getContent(), true);&#10;        $wikipediaUrl = $data['wikipedia_url'] ?? '';&#10;&#10;        if (empty($wikipediaUrl)) {&#10;            return $this-&gt;json(['success' =&gt; false, 'error' =&gt; 'URL Wikipedia requise'], 400);&#10;        }&#10;&#10;        // Valider le format de l'URL Wikipedia&#10;        if (!preg_match('/^https?:\/\/(fr\.)?wikipedia\.org\/wiki\/.+/', $wikipediaUrl)) {&#10;            return $this-&gt;json(['success' =&gt; false, 'error' =&gt; 'Veuillez entrer une URL Wikipedia française valide (ex: https://fr.wikipedia.org/wiki/Eau)'], 400);&#10;        }&#10;&#10;        try {&#10;            $room = $this-&gt;pedantixService-&gt;createRoom($wikipediaUrl);&#10;&#10;            return $this-&gt;json([&#10;                'success' =&gt; true,&#10;                'room_code' =&gt; $room-&gt;getCode(),&#10;                'title' =&gt; $room-&gt;getTitle()&#10;            ]);&#10;        } catch (\Exception $e) {&#10;            // Log l'erreur pour debugging&#10;            error_log('Erreur création de salle: ' . $e-&gt;getMessage() . ' pour URL: ' . $wikipediaUrl);&#10;&#10;            return $this-&gt;json([&#10;                'success' =&gt; false,&#10;                'error' =&gt; $e-&gt;getMessage()&#10;            ], 500);&#10;        }&#10;    }&#10;&#10;    #[Route('/join-room', name: 'app_join_room', methods: ['POST'])]&#10;    public function joinRoom(Request $request): JsonResponse&#10;    {&#10;        $data = json_decode($request-&gt;getContent(), true);&#10;        $roomCode = strtoupper($data['room_code'] ?? '');&#10;        $playerName = $data['player_name'] ?? '';&#10;&#10;        if (empty($roomCode) || empty($playerName)) {&#10;            return $this-&gt;json(['error' =&gt; 'Code de salle et nom de joueur requis'], 400);&#10;        }&#10;&#10;        try {&#10;            $ipAddress = $request-&gt;getClientIp();&#10;            $gameSession = $this-&gt;pedantixService-&gt;joinRoom($roomCode, $playerName, $ipAddress);&#10;&#10;            if (!$gameSession) {&#10;                return $this-&gt;json(['error' =&gt; 'Salle introuvable'], 404);&#10;            }&#10;&#10;            $room = $gameSession-&gt;getRoom();&#10;&#10;            return $this-&gt;json([&#10;                'success' =&gt; true,&#10;                'session_id' =&gt; $gameSession-&gt;getId(),&#10;                'room' =&gt; [&#10;                    'code' =&gt; $room-&gt;getCode(),&#10;                    'title' =&gt; 'Article mystère', // Ne pas révéler le vrai titre&#10;                    'hints' =&gt; $room-&gt;getHints()&#10;                ],&#10;                'player' =&gt; [&#10;                    'name' =&gt; $gameSession-&gt;getPlayerName(),&#10;                    'found_words' =&gt; $gameSession-&gt;getFoundWords(),&#10;                    'attempts' =&gt; $gameSession-&gt;getAttempts(),&#10;                    'score' =&gt; $gameSession-&gt;getScore(),&#10;                    'completed' =&gt; $gameSession-&gt;isCompleted()&#10;                ]&#10;            ]);&#10;        } catch (\Exception $e) {&#10;            return $this-&gt;json(['error' =&gt; $e-&gt;getMessage()], 500);&#10;        }&#10;    }&#10;&#10;    #[Route('/game/{roomCode}', name: 'app_game_room')]&#10;    public function gameRoom(string $roomCode): Response&#10;    {&#10;        return $this-&gt;render('game/room.html.twig', [&#10;            'room_code' =&gt; strtoupper($roomCode)&#10;        ]);&#10;    }&#10;&#10;    #[Route('/api/guess', name: 'app_submit_guess', methods: ['POST'])]&#10;    public function submitGuess(Request $request): JsonResponse&#10;    {&#10;        $data = json_decode($request-&gt;getContent(), true);&#10;        $sessionId = $data['session_id'] ?? null;&#10;        $guess = $data['guess'] ?? '';&#10;&#10;        if (!$sessionId || empty($guess)) {&#10;            return $this-&gt;json(['success' =&gt; false, 'error' =&gt; 'Session et mot requis'], 400);&#10;        }&#10;&#10;        try {&#10;            $gameSession = $this-&gt;pedantixService-&gt;getGameSession($sessionId);&#10;            if (!$gameSession) {&#10;                return $this-&gt;json(['success' =&gt; false, 'error' =&gt; 'Session invalide'], 400);&#10;            }&#10;&#10;            $result = $this-&gt;pedantixService-&gt;submitGuess($gameSession, $guess);&#10;&#10;            // Si c'est un doublon, retourner une erreur spécifique&#10;            if (isset($result['duplicate']) &amp;&amp; $result['duplicate']) {&#10;                return $this-&gt;json([&#10;                    'success' =&gt; false,&#10;                    'error' =&gt; 'Mot déjà essayé',&#10;                    'duplicate' =&gt; true,&#10;                    'word' =&gt; $result['word']&#10;                ], 400);&#10;            }&#10;&#10;            return $this-&gt;json([&#10;                'success' =&gt; true,&#10;                'result' =&gt; $result,&#10;                'player' =&gt; [&#10;                    'found_words' =&gt; $gameSession-&gt;getFoundWords(),&#10;                    'attempts' =&gt; $gameSession-&gt;getAttempts(),&#10;                    'score' =&gt; $gameSession-&gt;getScore(),&#10;                    'completed' =&gt; $gameSession-&gt;isCompleted()&#10;                ]&#10;            ]);&#10;        } catch (\Exception $e) {&#10;            return $this-&gt;json(['success' =&gt; false, 'error' =&gt; $e-&gt;getMessage()], 500);&#10;        }&#10;    }&#10;&#10;    #[Route('/api/article-content/{roomCode}', name: 'app_article_content')]&#10;    public function getArticleContent(string $roomCode, Request $request): JsonResponse&#10;    {&#10;        try {&#10;            $room = $this-&gt;pedantixService-&gt;getRoomByCode($roomCode);&#10;            if (!$room) {&#10;                return $this-&gt;json(['error' =&gt; 'Salle introuvable'], 404);&#10;            }&#10;&#10;            $sessionId = $request-&gt;query-&gt;get('session_id');&#10;            $foundWords = [];&#10;            $gameCompleted = false;&#10;            $proximityData = [];&#10;&#10;            if ($sessionId) {&#10;                $gameSession = $this-&gt;pedantixService-&gt;getGameSession($sessionId);&#10;                if ($gameSession) {&#10;                    $foundWords = $gameSession-&gt;getFoundWords();&#10;                    $gameCompleted = $gameSession-&gt;isCompleted();&#10;&#10;                    // Récupérer les données de proximité des dernières tentatives&#10;                    $proximityDataRaw = $request-&gt;query-&gt;get('proximity_data', '[]');&#10;                    if (is_string($proximityDataRaw)) {&#10;                        $decoded = json_decode($proximityDataRaw, true);&#10;                        if (is_array($decoded)) {&#10;                            $proximityData = $decoded;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            $processedContent = $this-&gt;pedantixService-&gt;getProcessedContent($room, $foundWords, $proximityData, $gameCompleted);&#10;&#10;            return $this-&gt;json([&#10;                'title' =&gt; $room-&gt;getTitle(),&#10;                'content' =&gt; $processedContent,&#10;                'total_words' =&gt; count($room-&gt;getWordsToFind()),&#10;                'game_completed' =&gt; $gameCompleted&#10;            ]);&#10;        } catch (\Exception $e) {&#10;            // Log l'erreur pour debugging&#10;            error_log('Erreur dans getArticleContent: ' . $e-&gt;getMessage() . ' - Trace: ' . $e-&gt;getTraceAsString());&#10;&#10;            return $this-&gt;json([&#10;                'error' =&gt; 'Erreur interne du serveur: ' . $e-&gt;getMessage(),&#10;                'debug_info' =&gt; [&#10;                    'line' =&gt; $e-&gt;getLine(),&#10;                    'file' =&gt; basename($e-&gt;getFile())&#10;                ]&#10;            ], 500);&#10;        }&#10;    }&#10;&#10;    #[Route('/api/leaderboard/{roomCode}', name: 'app_leaderboard')]&#10;    public function leaderboard(string $roomCode): JsonResponse&#10;    {&#10;        try {&#10;            $room = $this-&gt;pedantixService-&gt;getRoomByCode($roomCode);&#10;            if (!$room) {&#10;                return $this-&gt;json(['error' =&gt; 'Salle introuvable'], 404);&#10;            }&#10;&#10;            $leaderboard = $this-&gt;pedantixService-&gt;getLeaderboard($room);&#10;            $activePlayers = $this-&gt;pedantixService-&gt;getActivePlayers($room);&#10;&#10;            $leaderboardData = array_map(function($session) {&#10;                return [&#10;                    'player_name' =&gt; $session-&gt;getPlayerName(),&#10;                    'score' =&gt; $session-&gt;getScore(),&#10;                    'completed_at' =&gt; $session-&gt;getCompletedAt()?-&gt;format('Y-m-d H:i:s'),&#10;                    'attempts' =&gt; $session-&gt;getAttempts()&#10;                ];&#10;            }, $leaderboard);&#10;&#10;            $activePlayersData = array_map(function($session) {&#10;                return [&#10;                    'player_name' =&gt; $session-&gt;getPlayerName(),&#10;                    'score' =&gt; $session-&gt;getScore(),&#10;                    'found_words_count' =&gt; count($session-&gt;getFoundWords()),&#10;                    'last_activity' =&gt; $session-&gt;getLastActivity()-&gt;format('Y-m-d H:i:s')&#10;                ];&#10;            }, $activePlayers);&#10;&#10;            return $this-&gt;json([&#10;                'leaderboard' =&gt; $leaderboardData,&#10;                'active_players' =&gt; $activePlayersData&#10;            ]);&#10;        } catch (\Exception $e) {&#10;            return $this-&gt;json(['error' =&gt; $e-&gt;getMessage()], 500);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;namespace App\Controller;&#10;&#10;use App\Service\PedantixService;&#10;use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;&#10;use Symfony\Component\HttpFoundation\Request;&#10;use Symfony\Component\HttpFoundation\Response;&#10;use Symfony\Component\HttpFoundation\JsonResponse;&#10;use Symfony\Component\Routing\Annotation\Route;&#10;&#10;class GameController extends AbstractController&#10;{&#10;    public function __construct(&#10;        private PedantixService $pedantixService&#10;    ) {}&#10;&#10;    #[Route('/', name: 'app_home')]&#10;    public function index(): Response&#10;    {&#10;        return $this-&gt;render('game/index.html.twig');&#10;    }&#10;&#10;    #[Route('/create-room', name: 'app_create_room', methods: ['POST'])]&#10;    public function createRoom(Request $request): JsonResponse&#10;    {&#10;        $data = json_decode($request-&gt;getContent(), true);&#10;        $wikipediaUrl = $data['wikipedia_url'] ?? '';&#10;        $gameMode = $data['game_mode'] ?? 'competition'; // Par défaut: compétition&#10;&#10;        if (empty($wikipediaUrl)) {&#10;            return $this-&gt;json(['success' =&gt; false, 'error' =&gt; 'URL Wikipedia requise'], 400);&#10;        }&#10;&#10;        // Valider le mode de jeu&#10;        if (!in_array($gameMode, ['competition', 'cooperation'])) {&#10;            return $this-&gt;json(['success' =&gt; false, 'error' =&gt; 'Mode de jeu invalide'], 400);&#10;        }&#10;&#10;        // Valider le format de l'URL Wikipedia&#10;        if (!preg_match('/^https?:\/\/(fr\.)?wikipedia\.org\/wiki\/.+/', $wikipediaUrl)) {&#10;            return $this-&gt;json(['success' =&gt; false, 'error' =&gt; 'Veuillez entrer une URL Wikipedia française valide (ex: https://fr.wikipedia.org/wiki/Eau)'], 400);&#10;        }&#10;&#10;        try {&#10;            $room = $this-&gt;pedantixService-&gt;createRoom($wikipediaUrl, $gameMode);&#10;&#10;            return $this-&gt;json([&#10;                'success' =&gt; true,&#10;                'room_code' =&gt; $room-&gt;getCode(),&#10;                'title' =&gt; $room-&gt;getTitle(),&#10;                'game_mode' =&gt; $room-&gt;getGameMode()&#10;            ]);&#10;        } catch (\Exception $e) {&#10;            // Log l'erreur pour debugging&#10;            error_log('Erreur création de salle: ' . $e-&gt;getMessage() . ' pour URL: ' . $wikipediaUrl);&#10;&#10;            return $this-&gt;json([&#10;                'success' =&gt; false,&#10;                'error' =&gt; $e-&gt;getMessage()&#10;            ], 500);&#10;        }&#10;    }&#10;&#10;    #[Route('/join-room', name: 'app_join_room', methods: ['POST'])]&#10;    public function joinRoom(Request $request): JsonResponse&#10;    {&#10;        $data = json_decode($request-&gt;getContent(), true);&#10;        $roomCode = strtoupper($data['room_code'] ?? '');&#10;        $playerName = $data['player_name'] ?? '';&#10;&#10;        if (empty($roomCode) || empty($playerName)) {&#10;            return $this-&gt;json(['error' =&gt; 'Code de salle et nom de joueur requis'], 400);&#10;        }&#10;&#10;        try {&#10;            $ipAddress = $request-&gt;getClientIp();&#10;            $gameSession = $this-&gt;pedantixService-&gt;joinRoom($roomCode, $playerName, $ipAddress);&#10;&#10;            if (!$gameSession) {&#10;                return $this-&gt;json(['error' =&gt; 'Salle introuvable'], 404);&#10;            }&#10;&#10;            $room = $gameSession-&gt;getRoom();&#10;&#10;            return $this-&gt;json([&#10;                'success' =&gt; true,&#10;                'session_id' =&gt; $gameSession-&gt;getId(),&#10;                'room' =&gt; [&#10;                    'code' =&gt; $room-&gt;getCode(),&#10;                    'title' =&gt; 'Article mystère', // Ne pas révéler le vrai titre&#10;                    'hints' =&gt; $room-&gt;getHints()&#10;                ],&#10;                'player' =&gt; [&#10;                    'name' =&gt; $gameSession-&gt;getPlayerName(),&#10;                    'found_words' =&gt; $gameSession-&gt;getFoundWords(),&#10;                    'attempts' =&gt; $gameSession-&gt;getAttempts(),&#10;                    'score' =&gt; $gameSession-&gt;getScore(),&#10;                    'completed' =&gt; $gameSession-&gt;isCompleted()&#10;                ]&#10;            ]);&#10;        } catch (\Exception $e) {&#10;            return $this-&gt;json(['error' =&gt; $e-&gt;getMessage()], 500);&#10;        }&#10;    }&#10;&#10;    #[Route('/game/{roomCode}', name: 'app_game_room')]&#10;    public function gameRoom(string $roomCode): Response&#10;    {&#10;        return $this-&gt;render('game/room.html.twig', [&#10;            'room_code' =&gt; strtoupper($roomCode)&#10;        ]);&#10;    }&#10;&#10;    #[Route('/api/guess', name: 'app_submit_guess', methods: ['POST'])]&#10;    public function submitGuess(Request $request): JsonResponse&#10;    {&#10;        $data = json_decode($request-&gt;getContent(), true);&#10;        $sessionId = $data['session_id'] ?? null;&#10;        $guess = $data['guess'] ?? '';&#10;&#10;        if (!$sessionId || empty($guess)) {&#10;            return $this-&gt;json(['success' =&gt; false, 'error' =&gt; 'Session et mot requis'], 400);&#10;        }&#10;&#10;        try {&#10;            $gameSession = $this-&gt;pedantixService-&gt;getGameSession($sessionId);&#10;            if (!$gameSession) {&#10;                return $this-&gt;json(['success' =&gt; false, 'error' =&gt; 'Session invalide'], 400);&#10;            }&#10;&#10;            $result = $this-&gt;pedantixService-&gt;submitGuess($gameSession, $guess);&#10;&#10;            // Si c'est un doublon, retourner une erreur spécifique&#10;            if (isset($result['duplicate']) &amp;&amp; $result['duplicate']) {&#10;                return $this-&gt;json([&#10;                    'success' =&gt; false,&#10;                    'error' =&gt; 'Mot déjà essayé',&#10;                    'duplicate' =&gt; true,&#10;                    'word' =&gt; $result['word']&#10;                ], 400);&#10;            }&#10;&#10;            return $this-&gt;json([&#10;                'success' =&gt; true,&#10;                'result' =&gt; $result,&#10;                'player' =&gt; [&#10;                    'found_words' =&gt; $gameSession-&gt;getFoundWords(),&#10;                    'attempts' =&gt; $gameSession-&gt;getAttempts(),&#10;                    'score' =&gt; $gameSession-&gt;getScore(),&#10;                    'completed' =&gt; $gameSession-&gt;isCompleted()&#10;                ]&#10;            ]);&#10;        } catch (\Exception $e) {&#10;            return $this-&gt;json(['success' =&gt; false, 'error' =&gt; $e-&gt;getMessage()], 500);&#10;        }&#10;    }&#10;&#10;    #[Route('/api/article-content/{roomCode}', name: 'app_article_content')]&#10;    public function getArticleContent(string $roomCode, Request $request): JsonResponse&#10;    {&#10;        try {&#10;            $room = $this-&gt;pedantixService-&gt;getRoomByCode($roomCode);&#10;            if (!$room) {&#10;                return $this-&gt;json(['error' =&gt; 'Salle introuvable'], 404);&#10;            }&#10;&#10;            $sessionId = $request-&gt;query-&gt;get('session_id');&#10;            $foundWords = [];&#10;            $gameCompleted = false;&#10;            $proximityData = [];&#10;&#10;            if ($sessionId) {&#10;                $gameSession = $this-&gt;pedantixService-&gt;getGameSession($sessionId);&#10;                if ($gameSession) {&#10;                    $foundWords = $gameSession-&gt;getFoundWords();&#10;                    $gameCompleted = $gameSession-&gt;isCompleted();&#10;&#10;                    // Récupérer les données de proximité des dernières tentatives&#10;                    $proximityDataRaw = $request-&gt;query-&gt;get('proximity_data', '[]');&#10;                    if (is_string($proximityDataRaw)) {&#10;                        $decoded = json_decode($proximityDataRaw, true);&#10;                        if (is_array($decoded)) {&#10;                            $proximityData = $decoded;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            $processedContent = $this-&gt;pedantixService-&gt;getProcessedContent($room, $foundWords, $proximityData, $gameCompleted);&#10;&#10;            return $this-&gt;json([&#10;                'title' =&gt; $room-&gt;getTitle(),&#10;                'content' =&gt; $processedContent,&#10;                'total_words' =&gt; count($room-&gt;getWordsToFind()),&#10;                'game_completed' =&gt; $gameCompleted&#10;            ]);&#10;        } catch (\Exception $e) {&#10;            // Log l'erreur pour debugging&#10;            error_log('Erreur dans getArticleContent: ' . $e-&gt;getMessage() . ' - Trace: ' . $e-&gt;getTraceAsString());&#10;&#10;            return $this-&gt;json([&#10;                'error' =&gt; 'Erreur interne du serveur: ' . $e-&gt;getMessage(),&#10;                'debug_info' =&gt; [&#10;                    'line' =&gt; $e-&gt;getLine(),&#10;                    'file' =&gt; basename($e-&gt;getFile())&#10;                ]&#10;            ], 500);&#10;        }&#10;    }&#10;&#10;    #[Route('/api/leaderboard/{roomCode}', name: 'app_leaderboard')]&#10;    public function leaderboard(string $roomCode): JsonResponse&#10;    {&#10;        try {&#10;            $room = $this-&gt;pedantixService-&gt;getRoomByCode($roomCode);&#10;            if (!$room) {&#10;                return $this-&gt;json(['error' =&gt; 'Salle introuvable'], 404);&#10;            }&#10;&#10;            $leaderboard = $this-&gt;pedantixService-&gt;getLeaderboard($room);&#10;            $activePlayers = $this-&gt;pedantixService-&gt;getActivePlayers($room);&#10;&#10;            $leaderboardData = array_map(function($session) {&#10;                return [&#10;                    'player_name' =&gt; $session-&gt;getPlayerName(),&#10;                    'score' =&gt; $session-&gt;getScore(),&#10;                    'completed_at' =&gt; $session-&gt;getCompletedAt()?-&gt;format('Y-m-d H:i:s'),&#10;                    'attempts' =&gt; $session-&gt;getAttempts()&#10;                ];&#10;            }, $leaderboard);&#10;&#10;            $activePlayersData = array_map(function($session) {&#10;                return [&#10;                    'player_name' =&gt; $session-&gt;getPlayerName(),&#10;                    'score' =&gt; $session-&gt;getScore(),&#10;                    'found_words_count' =&gt; count($session-&gt;getFoundWords()),&#10;                    'last_activity' =&gt; $session-&gt;getLastActivity()-&gt;format('Y-m-d H:i:s')&#10;                ];&#10;            }, $activePlayers);&#10;&#10;            return $this-&gt;json([&#10;                'leaderboard' =&gt; $leaderboardData,&#10;                'active_players' =&gt; $activePlayersData&#10;            ]);&#10;        } catch (\Exception $e) {&#10;            return $this-&gt;json(['error' =&gt; $e-&gt;getMessage()], 500);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Entity/Room.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Entity/Room.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;namespace App\Entity;&#10;&#10;use App\Repository\RoomRepository;&#10;use Doctrine\Common\Collections\ArrayCollection;&#10;use Doctrine\Common\Collections\Collection;&#10;use Doctrine\ORM\Mapping as ORM;&#10;&#10;#[ORM\Entity(repositoryClass: RoomRepository::class)]&#10;class Room&#10;{&#10;    #[ORM\Id]&#10;    #[ORM\GeneratedValue]&#10;    #[ORM\Column]&#10;    private ?int $id = null;&#10;&#10;    #[ORM\Column(length: 10, unique: true)]&#10;    private ?string $code = null;&#10;&#10;    #[ORM\Column(length: 255)]&#10;    private ?string $title = null;&#10;&#10;    #[ORM\Column(type: 'text')]&#10;    private ?string $content = null;&#10;&#10;    #[ORM\Column(length: 255)]&#10;    private ?string $url = null;&#10;&#10;    #[ORM\Column]&#10;    private ?\DateTimeImmutable $createdAt = null;&#10;&#10;    #[ORM\Column]&#10;    private ?bool $isActive = true;&#10;&#10;    #[ORM\OneToMany(targetEntity: GameSession::class, mappedBy: 'room')]&#10;    private Collection $gameSessions;&#10;&#10;    #[ORM\Column(type: 'json')]&#10;    private array $wordsToFind = [];&#10;&#10;    #[ORM\Column(type: 'json')]&#10;    private array $hints = [];&#10;&#10;    public function __construct()&#10;    {&#10;        $this-&gt;gameSessions = new ArrayCollection();&#10;        $this-&gt;createdAt = new \DateTimeImmutable();&#10;        $this-&gt;code = $this-&gt;generateRoomCode();&#10;    }&#10;&#10;    public function getId(): ?int&#10;    {&#10;        return $this-&gt;id;&#10;    }&#10;&#10;    public function getCode(): ?string&#10;    {&#10;        return $this-&gt;code;&#10;    }&#10;&#10;    public function setCode(string $code): static&#10;    {&#10;        $this-&gt;code = $code;&#10;        return $this;&#10;    }&#10;&#10;    public function getTitle(): ?string&#10;    {&#10;        return $this-&gt;title;&#10;    }&#10;&#10;    public function setTitle(string $title): static&#10;    {&#10;        $this-&gt;title = $title;&#10;        return $this;&#10;    }&#10;&#10;    public function getContent(): ?string&#10;    {&#10;        return $this-&gt;content;&#10;    }&#10;&#10;    public function setContent(string $content): static&#10;    {&#10;        $this-&gt;content = $content;&#10;        return $this;&#10;    }&#10;&#10;    public function getUrl(): ?string&#10;    {&#10;        return $this-&gt;url;&#10;    }&#10;&#10;    public function setUrl(string $url): static&#10;    {&#10;        $this-&gt;url = $url;&#10;        return $this;&#10;    }&#10;&#10;    public function getCreatedAt(): ?\DateTimeImmutable&#10;    {&#10;        return $this-&gt;createdAt;&#10;    }&#10;&#10;    public function setCreatedAt(\DateTimeImmutable $createdAt): static&#10;    {&#10;        $this-&gt;createdAt = $createdAt;&#10;        return $this;&#10;    }&#10;&#10;    public function isActive(): ?bool&#10;    {&#10;        return $this-&gt;isActive;&#10;    }&#10;&#10;    public function setActive(bool $isActive): static&#10;    {&#10;        $this-&gt;isActive = $isActive;&#10;        return $this;&#10;    }&#10;&#10;    /**&#10;     * @return Collection&lt;int, GameSession&gt;&#10;     */&#10;    public function getGameSessions(): Collection&#10;    {&#10;        return $this-&gt;gameSessions;&#10;    }&#10;&#10;    public function addGameSession(GameSession $gameSession): static&#10;    {&#10;        if (!$this-&gt;gameSessions-&gt;contains($gameSession)) {&#10;            $this-&gt;gameSessions-&gt;add($gameSession);&#10;            $gameSession-&gt;setRoom($this);&#10;        }&#10;&#10;        return $this;&#10;    }&#10;&#10;    public function removeGameSession(GameSession $gameSession): static&#10;    {&#10;        if ($this-&gt;gameSessions-&gt;removeElement($gameSession)) {&#10;            if ($gameSession-&gt;getRoom() === $this) {&#10;                $gameSession-&gt;setRoom(null);&#10;            }&#10;        }&#10;&#10;        return $this;&#10;    }&#10;&#10;    public function getWordsToFind(): array&#10;    {&#10;        return $this-&gt;wordsToFind;&#10;    }&#10;&#10;    public function setWordsToFind(array $wordsToFind): static&#10;    {&#10;        $this-&gt;wordsToFind = $wordsToFind;&#10;        return $this;&#10;    }&#10;&#10;    public function getHints(): array&#10;    {&#10;        return $this-&gt;hints;&#10;    }&#10;&#10;    public function setHints(array $hints): static&#10;    {&#10;        $this-&gt;hints = $hints;&#10;        return $this;&#10;    }&#10;&#10;    private function generateRoomCode(): string&#10;    {&#10;        return strtoupper(substr(md5(uniqid()), 0, 6));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;namespace App\Entity;&#10;&#10;use App\Repository\RoomRepository;&#10;use Doctrine\Common\Collections\ArrayCollection;&#10;use Doctrine\Common\Collections\Collection;&#10;use Doctrine\ORM\Mapping as ORM;&#10;&#10;#[ORM\Entity(repositoryClass: RoomRepository::class)]&#10;class Room&#10;{&#10;    #[ORM\Id]&#10;    #[ORM\GeneratedValue]&#10;    #[ORM\Column]&#10;    private ?int $id = null;&#10;&#10;    #[ORM\Column(length: 10, unique: true)]&#10;    private ?string $code = null;&#10;&#10;    #[ORM\Column(length: 255)]&#10;    private ?string $title = null;&#10;&#10;    #[ORM\Column(type: 'text')]&#10;    private ?string $content = null;&#10;&#10;    #[ORM\Column(length: 255)]&#10;    private ?string $url = null;&#10;&#10;    #[ORM\Column]&#10;    private ?\DateTimeImmutable $createdAt = null;&#10;&#10;    #[ORM\Column]&#10;    private ?bool $isActive = true;&#10;&#10;    #[ORM\Column(length: 20)]&#10;    private ?string $gameMode = 'competition';&#10;&#10;    #[ORM\OneToMany(targetEntity: GameSession::class, mappedBy: 'room')]&#10;    private Collection $gameSessions;&#10;&#10;    #[ORM\Column(type: 'json')]&#10;    private array $wordsToFind = [];&#10;&#10;    #[ORM\Column(type: 'json')]&#10;    private array $hints = [];&#10;&#10;    #[ORM\Column(type: 'json')]&#10;    private array $globalFoundWords = [];&#10;&#10;    public function __construct()&#10;    {&#10;        $this-&gt;gameSessions = new ArrayCollection();&#10;        $this-&gt;createdAt = new \DateTimeImmutable();&#10;        $this-&gt;code = $this-&gt;generateRoomCode();&#10;    }&#10;&#10;    public function getId(): ?int&#10;    {&#10;        return $this-&gt;id;&#10;    }&#10;&#10;    public function getCode(): ?string&#10;    {&#10;        return $this-&gt;code;&#10;    }&#10;&#10;    public function setCode(string $code): static&#10;    {&#10;        $this-&gt;code = $code;&#10;        return $this;&#10;    }&#10;&#10;    public function getTitle(): ?string&#10;    {&#10;        return $this-&gt;title;&#10;    }&#10;&#10;    public function setTitle(string $title): static&#10;    {&#10;        $this-&gt;title = $title;&#10;        return $this;&#10;    }&#10;&#10;    public function getContent(): ?string&#10;    {&#10;        return $this-&gt;content;&#10;    }&#10;&#10;    public function setContent(string $content): static&#10;    {&#10;        $this-&gt;content = $content;&#10;        return $this;&#10;    }&#10;&#10;    public function getUrl(): ?string&#10;    {&#10;        return $this-&gt;url;&#10;    }&#10;&#10;    public function setUrl(string $url): static&#10;    {&#10;        $this-&gt;url = $url;&#10;        return $this;&#10;    }&#10;&#10;    public function getCreatedAt(): ?\DateTimeImmutable&#10;    {&#10;        return $this-&gt;createdAt;&#10;    }&#10;&#10;    public function setCreatedAt(\DateTimeImmutable $createdAt): static&#10;    {&#10;        $this-&gt;createdAt = $createdAt;&#10;        return $this;&#10;    }&#10;&#10;    public function isActive(): ?bool&#10;    {&#10;        return $this-&gt;isActive;&#10;    }&#10;&#10;    public function setActive(bool $isActive): static&#10;    {&#10;        $this-&gt;isActive = $isActive;&#10;        return $this;&#10;    }&#10;&#10;    /**&#10;     * @return Collection&lt;int, GameSession&gt;&#10;     */&#10;    public function getGameSessions(): Collection&#10;    {&#10;        return $this-&gt;gameSessions;&#10;    }&#10;&#10;    public function addGameSession(GameSession $gameSession): static&#10;    {&#10;        if (!$this-&gt;gameSessions-&gt;contains($gameSession)) {&#10;            $this-&gt;gameSessions-&gt;add($gameSession);&#10;            $gameSession-&gt;setRoom($this);&#10;        }&#10;&#10;        return $this;&#10;    }&#10;&#10;    public function removeGameSession(GameSession $gameSession): static&#10;    {&#10;        if ($this-&gt;gameSessions-&gt;removeElement($gameSession)) {&#10;            if ($gameSession-&gt;getRoom() === $this) {&#10;                $gameSession-&gt;setRoom(null);&#10;            }&#10;        }&#10;&#10;        return $this;&#10;    }&#10;&#10;    public function getWordsToFind(): array&#10;    {&#10;        return $this-&gt;wordsToFind;&#10;    }&#10;&#10;    public function setWordsToFind(array $wordsToFind): static&#10;    {&#10;        $this-&gt;wordsToFind = $wordsToFind;&#10;        return $this;&#10;    }&#10;&#10;    public function getHints(): array&#10;    {&#10;        return $this-&gt;hints;&#10;    }&#10;&#10;    public function setHints(array $hints): static&#10;    {&#10;        $this-&gt;hints = $hints;&#10;        return $this;&#10;    }&#10;&#10;    public function getGameMode(): ?string&#10;    {&#10;        return $this-&gt;gameMode;&#10;    }&#10;&#10;    public function setGameMode(string $gameMode): static&#10;    {&#10;        $this-&gt;gameMode = $gameMode;&#10;        return $this;&#10;    }&#10;&#10;    public function isCooperativeMode(): bool&#10;    {&#10;        return $this-&gt;gameMode === 'cooperation';&#10;    }&#10;&#10;    public function isCompetitiveMode(): bool&#10;    {&#10;        return $this-&gt;gameMode === 'competition';&#10;    }&#10;&#10;    public function getGlobalFoundWords(): array&#10;    {&#10;        return $this-&gt;globalFoundWords;&#10;    }&#10;&#10;    public function setGlobalFoundWords(array $globalFoundWords): static&#10;    {&#10;        $this-&gt;globalFoundWords = $globalFoundWords;&#10;        return $this;&#10;    }&#10;&#10;    public function addGlobalFoundWord(string $word): static&#10;    {&#10;        if (!in_array($word, $this-&gt;globalFoundWords)) {&#10;            $this-&gt;globalFoundWords[] = $word;&#10;        }&#10;        return $this;&#10;    }&#10;&#10;    private function generateRoomCode(): string&#10;    {&#10;        return strtoupper(substr(md5(uniqid()), 0, 6));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Service/PedantixService.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Service/PedantixService.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;namespace App\Service;&#10;&#10;use App\Entity\GameSession;&#10;use App\Entity\Room;&#10;use App\Repository\GameSessionRepository;&#10;use App\Repository\RoomRepository;&#10;use Doctrine\ORM\EntityManagerInterface;&#10;&#10;class PedantixService&#10;{&#10;    public function __construct(&#10;        private EntityManagerInterface $entityManager,&#10;        private RoomRepository $roomRepository,&#10;        private GameSessionRepository $gameSessionRepository&#10;    ) {}&#10;&#10;    public function createRoom(string $wikipediaUrl): Room&#10;    {&#10;        $articleData = $this-&gt;fetchWikipediaArticle($wikipediaUrl);&#10;&#10;        $room = new Room();&#10;        $room-&gt;setTitle($articleData['title']);&#10;        $room-&gt;setContent($articleData['content']);&#10;        $room-&gt;setUrl($wikipediaUrl);&#10;        $room-&gt;setWordsToFind($articleData['allWords']);&#10;        $room-&gt;setHints([]); // Pas d'indices dans le vrai Pedantix&#10;&#10;        $this-&gt;roomRepository-&gt;save($room, true);&#10;&#10;        return $room;&#10;    }&#10;&#10;    public function joinRoom(string $roomCode, string $playerName, string $ipAddress): ?GameSession&#10;    {&#10;        $room = $this-&gt;roomRepository-&gt;findByCode($roomCode);&#10;        if (!$room) {&#10;            return null;&#10;        }&#10;&#10;        // Chercher une session existante pour ce joueur&#10;        $existingSession = $this-&gt;gameSessionRepository-&gt;findByRoomAndPlayer($room, $playerName, $ipAddress);&#10;&#10;        if ($existingSession) {&#10;            $existingSession-&gt;updateActivity();&#10;            $this-&gt;gameSessionRepository-&gt;save($existingSession, true);&#10;            return $existingSession;&#10;        }&#10;&#10;        // Créer une nouvelle session&#10;        $gameSession = new GameSession();&#10;        $gameSession-&gt;setRoom($room);&#10;        $gameSession-&gt;setPlayerName($playerName);&#10;        $gameSession-&gt;setIpAddress($ipAddress);&#10;&#10;        $this-&gt;gameSessionRepository-&gt;save($gameSession, true);&#10;&#10;        return $gameSession;&#10;    }&#10;&#10;    public function submitGuess(GameSession $gameSession, string $guess): array&#10;    {&#10;        $guess = trim($guess);&#10;        $room = $gameSession-&gt;getRoom();&#10;        $content = $room-&gt;getContent();&#10;&#10;        // Vérifier si le mot a déjà été essayé par ce joueur&#10;        $normalizedGuess = $this-&gt;normalizeWord($guess);&#10;        $foundWordsNormalized = array_map([$this, 'normalizeWord'], $gameSession-&gt;getFoundWords());&#10;&#10;        if (in_array($normalizedGuess, $foundWordsNormalized)) {&#10;            return [&#10;                'found' =&gt; false,&#10;                'word' =&gt; $guess,&#10;                'proximity' =&gt; null,&#10;                'gameCompleted' =&gt; false,&#10;                'isExactMatch' =&gt; false,&#10;                'error' =&gt; 'Mot déjà trouvé',&#10;                'duplicate' =&gt; true&#10;            ];&#10;        }&#10;&#10;        $gameSession-&gt;incrementAttempts();&#10;        $gameSession-&gt;updateActivity();&#10;&#10;        $result = [&#10;            'found' =&gt; false,&#10;            'word' =&gt; $guess,&#10;            'proximity' =&gt; null,&#10;            'gameCompleted' =&gt; false,&#10;            'isExactMatch' =&gt; false,&#10;            'duplicate' =&gt; false&#10;        ];&#10;&#10;        // Vérifier si c'est le mot-titre (victoire)&#10;        $titleWords = $this-&gt;extractTitleWords($room-&gt;getTitle());&#10;&#10;        foreach ($titleWords as $titleWord) {&#10;            if ($this-&gt;normalizeWord($titleWord) === $normalizedGuess) {&#10;                $result['found'] = true;&#10;                $result['isExactMatch'] = true;&#10;                $result['gameCompleted'] = true;&#10;                $gameSession-&gt;addFoundWord($guess);&#10;                $gameSession-&gt;setCompleted(true);&#10;&#10;                // Score final basé sur le nombre de tentatives (moins = mieux)&#10;                $finalScore = max(1000 - ($gameSession-&gt;getAttempts() * 10), 100);&#10;                $gameSession-&gt;setScore($finalScore);&#10;&#10;                $this-&gt;gameSessionRepository-&gt;save($gameSession, true);&#10;                return $result;&#10;            }&#10;        }&#10;&#10;        // Vérifier si le mot existe dans l'article&#10;        if ($this-&gt;wordExistsInArticle($guess, $content)) {&#10;            $result['found'] = true;&#10;            $gameSession-&gt;addFoundWord($guess);&#10;&#10;            // Ajouter des points pour chaque mot trouvé (seulement si pas déjà trouvé)&#10;            $currentScore = $gameSession-&gt;getScore() + 10;&#10;            $gameSession-&gt;setScore($currentScore);&#10;        } else {&#10;            // Calculer la proximité sémantique avec les mots de l'article&#10;            $result['proximity'] = $this-&gt;calculateSemanticProximity($guess, $content, $room-&gt;getTitle());&#10;        }&#10;&#10;        $this-&gt;gameSessionRepository-&gt;save($gameSession, true);&#10;        return $result;&#10;    }&#10;&#10;    public function getProcessedContent(Room $room, array $foundWords, array $proximityData = [], bool $gameCompleted = false): string&#10;    {&#10;        $content = $room-&gt;getContent();&#10;        $foundWordsNormalized = array_map([$this, 'normalizeWord'], $foundWords);&#10;&#10;        // Si le jeu est terminé, révéler tous les mots&#10;        if ($gameCompleted) {&#10;            // Diviser le contenu en mots tout en préservant la ponctuation et la structure&#10;            $words = preg_split('/(\s+|[.,;:!?()&quot;\'-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;            $processedWords = [];&#10;            foreach ($words as $word) {&#10;                if (trim($word) === '' || preg_match('/^\s*$/', $word) || preg_match('/^[.,;:!?()&quot;\'-]+$/', $word)) {&#10;                    // Espaces et ponctuation - garder tel quel&#10;                    $processedWords[] = $word;&#10;                } else {&#10;                    // Tous les mots sont révélés avec le style de victoire&#10;                    $processedWords[] = '&lt;span class=&quot;title-word&quot;&gt;' . htmlspecialchars($word) . '&lt;/span&gt;';&#10;                }&#10;            }&#10;&#10;            return implode('', $processedWords);&#10;        }&#10;&#10;        // Créer un mapping des mots de l'article vers les mots devinés les plus proches&#10;        $wordProximityMapping = $this-&gt;buildWordProximityMapping($content, $proximityData);&#10;&#10;        // Créer un mapping des proximités sémantiques pour les mots trouvés&#10;        $semanticProximityMapping = $this-&gt;buildSemanticProximityMapping($content, $foundWords);&#10;&#10;        // Comportement normal : diviser le contenu en mots tout en préservant la ponctuation et la structure&#10;        $words = preg_split('/(\s+|[.,;:!?()&quot;\'-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;        $processedWords = [];&#10;        foreach ($words as $word) {&#10;            if (trim($word) === '' || preg_match('/^\s*$/', $word) || preg_match('/^[.,;:!?()&quot;\'-]+$/', $word)) {&#10;                // Espaces et ponctuation - garder tel quel&#10;                $processedWords[] = $word;&#10;            } else {&#10;                // C'est un mot - vérifier s'il doit être dévoilé&#10;                $normalizedWord = $this-&gt;normalizeWord($word);&#10;                $isRevealed = $this-&gt;isWordRevealed($word, $foundWordsNormalized);&#10;&#10;                if ($isRevealed) {&#10;                    // Mot trouvé : affichage en texte noir normal sans arrière-plan&#10;                    $processedWords[] = '&lt;span class=&quot;revealed-word&quot;&gt;' . htmlspecialchars($word) . '&lt;/span&gt;';&#10;                } else {&#10;                    // Vérifier si ce mot a une proximité sémantique avec un mot trouvé&#10;                    if (isset($semanticProximityMapping[$normalizedWord])) {&#10;                        $semanticInfo = $semanticProximityMapping[$normalizedWord];&#10;                        $foundWord = $semanticInfo['found_word'];&#10;                        $proximityScore = $semanticInfo['proximity'];&#10;                        $colorStyle = $this-&gt;getProximityColorStyle($proximityScore);&#10;&#10;                        // Afficher le mot trouvé avec la couleur de proximité sémantique&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word-with-proximity&quot; style=&quot;' . $colorStyle . '&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot; data-found=&quot;' . htmlspecialchars($foundWord) . '&quot; data-proximity=&quot;' . $proximityScore . '&quot;&gt;' . htmlspecialchars($foundWord) . '&lt;/span&gt;';&#10;                    } else if (isset($wordProximityMapping[$normalizedWord])) {&#10;                        // Vérifier la proximité avec les mots devinés mais non trouvés&#10;                        $proximityInfo = $wordProximityMapping[$normalizedWord];&#10;                        $guessedWord = $proximityInfo['guessed_word'];&#10;                        $proximityScore = $proximityInfo['proximity'];&#10;                        $colorStyle = $this-&gt;getProximityColorStyle($proximityScore);&#10;&#10;                        // Afficher le mot deviné avec la couleur de proximité&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word-with-proximity&quot; style=&quot;' . $colorStyle . '&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot; data-guessed=&quot;' . htmlspecialchars($guessedWord) . '&quot; data-proximity=&quot;' . $proximityScore . '&quot;&gt;' . htmlspecialchars($guessedWord) . '&lt;/span&gt;';&#10;                    } else {&#10;                        // Mot complètement caché&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot;&gt;' . str_repeat('█', mb_strlen($word)) . '&lt;/span&gt;';&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return implode('', $processedWords);&#10;    }&#10;&#10;    /**&#10;     * Vérifie si un mot de l'article doit être révélé basé sur les mots trouvés par le joueur&#10;     * Prend en compte les conjugaisons et variations&#10;     */&#10;    private function isWordRevealed(string $articleWord, array $foundWordsNormalized): bool&#10;    {&#10;        $normalizedArticleWord = $this-&gt;normalizeWord($articleWord);&#10;&#10;        // Vérification directe&#10;        if (in_array($normalizedArticleWord, $foundWordsNormalized)) {&#10;            return true;&#10;        }&#10;&#10;        // Vérifier si le mot de l'article est une conjugaison d'un des mots trouvés&#10;        foreach ($foundWordsNormalized as $foundWord) {&#10;            if ($this-&gt;isVerbConjugation($foundWord, $normalizedArticleWord)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        // Vérifier les contractions avec apostrophes&#10;        if (strpos($articleWord, &quot;'&quot;) !== false) {&#10;            $parts = explode(&quot;'&quot;, $articleWord);&#10;            foreach ($parts as $part) {&#10;                $normalizedPart = $this-&gt;normalizeWord($part);&#10;                if (in_array($normalizedPart, $foundWordsNormalized)) {&#10;                    return true;&#10;                }&#10;                // Vérifier les conjugaisons pour chaque partie&#10;                foreach ($foundWordsNormalized as $foundWord) {&#10;                    if ($this-&gt;isVerbConjugation($foundWord, $normalizedPart)) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    public function getLeaderboard(Room $room): array&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;getLeaderboard($room);&#10;    }&#10;&#10;    public function getActivePlayers(Room $room): array&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;findActiveSessionsForRoom($room);&#10;    }&#10;&#10;    public function getRoomByCode(string $code): ?Room&#10;    {&#10;        return $this-&gt;roomRepository-&gt;findByCode($code);&#10;    }&#10;&#10;    public function getGameSession(int $sessionId): ?GameSession&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;find($sessionId);&#10;    }&#10;&#10;    private function fetchWikipediaArticle(string $url): array&#10;    {&#10;        $title = $this-&gt;extractTitleFromUrl($url);&#10;&#10;        // Utiliser l'API de résumé de Wikipedia qui donne directement l'introduction&#10;        $summaryApiUrl = &quot;https://fr.wikipedia.org/api/rest_v1/page/summary/&quot; . urlencode($title);&#10;&#10;        $context = stream_context_create([&#10;            'http' =&gt; [&#10;                'header' =&gt; &quot;User-Agent: PedantixApp/1.0\r\n&quot;,&#10;                'timeout' =&gt; 30,&#10;                'ignore_errors' =&gt; true&#10;            ]&#10;        ]);&#10;&#10;        try {&#10;            $summaryResponse = file_get_contents($summaryApiUrl, false, $context);&#10;&#10;            if ($summaryResponse === false) {&#10;                $error = error_get_last();&#10;                throw new \Exception('Impossible de récupérer l\'article Wikipedia: ' . ($error['message'] ?? 'Erreur de connexion'));&#10;            }&#10;&#10;            $summaryData = json_decode($summaryResponse, true);&#10;&#10;            if (!$summaryData) {&#10;                throw new \Exception('Réponse invalide de l\'API Wikipedia');&#10;            }&#10;&#10;            if (isset($summaryData['type']) &amp;&amp; $summaryData['type'] === 'disambiguation') {&#10;                throw new \Exception('Cette page est une page de désambiguïsation. Veuillez choisir un article plus spécifique.');&#10;            }&#10;&#10;            if (!isset($summaryData['extract']) || empty($summaryData['extract'])) {&#10;                throw new \Exception('Contenu de l\'article introuvable ou vide');&#10;            }&#10;&#10;            // L'extract contient déjà un résumé propre de l'article&#10;            $content = $summaryData['extract'];&#10;&#10;            // Nettoyer un peu plus le contenu pour enlever les références restantes&#10;            $content = preg_replace('/\[[\d,\s]+\]/', '', $content); // Supprimer les références [1], [2,3], etc.&#10;            $content = preg_replace('/\s+/', ' ', $content); // Normaliser les espaces&#10;            $content = trim($content);&#10;&#10;            if (strlen($content) &lt; 50) {&#10;                throw new \Exception('L\'article est trop court pour créer une partie intéressante');&#10;            }&#10;&#10;            $properTitle = $summaryData['title'] ?? $title;&#10;&#10;            return [&#10;                'title' =&gt; $properTitle,&#10;                'content' =&gt; $content,&#10;                'allWords' =&gt; $this-&gt;extractAllWords($content)&#10;            ];&#10;        } catch (\Exception $e) {&#10;            // Log l'erreur pour debugging&#10;            error_log('Erreur fetchWikipediaArticle: ' . $e-&gt;getMessage() . ' pour URL: ' . $url);&#10;            throw $e;&#10;        }&#10;    }&#10;&#10;    private function cleanWikipediaContent(string $html): string&#10;    {&#10;        // Supprimer les balises non désirées&#10;        $html = preg_replace('/&lt;script.*?&lt;\/script&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;style.*?&lt;\/style&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;figure.*?&lt;\/figure&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;table.*?&lt;\/table&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*infobox[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;&#10;        // Supprimer TOUTES les boîtes d'aide, navigation et métadonnées&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*dablink[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*hatnote[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*disambig[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*navigation[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*navbox[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*metadata[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;&#10;        // Approche plus simple et plus stricte : extraire seulement les 2-3 premiers vrais paragraphes&#10;        preg_match_all('/&lt;p[^&gt;]*&gt;(.*?)&lt;\/p&gt;/is', $html, $matches);&#10;        $allParagraphs = $matches[1];&#10;&#10;        $introContent = [];&#10;        $paragraphCount = 0;&#10;&#10;        foreach ($allParagraphs as $paragraph) {&#10;            $cleaned = strip_tags($paragraph);&#10;            $cleaned = html_entity_decode($cleaned, ENT_QUOTES, 'UTF-8');&#10;            $cleaned = preg_replace('/\s+/', ' ', $cleaned);&#10;            $cleaned = trim($cleaned);&#10;&#10;            // Filtres très stricts pour ne garder que l'introduction&#10;            if (!empty($cleaned) &amp;&amp;&#10;                strlen($cleaned) &gt; 30 &amp;&amp; // Paragraphes substantiels seulement&#10;                !preg_match('/^(Pour les articles|Page d\'aide|Ne doit pas être confondu|Cet article|voir|redirigé|coordination|modifier|wikidata)/i', $cleaned) &amp;&amp;&#10;                !preg_match('/(homonymie|homonymes|voir aussi|articles connexes|catégorie|portail)/i', $cleaned) &amp;&amp;&#10;                !preg_match('/^\s*(modifier|edit|\[|\()/i', $cleaned)) {&#10;&#10;                $introContent[] = $cleaned;&#10;                $paragraphCount++;&#10;&#10;                // LIMITER STRICTEMENT à 2-3 paragraphes d'introduction maximum&#10;                if ($paragraphCount &gt;= 2) {&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;        // S'assurer qu'on a au moins quelque chose de substantiel&#10;        if (empty($introContent)) {&#10;            return &quot;L'eau est un composé chimique ubiquitaire sur la Terre, essentiel pour tous les organismes vivants connus.&quot;;&#10;        }&#10;&#10;        return implode(&quot;\n\n&quot;, $introContent);&#10;    }&#10;&#10;    private function getElementPosition(\DOMNode $element): int&#10;    {&#10;        $position = 0;&#10;        $current = $element;&#10;&#10;        while ($current-&gt;previousSibling !== null) {&#10;            $current = $current-&gt;previousSibling;&#10;            $position++;&#10;        }&#10;&#10;        // Ajouter la position des parents&#10;        if ($current-&gt;parentNode !== null &amp;&amp; $current-&gt;parentNode-&gt;nodeName !== '#document') {&#10;            $position += $this-&gt;getElementPosition($current-&gt;parentNode) * 1000;&#10;        }&#10;&#10;        return $position;&#10;    }&#10;&#10;    private function extractTitleFromUrl(string $url): string&#10;    {&#10;        $path = parse_url($url, PHP_URL_PATH);&#10;        $title = basename($path);&#10;        return urldecode($title);&#10;    }&#10;&#10;    private function extractAllWords(string $content): array&#10;    {&#10;        $words = preg_split('/\s+/', $content);&#10;        $cleanWords = [];&#10;&#10;        foreach ($words as $word) {&#10;            $cleaned = $this-&gt;normalizeWord($word);&#10;            if (strlen($cleaned) &gt;= 2 &amp;&amp; !in_array($cleaned, $this-&gt;getStopWords())) {&#10;                $cleanWords[] = $cleaned;&#10;            }&#10;        }&#10;&#10;        return array_unique($cleanWords);&#10;    }&#10;&#10;    private function extractAllWordsFromContent(string $content): array&#10;    {&#10;        // Extraire tous les mots du contenu en préservant la structure&#10;        $words = preg_split('/(\s+|[.,;:!?()&quot;\-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;        $cleanWords = [];&#10;&#10;        foreach ($words as $word) {&#10;            $cleanWord = trim($word);&#10;            if (empty($cleanWord) || preg_match('/^[.,;:!?()&quot;\'\\-\\s]+$/', $cleanWord)) {&#10;                continue;&#10;            }&#10;&#10;            // Traitement spécial pour les mots avec apostrophes&#10;            if (strpos($cleanWord, &quot;'&quot;) !== false) {&#10;                $parts = explode(&quot;'&quot;, $cleanWord);&#10;                foreach ($parts as $part) {&#10;                    $part = trim($part);&#10;                    if (!empty($part) &amp;&amp; strlen($part) &gt;= 2) {&#10;                        $cleanWords[] = $part;&#10;                    }&#10;                }&#10;            } else {&#10;                if (strlen($cleanWord) &gt;= 2) {&#10;                    $cleanWords[] = $cleanWord;&#10;                }&#10;            }&#10;        }&#10;&#10;        return $cleanWords;&#10;    }&#10;&#10;    private function extractTitleWords(string $title): array&#10;    {&#10;        // Extraire tous les mots significatifs du titre&#10;        $words = preg_split('/\s+/', $title);&#10;        $titleWords = [];&#10;&#10;        foreach ($words as $word) {&#10;            $cleaned = $this-&gt;normalizeWord($word);&#10;            if (strlen($cleaned) &gt;= 2) {&#10;                $titleWords[] = $word; // Garder le mot original, pas normalisé&#10;            }&#10;        }&#10;&#10;        return $titleWords;&#10;    }&#10;&#10;    private function normalizeWord(string $word): string&#10;    {&#10;        // Enlever la ponctuation et normaliser&#10;        $word = preg_replace('/[^\p{L}\p{N}]/u', '', $word);&#10;        $word = mb_strtolower($word, 'UTF-8');&#10;&#10;        // Enlever les accents pour la comparaison&#10;        $word = iconv('UTF-8', 'ASCII//TRANSLIT//IGNORE', $word);&#10;        $word = preg_replace('/[^a-z0-9]/', '', $word);&#10;&#10;        return $word;&#10;    }&#10;&#10;    private function wordExistsInArticle(string $guess, string $content): bool&#10;    {&#10;        $normalizedGuess = $this-&gt;normalizeWord($guess);&#10;&#10;        // Cas spécial pour les contractions comme &quot;l'&quot;&#10;        if (strlen($guess) == 1 &amp;&amp; in_array(strtolower($guess), ['l', 'd', 'j', 'n', 'm', 'c', 's', 't'])) {&#10;            // Rechercher des patterns comme &quot;l'eau&quot;, &quot;d'eau&quot;, etc.&#10;            $pattern = '/\b' . preg_quote(strtolower($guess)) . '\'/i';&#10;            if (preg_match($pattern, $content)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        // Diviser le contenu en mots en préservant les apostrophes&#10;        $words = preg_split('/(\s+|[.,;:!?()&quot;\-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;        foreach ($words as $word) {&#10;            $cleanWord = trim($word);&#10;            if (empty($cleanWord)) continue;&#10;&#10;            // Traitement spécial pour les mots avec apostrophes&#10;            if (strpos($cleanWord, &quot;'&quot;) !== false) {&#10;                $parts = explode(&quot;'&quot;, $cleanWord);&#10;                foreach ($parts as $part) {&#10;                    if ($this-&gt;normalizeWord($part) === $normalizedGuess) {&#10;                        return true;&#10;                    }&#10;                    // Vérifier les conjugaisons pour les parties de mots avec apostrophe&#10;                    if ($this-&gt;isVerbConjugation($normalizedGuess, $this-&gt;normalizeWord($part))) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;&#10;            $normalizedWord = $this-&gt;normalizeWord($cleanWord);&#10;            if ($normalizedWord === $normalizedGuess) {&#10;                return true;&#10;            }&#10;&#10;            // Vérifier si le mot deviné est un infinitif et le mot de l'article une conjugaison&#10;            if ($this-&gt;isVerbConjugation($normalizedGuess, $normalizedWord)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Vérifie si un mot est une conjugaison d'un verbe à l'infinitif&#10;     */&#10;    private function isVerbConjugation(string $infinitive, string $word): bool&#10;    {&#10;        // Patterns de conjugaison française simplifiés&#10;        $conjugationPatterns = $this-&gt;getConjugationPatterns();&#10;&#10;        foreach ($conjugationPatterns as $ending =&gt; $replacements) {&#10;            if (str_ends_with($infinitive, $ending)) {&#10;                $stem = substr($infinitive, 0, -strlen($ending));&#10;&#10;                foreach ($replacements as $replacement) {&#10;                    $conjugated = $stem . $replacement;&#10;                    if ($conjugated === $word) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Vérifier aussi les verbes irréguliers les plus courants&#10;        $irregularVerbs = $this-&gt;getIrregularVerbs();&#10;        if (isset($irregularVerbs[$infinitive])) {&#10;            return in_array($word, $irregularVerbs[$infinitive]);&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Patterns de conjugaison pour les verbes réguliers&#10;     */&#10;    private function getConjugationPatterns(): array&#10;    {&#10;        return [&#10;            'er' =&gt; [&#10;                'e', 'es', 'e', 'ons', 'ez', 'ent', // présent&#10;                'ais', 'ais', 'ait', 'ions', 'iez', 'aient', // imparfait&#10;                'ai', 'as', 'a', 'ames', 'ates', 'erent', // passé simple&#10;                'erai', 'eras', 'era', 'erons', 'erez', 'eront', // futur&#10;                'erais', 'erais', 'erait', 'erions', 'eriez', 'eraient', // conditionnel&#10;                'ant', 'e', // participes&#10;            ],&#10;            'ir' =&gt; [&#10;                'is', 'is', 'it', 'issons', 'issez', 'issent', // présent&#10;                'issais', 'issais', 'issait', 'issions', 'issiez', 'issaient', // imparfait&#10;                'is', 'is', 'it', 'imes', 'ites', 'irent', // passé simple&#10;                'irai', 'iras', 'ira', 'irons', 'irez', 'iront', // futur&#10;                'irais', 'irais', 'irait', 'irions', 'iriez', 'iraient', // conditionnel&#10;                'issant', 'i', // participes&#10;            ],&#10;            're' =&gt; [&#10;                's', 's', '', 'ons', 'ez', 'ent', // présent&#10;                'ais', 'ais', 'ait', 'ions', 'iez', 'aient', // imparfait&#10;                'is', 'is', 'it', 'imes', 'ites', 'irent', // passé simple&#10;                'rai', 'ras', 'ra', 'rons', 'rez', 'ront', // futur&#10;                'rais', 'rais', 'rait', 'rions', 'riez', 'raient', // conditionnel&#10;                'ant', 'u', // participes&#10;            ]&#10;        ];&#10;    }&#10;&#10;    /**&#10;     * Verbes irréguliers les plus courants&#10;     */&#10;    private function getIrregularVerbs(): array&#10;    {&#10;        return [&#10;            'etre' =&gt; ['suis', 'es', 'est', 'sommes', 'etes', 'sont', 'etais', 'etait', 'etions', 'etiez', 'etaient', 'fus', 'fut', 'fumes', 'furent', 'serai', 'seras', 'sera', 'serons', 'serez', 'seront', 'serais', 'serait', 'serions', 'seriez', 'seraient', 'etant', 'ete'],&#10;            'avoir' =&gt; ['ai', 'as', 'a', 'avons', 'avez', 'ont', 'avais', 'avait', 'avions', 'aviez', 'avaient', 'eus', 'eut', 'eumes', 'eurent', 'aurai', 'auras', 'aura', 'aurons', 'aurez', 'auront', 'aurais', 'aurait', 'aurions', 'auriez', 'auraient', 'ayant', 'eu'],&#10;            'aller' =&gt; ['vais', 'vas', 'va', 'allons', 'allez', 'vont', 'allais', 'allait', 'allions', 'alliez', 'allaient', 'allai', 'alla', 'allames', 'allerent', 'irai', 'iras', 'ira', 'irons', 'irez', 'iront', 'irais', 'irait', 'irions', 'iriez', 'iraient', 'allant', 'alle'],&#10;            'faire' =&gt; ['fais', 'fait', 'faisons', 'faites', 'font', 'faisais', 'faisait', 'faisions', 'faisiez', 'faisaient', 'fis', 'fit', 'fimes', 'firent', 'ferai', 'feras', 'fera', 'ferons', 'ferez', 'feront', 'ferais', 'ferait', 'ferions', 'feriez', 'feraient', 'faisant', 'fait'],&#10;            'dire' =&gt; ['dis', 'dit', 'disons', 'dites', 'disent', 'disais', 'disait', 'disions', 'disiez', 'disaient', 'dis', 'dit', 'dimes', 'dirent', 'dirai', 'diras', 'dira', 'dirons', 'direz', 'diront', 'dirais', 'dirait', 'dirions', 'diriez', 'diraient', 'disant', 'dit'],&#10;            'voir' =&gt; ['vois', 'voit', 'voyons', 'voyez', 'voient', 'voyais', 'voyait', 'voyions', 'voyiez', 'voyaient', 'vis', 'vit', 'vimes', 'virent', 'verrai', 'verras', 'verra', 'verrons', 'verrez', 'verront', 'verrais', 'verrait', 'verrions', 'verriez', 'verraient', 'voyant', 'vu'],&#10;            'savoir' =&gt; ['sais', 'sait', 'savons', 'savez', 'savent', 'savais', 'savait', 'savions', 'saviez', 'savaient', 'sus', 'sut', 'sumes', 'surent', 'saurai', 'sauras', 'saura', 'saurons', 'saurez', 'sauront', 'saurais', 'saurait', 'saurions', 'sauriez', 'sauraient', 'sachant', 'su'],&#10;            'pouvoir' =&gt; ['peux', 'peut', 'pouvons', 'pouvez', 'peuvent', 'pouvais', 'pouvait', 'pouvions', 'pouviez', 'pouvaient', 'pus', 'put', 'pumes', 'purent', 'pourrai', 'pourras', 'pourra', 'pourrons', 'pourrez', 'pourront', 'pourrais', 'pourrait', 'pourrions', 'pourriez', 'pourraient', 'pouvant', 'pu'],&#10;            'vouloir' =&gt; ['veux', 'veut', 'voulons', 'voulez', 'veulent', 'voulais', 'voulait', 'voulions', 'vouliez', 'voulaient', 'voulus', 'voulut', 'voulumes', 'voulurent', 'voudrai', 'voudras', 'voudra', 'voudrons', 'voudrez', 'voudront', 'voudrais', 'voudrait', 'voudrions', 'voudriez', 'voudraient', 'voulant', 'voulu'],&#10;            'venir' =&gt; ['viens', 'vient', 'venons', 'venez', 'viennent', 'venais', 'venait', 'venions', 'veniez', 'venaient', 'vins', 'vint', 'vinmes', 'vinrent', 'viendrai', 'viendras', 'viendra', 'viendrons', 'viendrez', 'viendront', 'viendrais', 'viendrait', 'viendrions', 'viendriez', 'viendraient', 'venant', 'venu'],&#10;            'partir' =&gt; ['pars', 'part', 'partons', 'partez', 'partent', 'partais', 'partait', 'partions', 'partiez', 'partaient', 'partis', 'partit', 'partimes', 'partirent', 'partirai', 'partiras', 'partira', 'partirons', 'partirez', 'partiront', 'partirais', 'partirait', 'partirions', 'partiriez', 'partiraient', 'partant', 'parti'],&#10;        ];&#10;    }&#10;&#10;    private function calculateSemanticProximity(string $guess, string $content, string $title): int&#10;    {&#10;        $normalizedGuess = $this-&gt;normalizeWord($guess);&#10;        $titleWords = array_map([$this, 'normalizeWord'], $this-&gt;extractTitleWords($title));&#10;&#10;        // Extraire TOUS les mots de l'article, pas seulement le titre&#10;        $allContentWords = $this-&gt;extractAllWordsFromContent($content);&#10;        $contentWords = array_map([$this, 'normalizeWord'], $allContentWords);&#10;&#10;        $maxProximity = 0;&#10;&#10;        // Vérifier la proximité avec les mots du titre (proximité maximale)&#10;        foreach ($titleWords as $titleWord) {&#10;            $similarity = $this-&gt;calculateLevenshteinSimilarity($normalizedGuess, $titleWord);&#10;            if ($similarity &gt; 0.7) {&#10;                $maxProximity = max($maxProximity, 950 + ($similarity * 50));&#10;            }&#10;        }&#10;&#10;        // Vérifier si le mot deviné est un nombre ou une date&#10;        $isGuessNumber = $this-&gt;isNumber($guess);&#10;        $isGuessDate = $this-&gt;isDate($guess);&#10;&#10;        // Si le mot deviné est un nombre ou une date, vérifier la proximité avec les nombres/dates de l'article&#10;        if ($isGuessNumber || $isGuessDate) {&#10;            $numbersAndDatesProximity = $this-&gt;calculateNumbersAndDatesProximity($guess, $content, $isGuessNumber, $isGuessDate);&#10;            $maxProximity = max($maxProximity, $numbersAndDatesProximity);&#10;        }&#10;&#10;        // Nouveau système de proximité sémantique avancé&#10;        foreach ($allContentWords as $contentWord) {&#10;            $normalizedContentWord = $this-&gt;normalizeWord($contentWord);&#10;            if (strlen($normalizedContentWord) &gt;= 2 &amp;&amp; !in_array($normalizedContentWord, $this-&gt;getStopWords())) {&#10;&#10;                // 1. Vérifier la similarité sémantique directe&#10;                $semanticScore = $this-&gt;calculateSemanticSimilarity($normalizedContentWord, $normalizedGuess);&#10;                if ($semanticScore &gt; 0) {&#10;                    $maxProximity = max($maxProximity, $semanticScore);&#10;                }&#10;&#10;                // 2. Vérifier la distance de Levenshtein (orthographe similaire)&#10;                $similarity = $this-&gt;calculateLevenshteinSimilarity($normalizedGuess, $normalizedContentWord);&#10;                if ($similarity &gt; 0.8) {&#10;                    $maxProximity = max($maxProximity, 800 + ($similarity * 100));&#10;                } elseif ($similarity &gt; 0.6) {&#10;                    $maxProximity = max($maxProximity, 400 + ($similarity * 200));&#10;                } elseif ($similarity &gt; 0.4) {&#10;                    $maxProximity = max($maxProximity, 100 + ($similarity * 100));&#10;                }&#10;&#10;                // 3. Vérifier les sous-chaînes&#10;                if (strlen($normalizedGuess) &gt;= 3 &amp;&amp; strlen($normalizedContentWord) &gt;= 3) {&#10;                    if (strpos($normalizedGuess, $normalizedContentWord) !== false || strpos($normalizedContentWord, $normalizedGuess) !== false) {&#10;                        $maxProximity = max($maxProximity, 600);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Si aucune proximité significative trouvée, retourner 0 (pas d'affichage)&#10;        if ($maxProximity &lt; 100) {&#10;            return 0;&#10;        }&#10;&#10;        return min(999, $maxProximity);&#10;    }&#10;&#10;    /**&#10;     * Vérifie si une chaîne représente un nombre&#10;     */&#10;    private function isNumber(string $text): bool&#10;    {&#10;        // Enlever les espaces et normaliser&#10;        $text = trim($text);&#10;&#10;        // Vérifier les nombres entiers&#10;        if (preg_match('/^\d+$/', $text)) {&#10;            return true;&#10;        }&#10;&#10;        // Vérifier les nombres décimaux (avec . ou ,)&#10;        if (preg_match('/^\d+[.,]\d+$/', $text)) {&#10;            return true;&#10;        }&#10;&#10;        // Vérifier les nombres avec séparateurs de milliers&#10;        if (preg_match('/^\d{1,3}([ .,]\d{3})*$/', $text)) {&#10;            return true;&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Vérifie si une chaîne représente une date&#10;     */&#10;    private function isDate(string $text): bool&#10;    {&#10;        $text = trim($text);&#10;&#10;        // Formats de dates courants&#10;        $datePatterns = [&#10;            '/^\d{1,2}\/\d{1,2}\/\d{2,4}$/', // 15/08/1995 ou 15/08/95&#10;            '/^\d{1,2}-\d{1,2}-\d{2,4}$/',   // 15-08-1995 ou 15-08-95&#10;            '/^\d{4}-\d{1,2}-\d{1,2}$/',     // 1995-08-15&#10;            '/^\d{1,2}\s+\w+\s+\d{4}$/',     // 15 août 1995&#10;            '/^\w+\s+\d{1,2},?\s+\d{4}$/',   // août 15, 1995&#10;            '/^\d{4}$/',                      // 1995 (année seule)&#10;        ];&#10;&#10;        foreach ($datePatterns as $pattern) {&#10;            if (preg_match($pattern, $text)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Calcule la proximité entre un nombre/date deviné et les nombres/dates de l'article&#10;     */&#10;    private function calculateNumbersAndDatesProximity(string $guess, string $content, bool $isGuessNumber, bool $isGuessDate): int&#10;    {&#10;        $maxProximity = 0;&#10;&#10;        // Extraire tous les nombres et dates du contenu&#10;        $words = preg_split('/\s+/', $content);&#10;&#10;        foreach ($words as $word) {&#10;            $cleanWord = preg_replace('/[^\w\d\/\-.,]/', '', $word);&#10;&#10;            if ($isGuessNumber &amp;&amp; $this-&gt;isNumber($cleanWord)) {&#10;                $proximity = $this-&gt;calculateNumberProximity($guess, $cleanWord);&#10;                $maxProximity = max($maxProximity, $proximity);&#10;            }&#10;&#10;            if ($isGuessDate &amp;&amp; $this-&gt;isDate($cleanWord)) {&#10;                $proximity = $this-&gt;calculateDateProximity($guess, $cleanWord);&#10;                $maxProximity = max($maxProximity, $proximity);&#10;            }&#10;        }&#10;&#10;        return $maxProximity;&#10;    }&#10;&#10;    /**&#10;     * Calcule la proximité entre deux nombres&#10;     */&#10;    private function calculateNumberProximity(string $number1, string $number2): int&#10;    {&#10;        // Convertir en nombres pour comparaison&#10;        $num1 = $this-&gt;parseNumber($number1);&#10;        $num2 = $this-&gt;parseNumber($number2);&#10;&#10;        if ($num1 === null || $num2 === null) {&#10;            return 0;&#10;        }&#10;&#10;        // Si les nombres sont identiques&#10;        if ($num1 == $num2) {&#10;            return 950;&#10;        }&#10;&#10;        // Calculer la différence relative&#10;        $diff = abs($num1 - $num2);&#10;        $average = ($num1 + $num2) / 2;&#10;        $relativeDiff = $average &gt; 0 ? ($diff / $average) : 1;&#10;&#10;        // Plus la différence relative est petite, plus la proximité est haute&#10;        if ($relativeDiff &lt;= 0.1) {&#10;            return 850; // Très proche (différence de 10% ou moins)&#10;        } elseif ($relativeDiff &lt;= 0.25) {&#10;            return 700; // Proche (différence de 25% ou moins)&#10;        } elseif ($relativeDiff &lt;= 0.5) {&#10;            return 500; // Moyennement proche&#10;        } elseif ($relativeDiff &lt;= 1.0) {&#10;            return 300; // Assez proche&#10;        } elseif ($relativeDiff &lt;= 2.0) {&#10;            return 150; // Distant mais détectable&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;    /**&#10;     * Calcule la proximité entre deux dates&#10;     */&#10;    private function calculateDateProximity(string $date1, string $date2): int&#10;    {&#10;        $timestamp1 = $this-&gt;parseDate($date1);&#10;        $timestamp2 = $this-&gt;parseDate($date2);&#10;&#10;        if ($timestamp1 === null || $timestamp2 === null) {&#10;            return 0;&#10;        }&#10;&#10;        // Si les dates sont identiques&#10;        if ($timestamp1 == $timestamp2) {&#10;            return 950;&#10;        }&#10;&#10;        // Calculer la différence en jours&#10;        $diffDays = abs($timestamp1 - $timestamp2) / (60 * 60 * 24);&#10;&#10;        // Proximité basée sur la différence en jours&#10;        if ($diffDays &lt;= 7) {&#10;            return 850; // Même semaine&#10;        } elseif ($diffDays &lt;= 30) {&#10;            return 700; // Même mois approximativement&#10;        } elseif ($diffDays &lt;= 365) {&#10;            return 500; // Même année approximativement&#10;        } elseif ($diffDays &lt;= 1825) { // 5 ans&#10;            return 300; // Proche dans le temps&#10;        } elseif ($diffDays &lt;= 3650) { // 10 ans&#10;            return 150; // Assez proche&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;    /**&#10;     * Parse un nombre depuis une chaîne&#10;     */&#10;    private function parseNumber(string $numberStr): ?float&#10;    {&#10;        $numberStr = trim($numberStr);&#10;        $numberStr = str_replace([' ', ','], ['', '.'], $numberStr);&#10;        $numberStr = preg_replace('/[^\d.]/', '', $numberStr);&#10;&#10;        if (is_numeric($numberStr)) {&#10;            return (float) $numberStr;&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Parse une date depuis une chaîne&#10;     */&#10;    private function parseDate(string $dateStr): ?int&#10;    {&#10;        $dateStr = trim($dateStr);&#10;&#10;        // Si c'est juste une année&#10;        if (preg_match('/^\d{4}$/', $dateStr)) {&#10;            return mktime(0, 0, 0, 1, 1, (int)$dateStr);&#10;        }&#10;&#10;        // Essayer différents formats&#10;        $formats = [&#10;            'd/m/Y', 'd-m-Y', 'Y-m-d', 'd/m/y', 'd-m-y',&#10;            'j F Y', 'F j, Y', 'j M Y', 'M j, Y'&#10;        ];&#10;&#10;        foreach ($formats as $format) {&#10;            $date = \DateTime::createFromFormat($format, $dateStr);&#10;            if ($date !== false) {&#10;                return $date-&gt;getTimestamp();&#10;            }&#10;        }&#10;&#10;        // Essayer strtotime comme dernier recours&#10;        $timestamp = strtotime($dateStr);&#10;        return $timestamp !== false ? $timestamp : null;&#10;    }&#10;&#10;    private function calculateSemanticSimilarity(string $word1, string $word2): int&#10;    {&#10;        // Base de données de relations sémantiques simplifiée&#10;        $semanticGroups = $this-&gt;getSemanticGroups();&#10;&#10;        $group1 = null;&#10;        $group2 = null;&#10;&#10;        // Trouver les groupes sémantiques des mots&#10;        foreach ($semanticGroups as $groupName =&gt; $words) {&#10;            if (in_array($word1, $words)) {&#10;                $group1 = $groupName;&#10;            }&#10;            if (in_array($word2, $words)) {&#10;                $group2 = $groupName;&#10;            }&#10;        }&#10;&#10;        // Si les deux mots sont dans le même groupe sémantique&#10;        if ($group1 &amp;&amp; $group2 &amp;&amp; $group1 === $group2) {&#10;            return 900; // Très haute proximité sémantique&#10;        }&#10;&#10;        // Vérifier les groupes liés&#10;        $relatedGroups = $this-&gt;getRelatedSemanticGroups();&#10;        if ($group1 &amp;&amp; $group2 &amp;&amp; isset($relatedGroups[$group1]) &amp;&amp; in_array($group2, $relatedGroups[$group1])) {&#10;            return 700; // Proximité sémantique élevée&#10;        }&#10;&#10;        // Vérifier les synonymes directs&#10;        $synonyms = $this-&gt;getSynonyms();&#10;        if (isset($synonyms[$word1]) &amp;&amp; in_array($word2, $synonyms[$word1])) {&#10;            return 850;&#10;        }&#10;        if (isset($synonyms[$word2]) &amp;&amp; in_array($word1, $synonyms[$word2])) {&#10;            return 850;&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;    private function getSemanticGroups(): array&#10;    {&#10;        return [&#10;            'etats_matiere' =&gt; ['liquide', 'gaz', 'solide', 'plasma', 'vapeur', 'fluide'],&#10;            'chimie' =&gt; ['molecule', 'atome', 'element', 'compose', 'reaction', 'chimique', 'formule', 'oxygene', 'hydrogene', 'carbone', 'azote'],&#10;            'eau_related' =&gt; ['eau', 'aquatique', 'marin', 'maritime', 'oceanique', 'fluvial', 'hydrique', 'hydraulique', 'hydrologie'],&#10;            'temperature' =&gt; ['chaud', 'froid', 'chaleur', 'temperature', 'thermique', 'calorique', 'glacial', 'bouillant'],&#10;            'corps_humain' =&gt; ['corps', 'organisme', 'cellule', 'tissu', 'organe', 'muscle', 'sang', 'cerveau', 'coeur'],&#10;            'science' =&gt; ['physique', 'biologie', 'chimie', 'mathematiques', 'recherche', 'experience', 'laboratoire', 'scientifique'],&#10;            'geographie' =&gt; ['terre', 'planete', 'continent', 'ocean', 'mer', 'riviere', 'montagne', 'vallee', 'climat'],&#10;            'vie' =&gt; ['vivant', 'organisme', 'biologique', 'vital', 'existence', 'survie', 'evolutif'],&#10;            'couleurs' =&gt; ['rouge', 'bleu', 'vert', 'jaune', 'noir', 'blanc', 'orange', 'violet', 'rose', 'gris'],&#10;            'taille' =&gt; ['grand', 'petit', 'enorme', 'minuscule', 'gigantesque', 'microscopique', 'immense', 'tiny'],&#10;            'mouvement' =&gt; ['rapide', 'lent', 'vitesse', 'acceleration', 'deceleration', 'mobile', 'statique', 'dynamique'],&#10;            'qualites' =&gt; ['important', 'essentiel', 'crucial', 'vital', 'necessaire', 'indispensable', 'fondamental'],&#10;        ];&#10;    }&#10;&#10;    private function getRelatedSemanticGroups(): array&#10;    {&#10;        return [&#10;            'etats_matiere' =&gt; ['chimie', 'temperature', 'science'],&#10;            'chimie' =&gt; ['etats_matiere', 'science', 'eau_related'],&#10;            'eau_related' =&gt; ['chimie', 'etats_matiere', 'geographie', 'vie'],&#10;            'temperature' =&gt; ['etats_matiere', 'science'],&#10;            'corps_humain' =&gt; ['vie', 'science'],&#10;            'science' =&gt; ['chimie', 'corps_humain', 'temperature'],&#10;            'geographie' =&gt; ['eau_related', 'vie'],&#10;            'vie' =&gt; ['corps_humain', 'eau_related', 'geographie'],&#10;        ];&#10;    }&#10;&#10;    private function getSynonyms(): array&#10;    {&#10;        return [&#10;            'eau' =&gt; ['h2o', 'aqua', 'flotte'],&#10;            'liquide' =&gt; ['fluide', 'liquid'],&#10;            'gaz' =&gt; ['gazeux', 'vapeur', 'aeriforme'],&#10;            'solide' =&gt; ['dur', 'rigide', 'cristallin'],&#10;            'chaud' =&gt; ['chaude', 'brulant', 'torride'],&#10;            'froid' =&gt; ['froide', 'glacial', 'frigide'],&#10;            'grand' =&gt; ['grande', 'gros', 'grosse', 'immense', 'gigantesque'],&#10;            'petit' =&gt; ['petite', 'minuscule', 'infime'],&#10;            'important' =&gt; ['importante', 'essentiel', 'essentielle', 'crucial', 'cruciale'],&#10;            'necessaire' =&gt; ['indispensable', 'requis', 'obligatoire'],&#10;            'vivant' =&gt; ['vivante', 'anime', 'biologique'],&#10;            'chimique' =&gt; ['chimiques', 'moleculaire'],&#10;            'naturel' =&gt; ['naturelle', 'nature', 'natif'],&#10;            'artificiel' =&gt; ['artificielle', 'synthetique', 'fabrique'],&#10;        ];&#10;    }&#10;&#10;    private function calculateLevenshteinSimilarity(string $str1, string $str2): float&#10;    {&#10;        $len1 = strlen($str1);&#10;        $len2 = strlen($str2);&#10;&#10;        if ($len1 === 0 &amp;&amp; $len2 === 0) return 1.0;&#10;        if ($len1 === 0 || $len2 === 0) return 0.0;&#10;&#10;        $distance = levenshtein($str1, $str2);&#10;        $maxLen = max($len1, $len2);&#10;&#10;        return 1 - ($distance / $maxLen);&#10;    }&#10;&#10;    private function getStopWords(): array&#10;    {&#10;        return [&#10;            'le', 'de', 'et', 'à', 'un', 'il', 'être', 'en', 'avoir', 'que', 'pour',&#10;            'dans', 'ce', 'son', 'une', 'sur', 'avec', 'ne', 'se', 'pas', 'tout', 'plus',&#10;            'par', 'grand', 'mais', 'qui', 'comme', 'où', 'ou', 'du', 'des', 'les', 'la',&#10;            'cette', 'ces', 'ses', 'leur', 'leurs', 'aux', 'nous', 'vous', 'ils', 'elles',&#10;            'est', 'sont', 'était', 'ont', 'peut', 'fait', 'très', 'bien', 'deux', 'aussi'&#10;        ];&#10;    }&#10;&#10;    private function buildWordProximityMapping(string $content, array $proximityData): array&#10;    {&#10;        $mapping = [];&#10;&#10;        if (empty($proximityData)) {&#10;            return $mapping;&#10;        }&#10;&#10;        // Extraire tous les mots de l'article&#10;        $allContentWords = $this-&gt;extractAllWordsFromContent($content);&#10;&#10;        foreach ($proximityData as $proximityInfo) {&#10;            $guessedWord = $proximityInfo['word'];&#10;            $proximityScore = $proximityInfo['proximity'];&#10;&#10;            // Trouver le meilleur mot de l'article pour afficher ce mot deviné&#10;            $bestMatch = null;&#10;            $bestSimilarity = 0;&#10;&#10;            foreach ($allContentWords as $contentWord) {&#10;                $normalizedContentWord = $this-&gt;normalizeWord($contentWord);&#10;                $normalizedGuessedWord = $this-&gt;normalizeWord($guessedWord);&#10;&#10;                // Calculer la similarité entre le mot deviné et le mot de l'article&#10;                $similarity = $this-&gt;calculateLevenshteinSimilarity($normalizedGuessedWord, $normalizedContentWord);&#10;&#10;                if ($similarity &gt; $bestSimilarity &amp;&amp; $similarity &gt; 0.3) {&#10;                    $bestSimilarity = $similarity;&#10;                    $bestMatch = $normalizedContentWord;&#10;                }&#10;            }&#10;&#10;            // Si on a trouvé un match suffisamment bon, l'ajouter au mapping&#10;            if ($bestMatch !== null) {&#10;                $mapping[$bestMatch] = [&#10;                    'guessed_word' =&gt; $guessedWord,&#10;                    'proximity' =&gt; $proximityScore&#10;                ];&#10;            }&#10;        }&#10;&#10;        return $mapping;&#10;    }&#10;&#10;    /**&#10;     * Construit un mapping des proximités sémantiques pour les mots trouvés&#10;     */&#10;    private function buildSemanticProximityMapping(string $content, array $foundWords): array&#10;    {&#10;        $mapping = [];&#10;&#10;        if (empty($foundWords)) {&#10;            return $mapping;&#10;        }&#10;&#10;        // Extraire tous les mots de l'article&#10;        $allContentWords = $this-&gt;extractAllWordsFromContent($content);&#10;&#10;        foreach ($foundWords as $foundWord) {&#10;            $normalizedFoundWord = $this-&gt;normalizeWord($foundWord);&#10;&#10;            // Pour chaque mot de l'article, vérifier s'il a une proximité sémantique avec ce mot trouvé&#10;            foreach ($allContentWords as $contentWord) {&#10;                $normalizedContentWord = $this-&gt;normalizeWord($contentWord);&#10;&#10;                // Éviter de remapper le mot sur lui-même s'il est déjà à sa place exacte&#10;                if ($normalizedContentWord === $normalizedFoundWord) {&#10;                    continue;&#10;                }&#10;&#10;                // Calculer la proximité sémantique&#10;                $semanticScore = $this-&gt;calculateSemanticSimilarity($normalizedFoundWord, $normalizedContentWord);&#10;&#10;                // Si il y a une proximité sémantique significative&#10;                if ($semanticScore &gt;= 700) { // Seuil élevé pour l'affichage sémantique&#10;                    // Seulement si ce mot n'a pas déjà un mapping avec un score plus élevé&#10;                    if (!isset($mapping[$normalizedContentWord]) || $mapping[$normalizedContentWord]['proximity'] &lt; $semanticScore) {&#10;                        $mapping[$normalizedContentWord] = [&#10;                            'found_word' =&gt; $foundWord,&#10;                            'proximity' =&gt; $semanticScore&#10;                        ];&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return $mapping;&#10;    }&#10;&#10;    private function getProximityColorStyle(int $proximityScore): string&#10;    {&#10;        // Nouveau système : fond grisé avec texte coloré&#10;        // Jaune très clair = très proche, orange foncé = éloigné&#10;        $baseStyle = 'background: #d0d0d0 !important; padding: 1px 2px !important; border-radius: 3px !important;';&#10;&#10;        if ($proximityScore &gt;= 900) {&#10;            // Très chaud - texte jaune très clair (proche)&#10;            return $baseStyle . ' color: #FFFF99 !important; font-weight: bold !important;';&#10;        } elseif ($proximityScore &gt;= 700) {&#10;            // Chaud - texte jaune doré&#10;            return $baseStyle . ' color: #FFD700 !important; font-weight: bold !important;';&#10;        } elseif ($proximityScore &gt;= 500) {&#10;            // Tiède - texte orange clair&#10;            return $baseStyle . ' color: #FFB347 !important;';&#10;        } elseif ($proximityScore &gt;= 300) {&#10;            // Froid - texte orange&#10;            return $baseStyle . ' color: #FF8C00 !important;';&#10;        } else {&#10;            // Très froid - texte orange foncé (éloigné)&#10;            return $baseStyle . ' color: #CC5500 !important;';&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;namespace App\Service;&#10;&#10;use App\Entity\GameSession;&#10;use App\Entity\Room;&#10;use App\Repository\GameSessionRepository;&#10;use App\Repository\RoomRepository;&#10;use Doctrine\ORM\EntityManagerInterface;&#10;&#10;class PedantixService&#10;{&#10;    public function __construct(&#10;        private EntityManagerInterface $entityManager,&#10;        private RoomRepository $roomRepository,&#10;        private GameSessionRepository $gameSessionRepository&#10;    ) {}&#10;&#10;    public function createRoom(string $wikipediaUrl, string $gameMode = 'competition'): Room&#10;    {&#10;        $articleData = $this-&gt;fetchWikipediaArticle($wikipediaUrl);&#10;&#10;        $room = new Room();&#10;        $room-&gt;setTitle($articleData['title']);&#10;        $room-&gt;setContent($articleData['content']);&#10;        $room-&gt;setUrl($wikipediaUrl);&#10;        $room-&gt;setWordsToFind($articleData['allWords']);&#10;        $room-&gt;setHints([]); // Pas d'indices dans le vrai Pedantix&#10;        $room-&gt;setGameMode($gameMode);&#10;&#10;        $this-&gt;roomRepository-&gt;save($room, true);&#10;&#10;        return $room;&#10;    }&#10;&#10;    public function joinRoom(string $roomCode, string $playerName, string $ipAddress): ?GameSession&#10;    {&#10;        $room = $this-&gt;roomRepository-&gt;findByCode($roomCode);&#10;        if (!$room) {&#10;            return null;&#10;        }&#10;&#10;        // Chercher une session existante pour ce joueur&#10;        $existingSession = $this-&gt;gameSessionRepository-&gt;findByRoomAndPlayer($room, $playerName, $ipAddress);&#10;&#10;        if ($existingSession) {&#10;            $existingSession-&gt;updateActivity();&#10;            $this-&gt;gameSessionRepository-&gt;save($existingSession, true);&#10;            return $existingSession;&#10;        }&#10;&#10;        // Créer une nouvelle session&#10;        $gameSession = new GameSession();&#10;        $gameSession-&gt;setRoom($room);&#10;        $gameSession-&gt;setPlayerName($playerName);&#10;        $gameSession-&gt;setIpAddress($ipAddress);&#10;&#10;        $this-&gt;gameSessionRepository-&gt;save($gameSession, true);&#10;&#10;        return $gameSession;&#10;    }&#10;&#10;    public function submitGuess(GameSession $gameSession, string $guess): array&#10;    {&#10;        $guess = trim($guess);&#10;        $room = $gameSession-&gt;getRoom();&#10;        $content = $room-&gt;getContent();&#10;&#10;        // Vérifier si le mot a déjà été essayé par ce joueur&#10;        $normalizedGuess = $this-&gt;normalizeWord($guess);&#10;        $foundWordsNormalized = array_map([$this, 'normalizeWord'], $gameSession-&gt;getFoundWords());&#10;&#10;        if (in_array($normalizedGuess, $foundWordsNormalized)) {&#10;            return [&#10;                'found' =&gt; false,&#10;                'word' =&gt; $guess,&#10;                'proximity' =&gt; null,&#10;                'gameCompleted' =&gt; false,&#10;                'isExactMatch' =&gt; false,&#10;                'error' =&gt; 'Mot déjà trouvé',&#10;                'duplicate' =&gt; true&#10;            ];&#10;        }&#10;&#10;        $gameSession-&gt;incrementAttempts();&#10;        $gameSession-&gt;updateActivity();&#10;&#10;        $result = [&#10;            'found' =&gt; false,&#10;            'word' =&gt; $guess,&#10;            'proximity' =&gt; null,&#10;            'gameCompleted' =&gt; false,&#10;            'isExactMatch' =&gt; false,&#10;            'duplicate' =&gt; false&#10;        ];&#10;&#10;        // Vérifier si c'est le mot-titre (victoire)&#10;        $titleWords = $this-&gt;extractTitleWords($room-&gt;getTitle());&#10;&#10;        foreach ($titleWords as $titleWord) {&#10;            if ($this-&gt;normalizeWord($titleWord) === $normalizedGuess) {&#10;                $result['found'] = true;&#10;                $result['isExactMatch'] = true;&#10;                $result['gameCompleted'] = true;&#10;                $gameSession-&gt;addFoundWord($guess);&#10;                $gameSession-&gt;setCompleted(true);&#10;&#10;                // En mode coopératif, ajouter le mot à la liste globale de la salle&#10;                if ($room-&gt;isCooperativeMode()) {&#10;                    $room-&gt;addGlobalFoundWord($guess);&#10;                    $this-&gt;roomRepository-&gt;save($room, true);&#10;                }&#10;&#10;                // Score final basé sur le nombre de tentatives (moins = mieux)&#10;                $finalScore = max(1000 - ($gameSession-&gt;getAttempts() * 10), 100);&#10;                $gameSession-&gt;setScore($finalScore);&#10;&#10;                $this-&gt;gameSessionRepository-&gt;save($gameSession, true);&#10;                return $result;&#10;            }&#10;        }&#10;&#10;        // Vérifier si le mot existe dans l'article&#10;        if ($this-&gt;wordExistsInArticle($guess, $content)) {&#10;            $result['found'] = true;&#10;            $gameSession-&gt;addFoundWord($guess);&#10;&#10;            // En mode coopératif, ajouter le mot à la liste globale de la salle&#10;            if ($room-&gt;isCooperativeMode()) {&#10;                $room-&gt;addGlobalFoundWord($guess);&#10;                $this-&gt;roomRepository-&gt;save($room, true);&#10;            }&#10;&#10;            // Ajouter des points pour chaque mot trouvé (seulement si pas déjà trouvé)&#10;            $currentScore = $gameSession-&gt;getScore() + 10;&#10;            $gameSession-&gt;setScore($currentScore);&#10;        } else {&#10;            // Calculer la proximité sémantique avec les mots de l'article&#10;            $result['proximity'] = $this-&gt;calculateSemanticProximity($guess, $content, $room-&gt;getTitle());&#10;        }&#10;&#10;        $this-&gt;gameSessionRepository-&gt;save($gameSession, true);&#10;        return $result;&#10;    }&#10;&#10;    public function getProcessedContent(Room $room, array $foundWords, array $proximityData = [], bool $gameCompleted = false): string&#10;    {&#10;        $content = $room-&gt;getContent();&#10;        &#10;        // En mode coopératif, combiner les mots trouvés par le joueur avec ceux trouvés globalement&#10;        if ($room-&gt;isCooperativeMode()) {&#10;            $allFoundWords = array_unique(array_merge($foundWords, $room-&gt;getGlobalFoundWords()));&#10;        } else {&#10;            $allFoundWords = $foundWords;&#10;        }&#10;        &#10;        $foundWordsNormalized = array_map([$this, 'normalizeWord'], $allFoundWords);&#10;&#10;        // Si le jeu est terminé, révéler tous les mots&#10;        if ($gameCompleted) {&#10;            // Diviser le contenu en mots tout en préservant la ponctuation et la structure&#10;            $words = preg_split('/(\s+|[.,;:!?()&quot;\'-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;            $processedWords = [];&#10;            foreach ($words as $word) {&#10;                if (trim($word) === '' || preg_match('/^\s*$/', $word) || preg_match('/^[.,;:!?()&quot;\'-]+$/', $word)) {&#10;                    // Espaces et ponctuation - garder tel quel&#10;                    $processedWords[] = $word;&#10;                } else {&#10;                    // Tous les mots sont révélés avec le style de victoire&#10;                    $processedWords[] = '&lt;span class=&quot;title-word&quot;&gt;' . htmlspecialchars($word) . '&lt;/span&gt;';&#10;                }&#10;            }&#10;&#10;            return implode('', $processedWords);&#10;        }&#10;&#10;        // Créer un mapping des mots de l'article vers les mots devinés les plus proches&#10;        $wordProximityMapping = $this-&gt;buildWordProximityMapping($content, $proximityData);&#10;&#10;        // Créer un mapping des proximités sémantiques pour les mots trouvés&#10;        $semanticProximityMapping = $this-&gt;buildSemanticProximityMapping($content, $allFoundWords);&#10;&#10;        // Comportement normal : diviser le contenu en mots tout en préservant la ponctuation et la structure&#10;        $words = preg_split('/(\s+|[.,;:!?()&quot;\'-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;        $processedWords = [];&#10;        foreach ($words as $word) {&#10;            if (trim($word) === '' || preg_match('/^\s*$/', $word) || preg_match('/^[.,;:!?()&quot;\'-]+$/', $word)) {&#10;                // Espaces et ponctuation - garder tel quel&#10;                $processedWords[] = $word;&#10;            } else {&#10;                // C'est un mot - vérifier s'il doit être dévoilé&#10;                $normalizedWord = $this-&gt;normalizeWord($word);&#10;                $isRevealed = $this-&gt;isWordRevealed($word, $foundWordsNormalized);&#10;&#10;                if ($isRevealed) {&#10;                    // Mot trouvé : affichage en texte noir normal sans arrière-plan&#10;                    $processedWords[] = '&lt;span class=&quot;revealed-word&quot;&gt;' . htmlspecialchars($word) . '&lt;/span&gt;';&#10;                } else {&#10;                    // Vérifier si ce mot a une proximité sémantique avec un mot trouvé&#10;                    if (isset($semanticProximityMapping[$normalizedWord])) {&#10;                        $semanticInfo = $semanticProximityMapping[$normalizedWord];&#10;                        $foundWord = $semanticInfo['found_word'];&#10;                        $proximityScore = $semanticInfo['proximity'];&#10;                        $colorStyle = $this-&gt;getProximityColorStyle($proximityScore);&#10;&#10;                        // Afficher le mot trouvé avec la couleur de proximité sémantique&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word-with-proximity&quot; style=&quot;' . $colorStyle . '&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot; data-found=&quot;' . htmlspecialchars($foundWord) . '&quot; data-proximity=&quot;' . $proximityScore . '&quot;&gt;' . htmlspecialchars($foundWord) . '&lt;/span&gt;';&#10;                    } else if (isset($wordProximityMapping[$normalizedWord])) {&#10;                        // Vérifier la proximité avec les mots devinés mais non trouvés&#10;                        $proximityInfo = $wordProximityMapping[$normalizedWord];&#10;                        $guessedWord = $proximityInfo['guessed_word'];&#10;                        $proximityScore = $proximityInfo['proximity'];&#10;                        $colorStyle = $this-&gt;getProximityColorStyle($proximityScore);&#10;&#10;                        // Afficher le mot deviné avec la couleur de proximité&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word-with-proximity&quot; style=&quot;' . $colorStyle . '&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot; data-guessed=&quot;' . htmlspecialchars($guessedWord) . '&quot; data-proximity=&quot;' . $proximityScore . '&quot;&gt;' . htmlspecialchars($guessedWord) . '&lt;/span&gt;';&#10;                    } else {&#10;                        // Mot complètement caché&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot;&gt;' . str_repeat('█', mb_strlen($word)) . '&lt;/span&gt;';&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return implode('', $processedWords);&#10;    }&#10;&#10;    /**&#10;     * Vérifie si un mot de l'article doit être révélé basé sur les mots trouvés par le joueur&#10;     * Prend en compte les conjugaisons et variations&#10;     */&#10;    private function isWordRevealed(string $articleWord, array $foundWordsNormalized): bool&#10;    {&#10;        $normalizedArticleWord = $this-&gt;normalizeWord($articleWord);&#10;&#10;        // Vérification directe&#10;        if (in_array($normalizedArticleWord, $foundWordsNormalized)) {&#10;            return true;&#10;        }&#10;&#10;        // Vérifier si le mot de l'article est une conjugaison d'un des mots trouvés&#10;        foreach ($foundWordsNormalized as $foundWord) {&#10;            if ($this-&gt;isVerbConjugation($foundWord, $normalizedArticleWord)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        // Vérifier les contractions avec apostrophes&#10;        if (strpos($articleWord, &quot;'&quot;) !== false) {&#10;            $parts = explode(&quot;'&quot;, $articleWord);&#10;            foreach ($parts as $part) {&#10;                $normalizedPart = $this-&gt;normalizeWord($part);&#10;                if (in_array($normalizedPart, $foundWordsNormalized)) {&#10;                    return true;&#10;                }&#10;                // Vérifier les conjugaisons pour chaque partie&#10;                foreach ($foundWordsNormalized as $foundWord) {&#10;                    if ($this-&gt;isVerbConjugation($foundWord, $normalizedPart)) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    public function getLeaderboard(Room $room): array&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;getLeaderboard($room);&#10;    }&#10;&#10;    public function getActivePlayers(Room $room): array&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;findActiveSessionsForRoom($room);&#10;    }&#10;&#10;    public function getRoomByCode(string $code): ?Room&#10;    {&#10;        return $this-&gt;roomRepository-&gt;findByCode($code);&#10;    }&#10;&#10;    public function getGameSession(int $sessionId): ?GameSession&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;find($sessionId);&#10;    }&#10;&#10;    private function fetchWikipediaArticle(string $url): array&#10;    {&#10;        $title = $this-&gt;extractTitleFromUrl($url);&#10;&#10;        // Utiliser l'API de résumé de Wikipedia qui donne directement l'introduction&#10;        $summaryApiUrl = &quot;https://fr.wikipedia.org/api/rest_v1/page/summary/&quot; . urlencode($title);&#10;&#10;        $context = stream_context_create([&#10;            'http' =&gt; [&#10;                'header' =&gt; &quot;User-Agent: PedantixApp/1.0\r\n&quot;,&#10;                'timeout' =&gt; 30,&#10;                'ignore_errors' =&gt; true&#10;            ]&#10;        ]);&#10;&#10;        try {&#10;            $summaryResponse = file_get_contents($summaryApiUrl, false, $context);&#10;&#10;            if ($summaryResponse === false) {&#10;                $error = error_get_last();&#10;                throw new \Exception('Impossible de r��cupérer l\'article Wikipedia: ' . ($error['message'] ?? 'Erreur de connexion'));&#10;            }&#10;&#10;            $summaryData = json_decode($summaryResponse, true);&#10;&#10;            if (!$summaryData) {&#10;                throw new \Exception('Réponse invalide de l\'API Wikipedia');&#10;            }&#10;&#10;            if (isset($summaryData['type']) &amp;&amp; $summaryData['type'] === 'disambiguation') {&#10;                throw new \Exception('Cette page est une page de désambiguïsation. Veuillez choisir un article plus spécifique.');&#10;            }&#10;&#10;            if (!isset($summaryData['extract']) || empty($summaryData['extract'])) {&#10;                throw new \Exception('Contenu de l\'article introuvable ou vide');&#10;            }&#10;&#10;            // L'extract contient déjà un résumé propre de l'article&#10;            $content = $summaryData['extract'];&#10;&#10;            // Nettoyer un peu plus le contenu pour enlever les références restantes&#10;            $content = preg_replace('/\[[\d,\s]+\]/', '', $content); // Supprimer les références [1], [2,3], etc.&#10;            $content = preg_replace('/\s+/', ' ', $content); // Normaliser les espaces&#10;            $content = trim($content);&#10;&#10;            if (strlen($content) &lt; 50) {&#10;                throw new \Exception('L\'article est trop court pour créer une partie intéressante');&#10;            }&#10;&#10;            $properTitle = $summaryData['title'] ?? $title;&#10;&#10;            return [&#10;                'title' =&gt; $properTitle,&#10;                'content' =&gt; $content,&#10;                'allWords' =&gt; $this-&gt;extractAllWords($content)&#10;            ];&#10;        } catch (\Exception $e) {&#10;            // Log l'erreur pour debugging&#10;            error_log('Erreur fetchWikipediaArticle: ' . $e-&gt;getMessage() . ' pour URL: ' . $url);&#10;            throw $e;&#10;        }&#10;    }&#10;&#10;    private function cleanWikipediaContent(string $html): string&#10;    {&#10;        // Supprimer les balises non désirées&#10;        $html = preg_replace('/&lt;script.*?&lt;\/script&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;style.*?&lt;\/style&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;figure.*?&lt;\/figure&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;table.*?&lt;\/table&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*infobox[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;&#10;        // Supprimer TOUTES les boîtes d'aide, navigation et métadonnées&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*dablink[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*hatnote[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*disambig[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*navigation[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*navbox[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*metadata[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;&#10;        // Approche plus simple et plus stricte : extraire seulement les 2-3 premiers vrais paragraphes&#10;        preg_match_all('/&lt;p[^&gt;]*&gt;(.*?)&lt;\/p&gt;/is', $html, $matches);&#10;        $allParagraphs = $matches[1];&#10;&#10;        $introContent = [];&#10;        $paragraphCount = 0;&#10;&#10;        foreach ($allParagraphs as $paragraph) {&#10;            $cleaned = strip_tags($paragraph);&#10;            $cleaned = html_entity_decode($cleaned, ENT_QUOTES, 'UTF-8');&#10;            $cleaned = preg_replace('/\s+/', ' ', $cleaned);&#10;            $cleaned = trim($cleaned);&#10;&#10;            // Filtres très stricts pour ne garder que l'introduction&#10;            if (!empty($cleaned) &amp;&amp;&#10;                strlen($cleaned) &gt; 30 &amp;&amp; // Paragraphes substantiels seulement&#10;                !preg_match('/^(Pour les articles|Page d\'aide|Ne doit pas être confondu|Cet article|voir|redirigé|coordination|modifier|wikidata)/i', $cleaned) &amp;&amp;&#10;                !preg_match('/(homonymie|homonymes|voir aussi|articles connexes|catégorie|portail)/i', $cleaned) &amp;&amp;&#10;                !preg_match('/^\s*(modifier|edit|\[|\()/i', $cleaned)) {&#10;&#10;                $introContent[] = $cleaned;&#10;                $paragraphCount++;&#10;&#10;                // LIMITER STRICTEMENT à 2-3 paragraphes d'introduction maximum&#10;                if ($paragraphCount &gt;= 2) {&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;        // S'assurer qu'on a au moins quelque chose de substantiel&#10;        if (empty($introContent)) {&#10;            return &quot;L'eau est un composé chimique ubiquitaire sur la Terre, essentiel pour tous les organismes vivants connus.&quot;;&#10;        }&#10;&#10;        return implode(&quot;\n\n&quot;, $introContent);&#10;    }&#10;&#10;    private function getElementPosition(\DOMNode $element): int&#10;    {&#10;        $position = 0;&#10;        $current = $element;&#10;&#10;        while ($current-&gt;previousSibling !== null) {&#10;            $current = $current-&gt;previousSibling;&#10;            $position++;&#10;        }&#10;&#10;        // Ajouter la position des parents&#10;        if ($current-&gt;parentNode !== null &amp;&amp; $current-&gt;parentNode-&gt;nodeName !== '#document') {&#10;            $position += $this-&gt;getElementPosition($current-&gt;parentNode) * 1000;&#10;        }&#10;&#10;        return $position;&#10;    }&#10;&#10;    private function extractTitleFromUrl(string $url): string&#10;    {&#10;        $path = parse_url($url, PHP_URL_PATH);&#10;        $title = basename($path);&#10;        return urldecode($title);&#10;    }&#10;&#10;    private function extractAllWords(string $content): array&#10;    {&#10;        $words = preg_split('/\s+/', $content);&#10;        $cleanWords = [];&#10;&#10;        foreach ($words as $word) {&#10;            $cleaned = $this-&gt;normalizeWord($word);&#10;            if (strlen($cleaned) &gt;= 2 &amp;&amp; !in_array($cleaned, $this-&gt;getStopWords())) {&#10;                $cleanWords[] = $cleaned;&#10;            }&#10;        }&#10;&#10;        return array_unique($cleanWords);&#10;    }&#10;&#10;    private function extractAllWordsFromContent(string $content): array&#10;    {&#10;        // Extraire tous les mots du contenu en préservant la structure&#10;        $words = preg_split('/(\s+|[.,;:!?()&quot;\-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;        $cleanWords = [];&#10;&#10;        foreach ($words as $word) {&#10;            $cleanWord = trim($word);&#10;            if (empty($cleanWord) || preg_match('/^[.,;:!?()&quot;\'\\-\\s]+$/', $cleanWord)) {&#10;                continue;&#10;            }&#10;&#10;            // Traitement spécial pour les mots avec apostrophes&#10;            if (strpos($cleanWord, &quot;'&quot;) !== false) {&#10;                $parts = explode(&quot;'&quot;, $cleanWord);&#10;                foreach ($parts as $part) {&#10;                    $part = trim($part);&#10;                    if (!empty($part) &amp;&amp; strlen($part) &gt;= 2) {&#10;                        $cleanWords[] = $part;&#10;                    }&#10;                }&#10;            } else {&#10;                if (strlen($cleanWord) &gt;= 2) {&#10;                    $cleanWords[] = $cleanWord;&#10;                }&#10;            }&#10;        }&#10;&#10;        return $cleanWords;&#10;    }&#10;&#10;    private function extractTitleWords(string $title): array&#10;    {&#10;        // Extraire tous les mots significatifs du titre&#10;        $words = preg_split('/\s+/', $title);&#10;        $titleWords = [];&#10;&#10;        foreach ($words as $word) {&#10;            $cleaned = $this-&gt;normalizeWord($word);&#10;            if (strlen($cleaned) &gt;= 2) {&#10;                $titleWords[] = $word; // Garder le mot original, pas normalisé&#10;            }&#10;        }&#10;&#10;        return $titleWords;&#10;    }&#10;&#10;    private function normalizeWord(string $word): string&#10;    {&#10;        // Enlever la ponctuation et normaliser&#10;        $word = preg_replace('/[^\p{L}\p{N}]/u', '', $word);&#10;        $word = mb_strtolower($word, 'UTF-8');&#10;&#10;        // Enlever les accents pour la comparaison&#10;        $word = iconv('UTF-8', 'ASCII//TRANSLIT//IGNORE', $word);&#10;        $word = preg_replace('/[^a-z0-9]/', '', $word);&#10;&#10;        return $word;&#10;    }&#10;&#10;    private function wordExistsInArticle(string $guess, string $content): bool&#10;    {&#10;        $normalizedGuess = $this-&gt;normalizeWord($guess);&#10;&#10;        // Cas spécial pour les contractions comme &quot;l'&quot;&#10;        if (strlen($guess) == 1 &amp;&amp; in_array(strtolower($guess), ['l', 'd', 'j', 'n', 'm', 'c', 's', 't'])) {&#10;            // Rechercher des patterns comme &quot;l'eau&quot;, &quot;d'eau&quot;, etc.&#10;            $pattern = '/\b' . preg_quote(strtolower($guess)) . '\'/i';&#10;            if (preg_match($pattern, $content)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        // Diviser le contenu en mots en préservant les apostrophes&#10;        $words = preg_split('/(\s+|[.,;:!?()&quot;\-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;        foreach ($words as $word) {&#10;            $cleanWord = trim($word);&#10;            if (empty($cleanWord)) continue;&#10;&#10;            // Traitement spécial pour les mots avec apostrophes&#10;            if (strpos($cleanWord, &quot;'&quot;) !== false) {&#10;                $parts = explode(&quot;'&quot;, $cleanWord);&#10;                foreach ($parts as $part) {&#10;                    if ($this-&gt;normalizeWord($part) === $normalizedGuess) {&#10;                        return true;&#10;                    }&#10;                    // Vérifier les conjugaisons pour les parties de mots avec apostrophe&#10;                    if ($this-&gt;isVerbConjugation($normalizedGuess, $this-&gt;normalizeWord($part))) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;&#10;            $normalizedWord = $this-&gt;normalizeWord($cleanWord);&#10;            if ($normalizedWord === $normalizedGuess) {&#10;                return true;&#10;            }&#10;&#10;            // Vérifier si le mot deviné est un infinitif et le mot de l'article une conjugaison&#10;            if ($this-&gt;isVerbConjugation($normalizedGuess, $normalizedWord)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Vérifie si un mot est une conjugaison d'un verbe à l'infinitif&#10;     */&#10;    private function isVerbConjugation(string $infinitive, string $word): bool&#10;    {&#10;        // Patterns de conjugaison française simplifiés&#10;        $conjugationPatterns = $this-&gt;getConjugationPatterns();&#10;&#10;        foreach ($conjugationPatterns as $ending =&gt; $replacements) {&#10;            if (str_ends_with($infinitive, $ending)) {&#10;                $stem = substr($infinitive, 0, -strlen($ending));&#10;&#10;                foreach ($replacements as $replacement) {&#10;                    $conjugated = $stem . $replacement;&#10;                    if ($conjugated === $word) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Vérifier aussi les verbes irréguliers les plus courants&#10;        $irregularVerbs = $this-&gt;getIrregularVerbs();&#10;        if (isset($irregularVerbs[$infinitive])) {&#10;            return in_array($word, $irregularVerbs[$infinitive]);&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Patterns de conjugaison pour les verbes réguliers&#10;     */&#10;    private function getConjugationPatterns(): array&#10;    {&#10;        return [&#10;            'er' =&gt; [&#10;                'e', 'es', 'e', 'ons', 'ez', 'ent', // présent&#10;                'ais', 'ais', 'ait', 'ions', 'iez', 'aient', // imparfait&#10;                'ai', 'as', 'a', 'ames', 'ates', 'erent', // passé simple&#10;                'erai', 'eras', 'era', 'erons', 'erez', 'eront', // futur&#10;                'erais', 'erais', 'erait', 'erions', 'eriez', 'eraient', // conditionnel&#10;                'ant', 'e', // participes&#10;            ],&#10;            'ir' =&gt; [&#10;                'is', 'is', 'it', 'issons', 'issez', 'issent', // présent&#10;                'issais', 'issais', 'issait', 'issions', 'issiez', 'issaient', // imparfait&#10;                'is', 'is', 'it', 'imes', 'ites', 'irent', // passé simple&#10;                'irai', 'iras', 'ira', 'irons', 'irez', 'iront', // futur&#10;                'irais', 'irais', 'irait', 'irions', 'iriez', 'iraient', // conditionnel&#10;                'issant', 'i', // participes&#10;            ],&#10;            're' =&gt; [&#10;                's', 's', '', 'ons', 'ez', 'ent', // présent&#10;                'ais', 'ais', 'ait', 'ions', 'iez', 'aient', // imparfait&#10;                'is', 'is', 'it', 'imes', 'ites', 'irent', // passé simple&#10;                'rai', 'ras', 'ra', 'rons', 'rez', 'ront', // futur&#10;                'rais', 'rais', 'rait', 'rions', 'riez', 'raient', // conditionnel&#10;                'ant', 'u', // participes&#10;            ]&#10;        ];&#10;    }&#10;&#10;    /**&#10;     * Verbes irréguliers les plus courants&#10;     */&#10;    private function getIrregularVerbs(): array&#10;    {&#10;        return [&#10;            'etre' =&gt; ['suis', 'es', 'est', 'sommes', 'etes', 'sont', 'etais', 'etait', 'etions', 'etiez', 'etaient', 'fus', 'fut', 'fumes', 'furent', 'serai', 'seras', 'sera', 'serons', 'serez', 'seront', 'serais', 'serait', 'serions', 'seriez', 'seraient', 'etant', 'ete'],&#10;            'avoir' =&gt; ['ai', 'as', 'a', 'avons', 'avez', 'ont', 'avais', 'avait', 'avions', 'aviez', 'avaient', 'eus', 'eut', 'eumes', 'eurent', 'aurai', 'auras', 'aura', 'aurons', 'aurez', 'auront', 'aurais', 'aurait', 'aurions', 'auriez', 'auraient', 'ayant', 'eu'],&#10;            'aller' =&gt; ['vais', 'vas', 'va', 'allons', 'allez', 'vont', 'allais', 'allait', 'allions', 'alliez', 'allaient', 'allai', 'alla', 'allames', 'allerent', 'irai', 'iras', 'ira', 'irons', 'irez', 'iront', 'irais', 'irait', 'irions', 'iriez', 'iraient', 'allant', 'alle'],&#10;            'faire' =&gt; ['fais', 'fait', 'faisons', 'faites', 'font', 'faisais', 'faisait', 'faisions', 'faisiez', 'faisaient', 'fis', 'fit', 'fimes', 'firent', 'ferai', 'feras', 'fera', 'ferons', 'ferez', 'feront', 'ferais', 'ferait', 'ferions', 'feriez', 'feraient', 'faisant', 'fait'],&#10;            'dire' =&gt; ['dis', 'dit', 'disons', 'dites', 'disent', 'disais', 'disait', 'disions', 'disiez', 'disaient', 'dis', 'dit', 'dimes', 'dirent', 'dirai', 'diras', 'dira', 'dirons', 'direz', 'diront', 'dirais', 'dirait', 'dirions', 'diriez', 'diraient', 'disant', 'dit'],&#10;            'voir' =&gt; ['vois', 'voit', 'voyons', 'voyez', 'voient', 'voyais', 'voyait', 'voyions', 'voyiez', 'voyaient', 'vis', 'vit', 'vimes', 'virent', 'verrai', 'verras', 'verra', 'verrons', 'verrez', 'verront', 'verrais', 'verrait', 'verrions', 'verriez', 'verraient', 'voyant', 'vu'],&#10;            'savoir' =&gt; ['sais', 'sait', 'savons', 'savez', 'savent', 'savais', 'savait', 'savions', 'saviez', 'savaient', 'sus', 'sut', 'sumes', 'surent', 'saurai', 'sauras', 'saura', 'saurons', 'saurez', 'sauront', 'saurais', 'saurait', 'saurions', 'sauriez', 'sauraient', 'sachant', 'su'],&#10;            'pouvoir' =&gt; ['peux', 'peut', 'pouvons', 'pouvez', 'peuvent', 'pouvais', 'pouvait', 'pouvions', 'pouviez', 'pouvaient', 'pus', 'put', 'pumes', 'purent', 'pourrai', 'pourras', 'pourra', 'pourrons', 'pourrez', 'pourront', 'pourrais', 'pourrait', 'pourrions', 'pourriez', 'pourraient', 'pouvant', 'pu'],&#10;            'vouloir' =&gt; ['veux', 'veut', 'voulons', 'voulez', 'veulent', 'voulais', 'voulait', 'voulions', 'vouliez', 'voulaient', 'voulus', 'voulut', 'voulumes', 'voulurent', 'voudrai', 'voudras', 'voudra', 'voudrons', 'voudrez', 'voudront', 'voudrais', 'voudrait', 'voudrions', 'voudriez', 'voudraient', 'voulant', 'voulu'],&#10;            'venir' =&gt; ['viens', 'vient', 'venons', 'venez', 'viennent', 'venais', 'venait', 'venions', 'veniez', 'venaient', 'vins', 'vint', 'vinmes', 'vinrent', 'viendrai', 'viendras', 'viendra', 'viendrons', 'viendrez', 'viendront', 'viendrais', 'viendrait', 'viendrions', 'viendriez', 'viendraient', 'venant', 'venu'],&#10;            'partir' =&gt; ['pars', 'part', 'partons', 'partez', 'partent', 'partais', 'partait', 'partions', 'partiez', 'partaient', 'partis', 'partit', 'partimes', 'partirent', 'partirai', 'partiras', 'partira', 'partirons', 'partirez', 'partiront', 'partirais', 'partirait', 'partirions', 'partiriez', 'partiraient', 'partant', 'parti'],&#10;        ];&#10;    }&#10;&#10;    private function calculateSemanticProximity(string $guess, string $content, string $title): int&#10;    {&#10;        $normalizedGuess = $this-&gt;normalizeWord($guess);&#10;        $titleWords = array_map([$this, 'normalizeWord'], $this-&gt;extractTitleWords($title));&#10;&#10;        // Extraire TOUS les mots de l'article, pas seulement le titre&#10;        $allContentWords = $this-&gt;extractAllWordsFromContent($content);&#10;        $contentWords = array_map([$this, 'normalizeWord'], $allContentWords);&#10;&#10;        $maxProximity = 0;&#10;&#10;        // Vérifier la proximité avec les mots du titre (proximité maximale)&#10;        foreach ($titleWords as $titleWord) {&#10;            $similarity = $this-&gt;calculateLevenshteinSimilarity($normalizedGuess, $titleWord);&#10;            if ($similarity &gt; 0.7) {&#10;                $maxProximity = max($maxProximity, 950 + ($similarity * 50));&#10;            }&#10;        }&#10;&#10;        // Vérifier si le mot deviné est un nombre ou une date&#10;        $isGuessNumber = $this-&gt;isNumber($guess);&#10;        $isGuessDate = $this-&gt;isDate($guess);&#10;&#10;        // Si le mot deviné est un nombre ou une date, vérifier la proximité avec les nombres/dates de l'article&#10;        if ($isGuessNumber || $isGuessDate) {&#10;            $numbersAndDatesProximity = $this-&gt;calculateNumbersAndDatesProximity($guess, $content, $isGuessNumber, $isGuessDate);&#10;            $maxProximity = max($maxProximity, $numbersAndDatesProximity);&#10;        }&#10;&#10;        // Nouveau système de proximité sémantique avancé&#10;        foreach ($allContentWords as $contentWord) {&#10;            $normalizedContentWord = $this-&gt;normalizeWord($contentWord);&#10;            if (strlen($normalizedContentWord) &gt;= 2 &amp;&amp; !in_array($normalizedContentWord, $this-&gt;getStopWords())) {&#10;&#10;                // 1. Vérifier la similarité sémantique directe&#10;                $semanticScore = $this-&gt;calculateSemanticSimilarity($normalizedContentWord, $normalizedGuess);&#10;                if ($semanticScore &gt; 0) {&#10;                    $maxProximity = max($maxProximity, $semanticScore);&#10;                }&#10;&#10;                // 2. Vérifier la distance de Levenshtein (orthographe similaire)&#10;                $similarity = $this-&gt;calculateLevenshteinSimilarity($normalizedGuess, $normalizedContentWord);&#10;                if ($similarity &gt; 0.8) {&#10;                    $maxProximity = max($maxProximity, 800 + ($similarity * 100));&#10;                } elseif ($similarity &gt; 0.6) {&#10;                    $maxProximity = max($maxProximity, 400 + ($similarity * 200));&#10;                } elseif ($similarity &gt; 0.4) {&#10;                    $maxProximity = max($maxProximity, 100 + ($similarity * 100));&#10;                }&#10;&#10;                // 3. Vérifier les sous-chaînes&#10;                if (strlen($normalizedGuess) &gt;= 3 &amp;&amp; strlen($normalizedContentWord) &gt;= 3) {&#10;                    if (strpos($normalizedGuess, $normalizedContentWord) !== false || strpos($normalizedContentWord, $normalizedGuess) !== false) {&#10;                        $maxProximity = max($maxProximity, 600);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Si aucune proximité significative trouvée, retourner 0 (pas d'affichage)&#10;        if ($maxProximity &lt; 100) {&#10;            return 0;&#10;        }&#10;&#10;        return min(999, $maxProximity);&#10;    }&#10;&#10;    /**&#10;     * Vérifie si une chaîne représente un nombre&#10;     */&#10;    private function isNumber(string $text): bool&#10;    {&#10;        // Enlever les espaces et normaliser&#10;        $text = trim($text);&#10;&#10;        // Vérifier les nombres entiers&#10;        if (preg_match('/^\d+$/', $text)) {&#10;            return true;&#10;        }&#10;&#10;        // Vérifier les nombres décimaux (avec . ou ,)&#10;        if (preg_match('/^\d+[.,]\d+$/', $text)) {&#10;            return true;&#10;        }&#10;&#10;        // Vérifier les nombres avec séparateurs de milliers&#10;        if (preg_match('/^\d{1,3}([ .,]\d{3})*$/', $text)) {&#10;            return true;&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Vérifie si une chaîne représente une date&#10;     */&#10;    private function isDate(string $text): bool&#10;    {&#10;        $text = trim($text);&#10;&#10;        // Formats de dates courants&#10;        $datePatterns = [&#10;            '/^\d{1,2}\/\d{1,2}\/\d{2,4}$/', // 15/08/1995 ou 15/08/95&#10;            '/^\d{1,2}-\d{1,2}-\d{2,4}$/',   // 15-08-1995 ou 15-08-95&#10;            '/^\d{4}-\d{1,2}-\d{1,2}$/',     // 1995-08-15&#10;            '/^\d{1,2}\s+\w+\s+\d{4}$/',     // 15 août 1995&#10;            '/^\w+\s+\d{1,2},?\s+\d{4}$/',   // août 15, 1995&#10;            '/^\d{4}$/',                      // 1995 (année seule)&#10;        ];&#10;&#10;        foreach ($datePatterns as $pattern) {&#10;            if (preg_match($pattern, $text)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Calcule la proximité entre un nombre/date deviné et les nombres/dates de l'article&#10;     */&#10;    private function calculateNumbersAndDatesProximity(string $guess, string $content, bool $isGuessNumber, bool $isGuessDate): int&#10;    {&#10;        $maxProximity = 0;&#10;&#10;        // Extraire tous les nombres et dates du contenu&#10;        $words = preg_split('/\s+/', $content);&#10;&#10;        foreach ($words as $word) {&#10;            $cleanWord = preg_replace('/[^\w\d\/\-.,]/', '', $word);&#10;&#10;            if ($isGuessNumber &amp;&amp; $this-&gt;isNumber($cleanWord)) {&#10;                $proximity = $this-&gt;calculateNumberProximity($guess, $cleanWord);&#10;                $maxProximity = max($maxProximity, $proximity);&#10;            }&#10;&#10;            if ($isGuessDate &amp;&amp; $this-&gt;isDate($cleanWord)) {&#10;                $proximity = $this-&gt;calculateDateProximity($guess, $cleanWord);&#10;                $maxProximity = max($maxProximity, $proximity);&#10;            }&#10;        }&#10;&#10;        return $maxProximity;&#10;    }&#10;&#10;    /**&#10;     * Calcule la proximité entre deux nombres&#10;     */&#10;    private function calculateNumberProximity(string $number1, string $number2): int&#10;    {&#10;        // Convertir en nombres pour comparaison&#10;        $num1 = $this-&gt;parseNumber($number1);&#10;        $num2 = $this-&gt;parseNumber($number2);&#10;&#10;        if ($num1 === null || $num2 === null) {&#10;            return 0;&#10;        }&#10;&#10;        // Si les nombres sont identiques&#10;        if ($num1 == $num2) {&#10;            return 950;&#10;        }&#10;&#10;        // Calculer la différence relative&#10;        $diff = abs($num1 - $num2);&#10;        $average = ($num1 + $num2) / 2;&#10;        $relativeDiff = $average &gt; 0 ? ($diff / $average) : 1;&#10;&#10;        // Plus la différence relative est petite, plus la proximité est haute&#10;        if ($relativeDiff &lt;= 0.1) {&#10;            return 850; // Très proche (différence de 10% ou moins)&#10;        } elseif ($relativeDiff &lt;= 0.25) {&#10;            return 700; // Proche (différence de 25% ou moins)&#10;        } elseif ($relativeDiff &lt;= 0.5) {&#10;            return 500; // Moyennement proche&#10;        } elseif ($relativeDiff &lt;= 1.0) {&#10;            return 300; // Assez proche&#10;        } elseif ($relativeDiff &lt;= 2.0) {&#10;            return 150; // Distant mais détectable&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;    /**&#10;     * Calcule la proximité entre deux dates&#10;     */&#10;    private function calculateDateProximity(string $date1, string $date2): int&#10;    {&#10;        $timestamp1 = $this-&gt;parseDate($date1);&#10;        $timestamp2 = $this-&gt;parseDate($date2);&#10;&#10;        if ($timestamp1 === null || $timestamp2 === null) {&#10;            return 0;&#10;        }&#10;&#10;        // Si les dates sont identiques&#10;        if ($timestamp1 == $timestamp2) {&#10;            return 950;&#10;        }&#10;&#10;        // Calculer la différence en jours&#10;        $diffDays = abs($timestamp1 - $timestamp2) / (60 * 60 * 24);&#10;&#10;        // Proximité basée sur la différence en jours&#10;        if ($diffDays &lt;= 7) {&#10;            return 850; // Même semaine&#10;        } elseif ($diffDays &lt;= 30) {&#10;            return 700; // Même mois approximativement&#10;        } elseif ($diffDays &lt;= 365) {&#10;            return 500; // Même année approximativement&#10;        } elseif ($diffDays &lt;= 1825) { // 5 ans&#10;            return 300; // Proche dans le temps&#10;        } elseif ($diffDays &lt;= 3650) { // 10 ans&#10;            return 150; // Assez proche&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;    /**&#10;     * Parse un nombre depuis une chaîne&#10;     */&#10;    private function parseNumber(string $numberStr): ?float&#10;    {&#10;        $numberStr = trim($numberStr);&#10;        $numberStr = str_replace([' ', ','], ['', '.'], $numberStr);&#10;        $numberStr = preg_replace('/[^\d.]/', '', $numberStr);&#10;&#10;        if (is_numeric($numberStr)) {&#10;            return (float) $numberStr;&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Parse une date depuis une chaîne&#10;     */&#10;    private function parseDate(string $dateStr): ?int&#10;    {&#10;        $dateStr = trim($dateStr);&#10;&#10;        // Si c'est juste une année&#10;        if (preg_match('/^\d{4}$/', $dateStr)) {&#10;            return mktime(0, 0, 0, 1, 1, (int)$dateStr);&#10;        }&#10;&#10;        // Essayer différents formats&#10;        $formats = [&#10;            'd/m/Y', 'd-m-Y', 'Y-m-d', 'd/m/y', 'd-m-y',&#10;            'j F Y', 'F j, Y', 'j M Y', 'M j, Y'&#10;        ];&#10;&#10;        foreach ($formats as $format) {&#10;            $date = \DateTime::createFromFormat($format, $dateStr);&#10;            if ($date !== false) {&#10;                return $date-&gt;getTimestamp();&#10;            }&#10;        }&#10;&#10;        // Essayer strtotime comme dernier recours&#10;        $timestamp = strtotime($dateStr);&#10;        return $timestamp !== false ? $timestamp : null;&#10;    }&#10;&#10;    private function calculateSemanticSimilarity(string $word1, string $word2): int&#10;    {&#10;        // Base de données de relations sémantiques simplifiée&#10;        $semanticGroups = $this-&gt;getSemanticGroups();&#10;&#10;        $group1 = null;&#10;        $group2 = null;&#10;&#10;        // Trouver les groupes sémantiques des mots&#10;        foreach ($semanticGroups as $groupName =&gt; $words) {&#10;            if (in_array($word1, $words)) {&#10;                $group1 = $groupName;&#10;            }&#10;            if (in_array($word2, $words)) {&#10;                $group2 = $groupName;&#10;            }&#10;        }&#10;&#10;        // Si les deux mots sont dans le même groupe sémantique&#10;        if ($group1 &amp;&amp; $group2 &amp;&amp; $group1 === $group2) {&#10;            return 900; // Très haute proximité sémantique&#10;        }&#10;&#10;        // Vérifier les groupes liés&#10;        $relatedGroups = $this-&gt;getRelatedSemanticGroups();&#10;        if ($group1 &amp;&amp; $group2 &amp;&amp; isset($relatedGroups[$group1]) &amp;&amp; in_array($group2, $relatedGroups[$group1])) {&#10;            return 700; // Proximité sémantique élevée&#10;        }&#10;&#10;        // Vérifier les synonymes directs&#10;        $synonyms = $this-&gt;getSynonyms();&#10;        if (isset($synonyms[$word1]) &amp;&amp; in_array($word2, $synonyms[$word1])) {&#10;            return 850;&#10;        }&#10;        if (isset($synonyms[$word2]) &amp;&amp; in_array($word1, $synonyms[$word2])) {&#10;            return 850;&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;    private function getSemanticGroups(): array&#10;    {&#10;        return [&#10;            'etats_matiere' =&gt; ['liquide', 'gaz', 'solide', 'plasma', 'vapeur', 'fluide'],&#10;            'chimie' =&gt; ['molecule', 'atome', 'element', 'compose', 'reaction', 'chimique', 'formule', 'oxygene', 'hydrogene', 'carbone', 'azote'],&#10;            'eau_related' =&gt; ['eau', 'aquatique', 'marin', 'maritime', 'oceanique', 'fluvial', 'hydrique', 'hydraulique', 'hydrologie'],&#10;            'temperature' =&gt; ['chaud', 'froid', 'chaleur', 'temperature', 'thermique', 'calorique', 'glacial', 'bouillant'],&#10;            'corps_humain' =&gt; ['corps', 'organisme', 'cellule', 'tissu', 'organe', 'muscle', 'sang', 'cerveau', 'coeur'],&#10;            'science' =&gt; ['physique', 'biologie', 'chimie', 'mathematiques', 'recherche', 'experience', 'laboratoire', 'scientifique'],&#10;            'geographie' =&gt; ['terre', 'planete', 'continent', 'ocean', 'mer', 'riviere', 'montagne', 'vallee', 'climat'],&#10;            'vie' =&gt; ['vivant', 'organisme', 'biologique', 'vital', 'existence', 'survie', 'evolutif'],&#10;            'couleurs' =&gt; ['rouge', 'bleu', 'vert', 'jaune', 'noir', 'blanc', 'orange', 'violet', 'rose', 'gris'],&#10;            'taille' =&gt; ['grand', 'petit', 'enorme', 'minuscule', 'gigantesque', 'microscopique', 'immense', 'tiny'],&#10;            'mouvement' =&gt; ['rapide', 'lent', 'vitesse', 'acceleration', 'deceleration', 'mobile', 'statique', 'dynamique'],&#10;            'qualites' =&gt; ['important', 'essentiel', 'crucial', 'vital', 'necessaire', 'indispensable', 'fondamental'],&#10;        ];&#10;    }&#10;&#10;    private function getRelatedSemanticGroups(): array&#10;    {&#10;        return [&#10;            'etats_matiere' =&gt; ['chimie', 'temperature', 'science'],&#10;            'chimie' =&gt; ['etats_matiere', 'science', 'eau_related'],&#10;            'eau_related' =&gt; ['chimie', 'etats_matiere', 'geographie', 'vie'],&#10;            'temperature' =&gt; ['etats_matiere', 'science'],&#10;            'corps_humain' =&gt; ['vie', 'science'],&#10;            'science' =&gt; ['chimie', 'corps_humain', 'temperature'],&#10;            'geographie' =&gt; ['eau_related', 'vie'],&#10;            'vie' =&gt; ['corps_humain', 'eau_related', 'geographie'],&#10;        ];&#10;    }&#10;&#10;    private function getSynonyms(): array&#10;    {&#10;        return [&#10;            'eau' =&gt; ['h2o', 'aqua', 'flotte'],&#10;            'liquide' =&gt; ['fluide', 'liquid'],&#10;            'gaz' =&gt; ['gazeux', 'vapeur', 'aeriforme'],&#10;            'solide' =&gt; ['dur', 'rigide', 'cristallin'],&#10;            'chaud' =&gt; ['chaude', 'brulant', 'torride'],&#10;            'froid' =&gt; ['froide', 'glacial', 'frigide'],&#10;            'grand' =&gt; ['grande', 'gros', 'grosse', 'immense', 'gigantesque'],&#10;            'petit' =&gt; ['petite', 'minuscule', 'infime'],&#10;            'important' =&gt; ['importante', 'essentiel', 'essentielle', 'crucial', 'cruciale'],&#10;            'necessaire' =&gt; ['indispensable', 'requis', 'obligatoire'],&#10;            'vivant' =&gt; ['vivante', 'anime', 'biologique'],&#10;            'chimique' =&gt; ['chimiques', 'moleculaire'],&#10;            'naturel' =&gt; ['naturelle', 'nature', 'natif'],&#10;            'artificiel' =&gt; ['artificielle', 'synthetique', 'fabrique'],&#10;        ];&#10;    }&#10;&#10;    private function calculateLevenshteinSimilarity(string $str1, string $str2): float&#10;    {&#10;        $len1 = strlen($str1);&#10;        $len2 = strlen($str2);&#10;&#10;        if ($len1 === 0 &amp;&amp; $len2 === 0) return 1.0;&#10;        if ($len1 === 0 || $len2 === 0) return 0.0;&#10;&#10;        $distance = levenshtein($str1, $str2);&#10;        $maxLen = max($len1, $len2);&#10;&#10;        return 1 - ($distance / $maxLen);&#10;    }&#10;&#10;    private function getStopWords(): array&#10;    {&#10;        return [&#10;            'le', 'de', 'et', 'à', 'un', 'il', 'être', 'en', 'avoir', 'que', 'pour',&#10;            'dans', 'ce', 'son', 'une', 'sur', 'avec', 'ne', 'se', 'pas', 'tout', 'plus',&#10;            'par', 'grand', 'mais', 'qui', 'comme', 'où', 'ou', 'du', 'des', 'les', 'la',&#10;            'cette', 'ces', 'ses', 'leur', 'leurs', 'aux', 'nous', 'vous', 'ils', 'elles',&#10;            'est', 'sont', 'était', 'ont', 'peut', 'fait', 'très', 'bien', 'deux', 'aussi'&#10;        ];&#10;    }&#10;&#10;    private function buildWordProximityMapping(string $content, array $proximityData): array&#10;    {&#10;        $mapping = [];&#10;&#10;        if (empty($proximityData)) {&#10;            return $mapping;&#10;        }&#10;&#10;        // Extraire tous les mots de l'article&#10;        $allContentWords = $this-&gt;extractAllWordsFromContent($content);&#10;&#10;        foreach ($proximityData as $proximityInfo) {&#10;            $guessedWord = $proximityInfo['word'];&#10;            $proximityScore = $proximityInfo['proximity'];&#10;&#10;            // Trouver le meilleur mot de l'article pour afficher ce mot deviné&#10;            $bestMatch = null;&#10;            $bestSimilarity = 0;&#10;&#10;            foreach ($allContentWords as $contentWord) {&#10;                $normalizedContentWord = $this-&gt;normalizeWord($contentWord);&#10;                $normalizedGuessedWord = $this-&gt;normalizeWord($guessedWord);&#10;&#10;                // Calculer la similarité entre le mot deviné et le mot de l'article&#10;                $similarity = $this-&gt;calculateLevenshteinSimilarity($normalizedGuessedWord, $normalizedContentWord);&#10;&#10;                if ($similarity &gt; $bestSimilarity &amp;&amp; $similarity &gt; 0.3) {&#10;                    $bestSimilarity = $similarity;&#10;                    $bestMatch = $normalizedContentWord;&#10;                }&#10;            }&#10;&#10;            // Si on a trouvé un match suffisamment bon, l'ajouter au mapping&#10;            if ($bestMatch !== null) {&#10;                $mapping[$bestMatch] = [&#10;                    'guessed_word' =&gt; $guessedWord,&#10;                    'proximity' =&gt; $proximityScore&#10;                ];&#10;            }&#10;        }&#10;&#10;        return $mapping;&#10;    }&#10;&#10;    /**&#10;     * Construit un mapping des proximités sémantiques pour les mots trouvés&#10;     */&#10;    private function buildSemanticProximityMapping(string $content, array $foundWords): array&#10;    {&#10;        $mapping = [];&#10;&#10;        if (empty($foundWords)) {&#10;            return $mapping;&#10;        }&#10;&#10;        // Extraire tous les mots de l'article&#10;        $allContentWords = $this-&gt;extractAllWordsFromContent($content);&#10;&#10;        foreach ($foundWords as $foundWord) {&#10;            $normalizedFoundWord = $this-&gt;normalizeWord($foundWord);&#10;&#10;            // Pour chaque mot de l'article, vérifier s'il a une proximité sémantique avec ce mot trouvé&#10;            foreach ($allContentWords as $contentWord) {&#10;                $normalizedContentWord = $this-&gt;normalizeWord($contentWord);&#10;&#10;                // Éviter de remapper le mot sur lui-même s'il est déjà à sa place exacte&#10;                if ($normalizedContentWord === $normalizedFoundWord) {&#10;                    continue;&#10;                }&#10;&#10;                // Calculer la proximité sémantique&#10;                $semanticScore = $this-&gt;calculateSemanticSimilarity($normalizedFoundWord, $normalizedContentWord);&#10;&#10;                // Si il y a une proximité sémantique significative&#10;                if ($semanticScore &gt;= 700) { // Seuil élevé pour l'affichage sémantique&#10;                    // Seulement si ce mot n'a pas déjà un mapping avec un score plus élevé&#10;                    if (!isset($mapping[$normalizedContentWord]) || $mapping[$normalizedContentWord]['proximity'] &lt; $semanticScore) {&#10;                        $mapping[$normalizedContentWord] = [&#10;                            'found_word' =&gt; $foundWord,&#10;                            'proximity' =&gt; $semanticScore&#10;                        ];&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return $mapping;&#10;    }&#10;&#10;    private function getProximityColorStyle(int $proximityScore): string&#10;    {&#10;        // Nouveau système : fond grisé avec texte coloré&#10;        // Jaune très clair = très proche, orange foncé = éloigné&#10;        $baseStyle = 'background: #d0d0d0 !important; padding: 1px 2px !important; border-radius: 3px !important;';&#10;&#10;        if ($proximityScore &gt;= 900) {&#10;            // Très chaud - texte jaune très clair (proche)&#10;            return $baseStyle . ' color: #FFFF99 !important; font-weight: bold !important;';&#10;        } elseif ($proximityScore &gt;= 700) {&#10;            // Chaud - texte jaune doré&#10;            return $baseStyle . ' color: #FFD700 !important; font-weight: bold !important;';&#10;        } elseif ($proximityScore &gt;= 500) {&#10;            // Tiède - texte orange clair&#10;            return $baseStyle . ' color: #FFB347 !important;';&#10;        } elseif ($proximityScore &gt;= 300) {&#10;            // Froid - texte orange&#10;            return $baseStyle . ' color: #FF8C00 !important;';&#10;        } else {&#10;            // Très froid - texte orange foncé (éloigné)&#10;            return $baseStyle . ' color: #CC5500 !important;';&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/templates/game/index.html.twig">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/templates/game/index.html.twig" />
              <option name="originalContent" value="{% extends 'base.html.twig' %}&#10;&#10;{% block title %}Pedantix - Accueil{% endblock %}&#10;&#10;{% block body %}&#10;&lt;div class=&quot;row justify-content-center&quot;&gt;&#10;    &lt;div class=&quot;col-lg-8&quot;&gt;&#10;        &lt;div class=&quot;game-container p-5 text-center&quot;&gt;&#10;            &lt;h1 class=&quot;display-4 mb-4&quot;&gt; Pedantix&lt;/h1&gt;&#10;            &lt;p class=&quot;lead mb-5&quot;&gt;Jeu de mots collaboratif basé sur Wikipedia. Créez votre propre salle ou rejoignez celle d'un ami !&lt;/p&gt;&#10;&#10;            &lt;!-- Onglets pour créer ou rejoindre une salle --&gt;&#10;            &lt;ul class=&quot;nav nav-pills nav-justified mb-4&quot; id=&quot;gameTabs&quot; role=&quot;tablist&quot;&gt;&#10;                &lt;li class=&quot;nav-item&quot; role=&quot;presentation&quot;&gt;&#10;                    &lt;button class=&quot;nav-link active&quot; id=&quot;create-tab&quot; data-bs-toggle=&quot;pill&quot; data-bs-target=&quot;#create-room&quot; type=&quot;button&quot; role=&quot;tab&quot;&gt;&#10;                        &lt;i class=&quot;fas fa-plus-circle me-2&quot;&gt;&lt;/i&gt;Créer une salle&#10;                    &lt;/button&gt;&#10;                &lt;/li&gt;&#10;                &lt;li class=&quot;nav-item&quot; role=&quot;presentation&quot;&gt;&#10;                    &lt;button class=&quot;nav-link&quot; id=&quot;join-tab&quot; data-bs-toggle=&quot;pill&quot; data-bs-target=&quot;#join-room&quot; type=&quot;button&quot; role=&quot;tab&quot;&gt;&#10;                        &lt;i class=&quot;fas fa-users me-2&quot;&gt;&lt;/i&gt;Rejoindre une salle&#10;                    &lt;/button&gt;&#10;                &lt;/li&gt;&#10;            &lt;/ul&gt;&#10;&#10;            &lt;div class=&quot;tab-content&quot; id=&quot;gameTabsContent&quot;&gt;&#10;                &lt;!-- Créer une salle --&gt;&#10;                &lt;div class=&quot;tab-pane fade show active&quot; id=&quot;create-room&quot; role=&quot;tabpanel&quot;&gt;&#10;                    &lt;form id=&quot;createRoomForm&quot;&gt;&#10;                        &lt;div class=&quot;mb-4&quot;&gt;&#10;                            &lt;label for=&quot;wikipediaUrl&quot; class=&quot;form-label fw-bold&quot;&gt;URL de l'article Wikipedia :&lt;/label&gt;&#10;                            &lt;input type=&quot;url&quot; class=&quot;form-control word-input&quot; id=&quot;wikipediaUrl&quot;&#10;                                   placeholder=&quot;https://fr.wikipedia.org/wiki/...&quot; required&gt;&#10;                            &lt;div class=&quot;form-text&quot;&gt;Collez l'URL d'un article Wikipedia français&lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                        &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-lg&quot;&gt;&#10;                            &lt;i class=&quot;fas fa-rocket me-2&quot;&gt;&lt;/i&gt;Créer la salle&#10;                        &lt;/button&gt;&#10;                    &lt;/form&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;!-- Rejoindre une salle --&gt;&#10;                &lt;div class=&quot;tab-pane fade&quot; id=&quot;join-room&quot; role=&quot;tabpanel&quot;&gt;&#10;                    &lt;form id=&quot;joinRoomForm&quot;&gt;&#10;                        &lt;div class=&quot;row g-3&quot;&gt;&#10;                            &lt;div class=&quot;col-md-6&quot;&gt;&#10;                                &lt;label for=&quot;roomCode&quot; class=&quot;form-label fw-bold&quot;&gt;Code de la salle :&lt;/label&gt;&#10;                                &lt;input type=&quot;text&quot; class=&quot;form-control word-input&quot; id=&quot;roomCode&quot;&#10;                                       placeholder=&quot;ABC123&quot; maxlength=&quot;6&quot; required style=&quot;text-transform: uppercase;&quot;&gt;&#10;                            &lt;/div&gt;&#10;                            &lt;div class=&quot;col-md-6&quot;&gt;&#10;                                &lt;label for=&quot;playerName&quot; class=&quot;form-label fw-bold&quot;&gt;Votre nom :&lt;/label&gt;&#10;                                &lt;input type=&quot;text&quot; class=&quot;form-control word-input&quot; id=&quot;playerName&quot;&#10;                                       placeholder=&quot;Votre pseudo&quot; maxlength=&quot;20&quot; required&gt;&#10;                            &lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                        &lt;div class=&quot;mt-4&quot;&gt;&#10;                            &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-lg&quot;&gt;&#10;                                &lt;i class=&quot;fas fa-sign-in-alt me-2&quot;&gt;&lt;/i&gt;Rejoindre la salle&#10;                            &lt;/button&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/form&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;!-- Messages d'erreur/succès --&gt;&#10;            &lt;div id=&quot;alertContainer&quot; class=&quot;mt-4&quot;&gt;&lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;!-- Instructions --&gt;&#10;        &lt;div class=&quot;game-container p-4 mt-4&quot;&gt;&#10;            &lt;h3 class=&quot;text-center mb-3&quot;&gt;Comment jouer ?&lt;/h3&gt;&#10;            &lt;div class=&quot;row&quot;&gt;&#10;                &lt;div class=&quot;col-md-4 text-center mb-3&quot;&gt;&#10;                    &lt;i class=&quot;fas fa-search fa-3x text-primary mb-3&quot;&gt;&lt;/i&gt;&#10;                    &lt;h5&gt;Devinez les mots&lt;/h5&gt;&#10;                    &lt;p&gt;Trouvez les mots-clés de l'article Wikipedia choisi&lt;/p&gt;&#10;                &lt;/div&gt;&#10;                &lt;div class=&quot;col-md-4 text-center mb-3&quot;&gt;&#10;                    &lt;i class=&quot;fas fa-trophy fa-3x text-warning mb-3&quot;&gt;&lt;/i&gt;&#10;                    &lt;h5&gt;Gagnez des points&lt;/h5&gt;&#10;                    &lt;p&gt;Plus le mot est important dans l'article, plus vous gagnez de points&lt;/p&gt;&#10;                &lt;/div&gt;&#10;                &lt;div class=&quot;col-md-4 text-center mb-3&quot;&gt;&#10;                    &lt;i class=&quot;fas fa-users fa-3x text-success mb-3&quot;&gt;&lt;/i&gt;&#10;                    &lt;h5&gt;Jouez ensemble&lt;/h5&gt;&#10;                    &lt;p&gt;Partagez le code de votre salle avec vos amis pour jouer ensemble&lt;/p&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    &lt;/div&gt;&#10;&lt;/div&gt;&#10;{% endblock %}&#10;&#10;{% block javascripts %}&#10;&lt;script&gt;&#10;document.addEventListener('DOMContentLoaded', function() {&#10;    const createForm = document.getElementById('createRoomForm');&#10;    const joinForm = document.getElementById('joinRoomForm');&#10;    const alertContainer = document.getElementById('alertContainer');&#10;&#10;    // Transformer le code de salle en majuscules&#10;    document.getElementById('roomCode').addEventListener('input', function(e) {&#10;        e.target.value = e.target.value.toUpperCase();&#10;    });&#10;&#10;    // Gérer la création de salle&#10;    createForm.addEventListener('submit', async function(e) {&#10;        e.preventDefault();&#10;&#10;        const formData = new FormData(e.target);&#10;        const wikipediaUrl = formData.get('wikipediaUrl') || document.getElementById('wikipediaUrl').value;&#10;&#10;        if (!wikipediaUrl) {&#10;            showAlert('Veuillez entrer une URL Wikipedia valide.', 'danger');&#10;            return;&#10;        }&#10;&#10;        showAlert('Création de la salle en cours...', 'info');&#10;&#10;        try {&#10;            const response = await fetch('/create-room', {&#10;                method: 'POST',&#10;                headers: {&#10;                    'Content-Type': 'application/json',&#10;                },&#10;                body: JSON.stringify({&#10;                    wikipedia_url: wikipediaUrl&#10;                })&#10;            });&#10;&#10;            const data = await response.json();&#10;&#10;            if (data.success) {&#10;                showAlert(`Salle créée avec succès ! Code: &lt;strong&gt;${data.room_code}&lt;/strong&gt;&lt;br&gt;Article: ${data.title}`, 'success');&#10;                setTimeout(() =&gt; {&#10;                    window.location.href = `/game/${data.room_code}`;&#10;                }, 2000);&#10;            } else {&#10;                showAlert(data.error || 'Erreur lors de la création de la salle', 'danger');&#10;            }&#10;        } catch (error) {&#10;            showAlert('Erreur de connexion. Veuillez réessayer.', 'danger');&#10;        }&#10;    });&#10;&#10;    // Gérer la connexion à une salle&#10;    joinForm.addEventListener('submit', async function(e) {&#10;        e.preventDefault();&#10;&#10;        const roomCode = document.getElementById('roomCode').value;&#10;        const playerName = document.getElementById('playerName').value;&#10;&#10;        if (!roomCode || !playerName) {&#10;            showAlert('Veuillez remplir tous les champs.', 'danger');&#10;            return;&#10;        }&#10;&#10;        showAlert('Connexion à la salle...', 'info');&#10;&#10;        try {&#10;            const response = await fetch('/join-room', {&#10;                method: 'POST',&#10;                headers: {&#10;                    'Content-Type': 'application/json',&#10;                },&#10;                body: JSON.stringify({&#10;                    room_code: roomCode,&#10;                    player_name: playerName&#10;                })&#10;            });&#10;&#10;            const data = await response.json();&#10;&#10;            if (data.success) {&#10;                // Stocker les informations de session&#10;                sessionStorage.setItem('gameSession', JSON.stringify({&#10;                    sessionId: data.session_id,&#10;                    roomCode: data.room.code,&#10;                    playerName: data.player.name&#10;                }));&#10;&#10;                window.location.href = `/game/${data.room.code}`;&#10;            } else {&#10;                showAlert(data.error || 'Erreur lors de la connexion à la salle', 'danger');&#10;            }&#10;        } catch (error) {&#10;            showAlert('Erreur de connexion. Veuillez réessayer.', 'danger');&#10;        }&#10;    });&#10;&#10;    function showAlert(message, type) {&#10;        alertContainer.innerHTML = `&#10;            &lt;div class=&quot;alert alert-${type} alert-dismissible fade show&quot; role=&quot;alert&quot;&gt;&#10;                ${message}&#10;                &lt;button type=&quot;button&quot; class=&quot;btn-close&quot; data-bs-dismiss=&quot;alert&quot;&gt;&lt;/button&gt;&#10;            &lt;/div&gt;&#10;        `;&#10;    }&#10;});&#10;&lt;/script&gt;&#10;{% endblock %}&#10;" />
              <option name="updatedContent" value="{% extends 'base.html.twig' %}&#10;&#10;{% block title %}Pedantix - Accueil{% endblock %}&#10;&#10;{% block body %}&#10;&lt;div class=&quot;row justify-content-center&quot;&gt;&#10;    &lt;div class=&quot;col-lg-8&quot;&gt;&#10;        &lt;div class=&quot;game-container p-5 text-center&quot;&gt;&#10;            &lt;h1 class=&quot;display-4 mb-4&quot;&gt; Pedantix&lt;/h1&gt;&#10;            &lt;p class=&quot;lead mb-5&quot;&gt;Jeu de mots collaboratif basé sur Wikipedia. Créez votre propre salle ou rejoignez celle d'un ami !&lt;/p&gt;&#10;&#10;            &lt;!-- Onglets pour créer ou rejoindre une salle --&gt;&#10;            &lt;ul class=&quot;nav nav-pills nav-justified mb-4&quot; id=&quot;gameTabs&quot; role=&quot;tablist&quot;&gt;&#10;                &lt;li class=&quot;nav-item&quot; role=&quot;presentation&quot;&gt;&#10;                    &lt;button class=&quot;nav-link active&quot; id=&quot;create-tab&quot; data-bs-toggle=&quot;pill&quot; data-bs-target=&quot;#create-room&quot; type=&quot;button&quot; role=&quot;tab&quot;&gt;&#10;                        &lt;i class=&quot;fas fa-plus-circle me-2&quot;&gt;&lt;/i&gt;Créer une salle&#10;                    &lt;/button&gt;&#10;                &lt;/li&gt;&#10;                &lt;li class=&quot;nav-item&quot; role=&quot;presentation&quot;&gt;&#10;                    &lt;button class=&quot;nav-link&quot; id=&quot;join-tab&quot; data-bs-toggle=&quot;pill&quot; data-bs-target=&quot;#join-room&quot; type=&quot;button&quot; role=&quot;tab&quot;&gt;&#10;                        &lt;i class=&quot;fas fa-users me-2&quot;&gt;&lt;/i&gt;Rejoindre une salle&#10;                    &lt;/button&gt;&#10;                &lt;/li&gt;&#10;            &lt;/ul&gt;&#10;&#10;            &lt;div class=&quot;tab-content&quot; id=&quot;gameTabsContent&quot;&gt;&#10;                &lt;!-- Créer une salle --&gt;&#10;                &lt;div class=&quot;tab-pane fade show active&quot; id=&quot;create-room&quot; role=&quot;tabpanel&quot;&gt;&#10;                    &lt;form id=&quot;createRoomForm&quot;&gt;&#10;                        &lt;div class=&quot;mb-4&quot;&gt;&#10;                            &lt;label for=&quot;wikipediaUrl&quot; class=&quot;form-label fw-bold&quot;&gt;URL de l'article Wikipedia :&lt;/label&gt;&#10;                            &lt;input type=&quot;url&quot; class=&quot;form-control word-input&quot; id=&quot;wikipediaUrl&quot;&#10;                                   placeholder=&quot;https://fr.wikipedia.org/wiki/...&quot; required&gt;&#10;                            &lt;div class=&quot;form-text&quot;&gt;Collez l'URL d'un article Wikipedia français&lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                        &#10;                        &lt;div class=&quot;mb-4&quot;&gt;&#10;                            &lt;label class=&quot;form-label fw-bold&quot;&gt;Mode de jeu :&lt;/label&gt;&#10;                            &lt;div class=&quot;row g-3&quot;&gt;&#10;                                &lt;div class=&quot;col-md-6&quot;&gt;&#10;                                    &lt;div class=&quot;card h-100&quot;&gt;&#10;                                        &lt;div class=&quot;card-body text-center&quot;&gt;&#10;                                            &lt;input type=&quot;radio&quot; class=&quot;form-check-input&quot; id=&quot;competitionMode&quot; name=&quot;gameMode&quot; value=&quot;competition&quot; checked&gt;&#10;                                            &lt;label for=&quot;competitionMode&quot; class=&quot;form-check-label&quot;&gt;&#10;                                                &lt;h5 class=&quot;card-title mt-2&quot;&gt; Compétition&lt;/h5&gt;&#10;                                                &lt;p class=&quot;card-text small&quot;&gt;Chaque joueur trouve ses propres mots. Le premier à trouver le mot-titre gagne !&lt;/p&gt;&#10;                                            &lt;/label&gt;&#10;                                        &lt;/div&gt;&#10;                                    &lt;/div&gt;&#10;                                &lt;/div&gt;&#10;                                &lt;div class=&quot;col-md-6&quot;&gt;&#10;                                    &lt;div class=&quot;card h-100&quot;&gt;&#10;                                        &lt;div class=&quot;card-body text-center&quot;&gt;&#10;                                            &lt;input type=&quot;radio&quot; class=&quot;form-check-input&quot; id=&quot;cooperationMode&quot; name=&quot;gameMode&quot; value=&quot;cooperation&quot;&gt;&#10;                                            &lt;label for=&quot;cooperationMode&quot; class=&quot;form-check-label&quot;&gt;&#10;                                                &lt;h5 class=&quot;card-title mt-2&quot;&gt; Coopération&lt;/h5&gt;&#10;                                                &lt;p class=&quot;card-text small&quot;&gt;Tous les mots trouvés par les joueurs apparaissent pour tout le monde. Travaillez ensemble !&lt;/p&gt;&#10;                                            &lt;/label&gt;&#10;                                        &lt;/div&gt;&#10;                                    &lt;/div&gt;&#10;                                &lt;/div&gt;&#10;                            &lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                        &#10;                        &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-lg&quot;&gt;&#10;                            &lt;i class=&quot;fas fa-rocket me-2&quot;&gt;&lt;/i&gt;Créer la salle&#10;                        &lt;/button&gt;&#10;                    &lt;/form&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;!-- Rejoindre une salle --&gt;&#10;                &lt;div class=&quot;tab-pane fade&quot; id=&quot;join-room&quot; role=&quot;tabpanel&quot;&gt;&#10;                    &lt;form id=&quot;joinRoomForm&quot;&gt;&#10;                        &lt;div class=&quot;row g-3&quot;&gt;&#10;                            &lt;div class=&quot;col-md-6&quot;&gt;&#10;                                &lt;label for=&quot;roomCode&quot; class=&quot;form-label fw-bold&quot;&gt;Code de la salle :&lt;/label&gt;&#10;                                &lt;input type=&quot;text&quot; class=&quot;form-control word-input&quot; id=&quot;roomCode&quot;&#10;                                       placeholder=&quot;ABC123&quot; maxlength=&quot;6&quot; required style=&quot;text-transform: uppercase;&quot;&gt;&#10;                            &lt;/div&gt;&#10;                            &lt;div class=&quot;col-md-6&quot;&gt;&#10;                                &lt;label for=&quot;playerName&quot; class=&quot;form-label fw-bold&quot;&gt;Votre nom :&lt;/label&gt;&#10;                                &lt;input type=&quot;text&quot; class=&quot;form-control word-input&quot; id=&quot;playerName&quot;&#10;                                       placeholder=&quot;Votre pseudo&quot; maxlength=&quot;20&quot; required&gt;&#10;                            &lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                        &lt;div class=&quot;mt-4&quot;&gt;&#10;                            &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-lg&quot;&gt;&#10;                                &lt;i class=&quot;fas fa-sign-in-alt me-2&quot;&gt;&lt;/i&gt;Rejoindre la salle&#10;                            &lt;/button&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/form&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;!-- Messages d'erreur/succès --&gt;&#10;            &lt;div id=&quot;alertContainer&quot; class=&quot;mt-4&quot;&gt;&lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;!-- Instructions --&gt;&#10;        &lt;div class=&quot;game-container p-4 mt-4&quot;&gt;&#10;            &lt;h3 class=&quot;text-center mb-3&quot;&gt;Comment jouer ?&lt;/h3&gt;&#10;            &lt;div class=&quot;row&quot;&gt;&#10;                &lt;div class=&quot;col-md-4 text-center mb-3&quot;&gt;&#10;                    &lt;i class=&quot;fas fa-search fa-3x text-primary mb-3&quot;&gt;&lt;/i&gt;&#10;                    &lt;h5&gt;Devinez les mots&lt;/h5&gt;&#10;                    &lt;p&gt;Trouvez les mots-clés de l'article Wikipedia choisi&lt;/p&gt;&#10;                &lt;/div&gt;&#10;                &lt;div class=&quot;col-md-4 text-center mb-3&quot;&gt;&#10;                    &lt;i class=&quot;fas fa-trophy fa-3x text-warning mb-3&quot;&gt;&lt;/i&gt;&#10;                    &lt;h5&gt;Gagnez des points&lt;/h5&gt;&#10;                    &lt;p&gt;Plus le mot est important dans l'article, plus vous gagnez de points&lt;/p&gt;&#10;                &lt;/div&gt;&#10;                &lt;div class=&quot;col-md-4 text-center mb-3&quot;&gt;&#10;                    &lt;i class=&quot;fas fa-users fa-3x text-success mb-3&quot;&gt;&lt;/i&gt;&#10;                    &lt;h5&gt;Jouez ensemble&lt;/h5&gt;&#10;                    &lt;p&gt;Partagez le code de votre salle avec vos amis pour jouer ensemble&lt;/p&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    &lt;/div&gt;&#10;&lt;/div&gt;&#10;{% endblock %}&#10;&#10;{% block javascripts %}&#10;&lt;script&gt;&#10;document.addEventListener('DOMContentLoaded', function() {&#10;    const createForm = document.getElementById('createRoomForm');&#10;    const joinForm = document.getElementById('joinRoomForm');&#10;    const alertContainer = document.getElementById('alertContainer');&#10;&#10;    // Transformer le code de salle en majuscules&#10;    document.getElementById('roomCode').addEventListener('input', function(e) {&#10;        e.target.value = e.target.value.toUpperCase();&#10;    });&#10;&#10;    // Gérer la création de salle&#10;    createForm.addEventListener('submit', async function(e) {&#10;        e.preventDefault();&#10;&#10;        const formData = new FormData(e.target);&#10;        const wikipediaUrl = formData.get('wikipediaUrl') || document.getElementById('wikipediaUrl').value;&#10;        const gameMode = formData.get('gameMode') || 'competition';&#10;&#10;        if (!wikipediaUrl) {&#10;            showAlert('Veuillez entrer une URL Wikipedia valide.', 'danger');&#10;            return;&#10;        }&#10;&#10;        showAlert('Création de la salle en cours...', 'info');&#10;&#10;        try {&#10;            const response = await fetch('/create-room', {&#10;                method: 'POST',&#10;                headers: {&#10;                    'Content-Type': 'application/json',&#10;                },&#10;                body: JSON.stringify({&#10;                    wikipedia_url: wikipediaUrl,&#10;                    game_mode: gameMode&#10;                })&#10;            });&#10;&#10;            const data = await response.json();&#10;&#10;            if (data.success) {&#10;                const modeText = data.game_mode === 'cooperation' ? ' (Mode Coopération)' : ' (Mode Compétition)';&#10;                showAlert(`Salle créée avec succès ! Code: &lt;strong&gt;${data.room_code}&lt;/strong&gt;&lt;br&gt;Article: ${data.title}${modeText}`, 'success');&#10;                setTimeout(() =&gt; {&#10;                    window.location.href = `/game/${data.room_code}`;&#10;                }, 2000);&#10;            } else {&#10;                showAlert(data.error || 'Erreur lors de la création de la salle', 'danger');&#10;            }&#10;        } catch (error) {&#10;            showAlert('Erreur de connexion. Veuillez réessayer.', 'danger');&#10;        }&#10;    });&#10;&#10;    // Gérer la connexion à une salle&#10;    joinForm.addEventListener('submit', async function(e) {&#10;        e.preventDefault();&#10;&#10;        const roomCode = document.getElementById('roomCode').value;&#10;        const playerName = document.getElementById('playerName').value;&#10;&#10;        if (!roomCode || !playerName) {&#10;            showAlert('Veuillez remplir tous les champs.', 'danger');&#10;            return;&#10;        }&#10;&#10;        showAlert('Connexion à la salle...', 'info');&#10;&#10;        try {&#10;            const response = await fetch('/join-room', {&#10;                method: 'POST',&#10;                headers: {&#10;                    'Content-Type': 'application/json',&#10;                },&#10;                body: JSON.stringify({&#10;                    room_code: roomCode,&#10;                    player_name: playerName&#10;                })&#10;            });&#10;&#10;            const data = await response.json();&#10;&#10;            if (data.success) {&#10;                // Stocker les informations de session&#10;                sessionStorage.setItem('gameSession', JSON.stringify({&#10;                    sessionId: data.session_id,&#10;                    roomCode: data.room.code,&#10;                    playerName: data.player.name&#10;                }));&#10;&#10;                window.location.href = `/game/${data.room.code}`;&#10;            } else {&#10;                showAlert(data.error || 'Erreur lors de la connexion à la salle', 'danger');&#10;            }&#10;        } catch (error) {&#10;            showAlert('Erreur de connexion. Veuillez réessayer.', 'danger');&#10;        }&#10;    });&#10;&#10;    function showAlert(message, type) {&#10;        alertContainer.innerHTML = `&#10;            &lt;div class=&quot;alert alert-${type} alert-dismissible fade show&quot; role=&quot;alert&quot;&gt;&#10;                ${message}&#10;                &lt;button type=&quot;button&quot; class=&quot;btn-close&quot; data-bs-dismiss=&quot;alert&quot;&gt;&lt;/button&gt;&#10;            &lt;/div&gt;&#10;        `;&#10;    }&#10;});&#10;&lt;/script&gt;&#10;{% endblock %}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>