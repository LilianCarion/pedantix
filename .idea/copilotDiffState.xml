<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env.prod">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.prod" />
              <option name="updatedContent" value="# Configuration pour la production&#10;APP_ENV=prod&#10;APP_SECRET=CHANGEZ_CETTE_CLE_SECRETE_EN_PRODUCTION&#10;APP_DEBUG=0&#10;&#10;# Base de données - À adapter selon votre serveur OVH&#10;DATABASE_URL=&quot;mysql://username:password@localhost:3306/pedantix_prod?serverVersion=8.0&amp;charset=utf8mb4&quot;&#10;&#10;# Configuration serveur&#10;TRUSTED_PROXIES=127.0.0.0/8,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16&#10;TRUSTED_HOSTS='^(localhost|127\.0\.0\.1|yourdomainname\.com)$'&#10;&#10;# Optimisations&#10;OPCACHE_PRELOAD=var/cache/prod/App_KernelProdContainer.preload.php" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bin/deploy.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bin/deploy.sh" />
              <option name="updatedContent" value="#!/bin/bash&#10;&#10;# Script de déploiement complet pour Pedantix&#10;# Usage: ./bin/deploy.sh [production|dev]&#10;&#10;set -e  # Arrêter le script en cas d'erreur&#10;&#10;ENV=${1:-production}&#10;echo &quot; Démarrage du déploiement Pedantix en mode: $ENV&quot;&#10;&#10;# Couleurs pour les messages&#10;RED='\033[0;31m'&#10;GREEN='\033[0;32m'&#10;YELLOW='\033[1;33m'&#10;NC='\033[0m' # No Color&#10;&#10;# Fonction pour afficher des messages colorés&#10;log_info() {&#10;    echo -e &quot;${GREEN}[INFO]${NC} $1&quot;&#10;}&#10;&#10;log_warning() {&#10;    echo -e &quot;${YELLOW}[WARNING]${NC} $1&quot;&#10;}&#10;&#10;log_error() {&#10;    echo -e &quot;${RED}[ERROR]${NC} $1&quot;&#10;}&#10;&#10;# Vérifier que Composer est installé&#10;if ! command -v composer &amp;&gt; /dev/null; then&#10;    log_error &quot;Composer n'est pas installé. Veuillez l'installer d'abord.&quot;&#10;    exit 1&#10;fi&#10;&#10;# Vérifier que PHP est installé&#10;if ! command -v php &amp;&gt; /dev/null; then&#10;    log_error &quot;PHP n'est pas installé. Veuillez l'installer d'abord.&quot;&#10;    exit 1&#10;fi&#10;&#10;log_info &quot;1. Installation des dépendances...&quot;&#10;if [ &quot;$ENV&quot; = &quot;production&quot; ]; then&#10;    composer install --no-dev --optimize-autoloader&#10;else&#10;    composer install&#10;fi&#10;&#10;log_info &quot;2. Configuration de l'environnement...&quot;&#10;if [ ! -f .env ]; then&#10;    if [ -f .env.example ]; then&#10;        cp .env.example .env&#10;        log_warning &quot;Fichier .env créé depuis .env.example. Veuillez le configurer avec vos paramètres.&quot;&#10;    else&#10;        log_error &quot;Aucun fichier .env trouvé. Veuillez en créer un.&quot;&#10;        exit 1&#10;    fi&#10;fi&#10;&#10;# Nettoyer le cache&#10;log_info &quot;3. Nettoyage du cache...&quot;&#10;php bin/console cache:clear --env=$ENV --no-debug&#10;&#10;if [ &quot;$ENV&quot; = &quot;production&quot; ]; then&#10;    # Optimisations pour la production&#10;    log_info &quot;4. Optimisations pour la production...&quot;&#10;    php bin/console cache:warmup --env=prod --no-debug&#10;    &#10;    # Générer les assets optimisés si Webpack Encore est utilisé&#10;    if [ -f &quot;webpack.config.js&quot; ]; then&#10;        if command -v npm &amp;&gt; /dev/null; then&#10;            log_info &quot;   Installation des dépendances Node.js...&quot;&#10;            npm install&#10;            log_info &quot;   Build des assets pour la production...&quot;&#10;            npm run build&#10;        fi&#10;    fi&#10;fi&#10;&#10;# Vérifier la configuration de la base de données&#10;log_info &quot;5. Vérification de la base de données...&quot;&#10;if php bin/console doctrine:database:create --if-not-exists --no-interaction; then&#10;    log_info &quot;   Base de données créée ou déjà existante&quot;&#10;else&#10;    log_warning &quot;   Impossible de créer la base de données - vérifiez la configuration&quot;&#10;fi&#10;&#10;# Exécuter les migrations&#10;log_info &quot;6. Exécution des migrations...&quot;&#10;php bin/console doctrine:migrations:migrate --no-interaction&#10;&#10;# Peuplement de la base avec les articles Wikipedia&#10;log_info &quot;7. Peuplement de la base de données avec les articles...&quot;&#10;php bin/console app:seed-wikipedia-articles&#10;&#10;# Vérifier que tout fonctionne&#10;log_info &quot;8. Vérification de l'installation...&quot;&#10;if php bin/console debug:container --env=$ENV &gt; /dev/null 2&gt;&amp;1; then&#10;    log_info &quot;   Container Symfony OK&quot;&#10;else&#10;    log_error &quot;   Problème avec le container Symfony&quot;&#10;    exit 1&#10;fi&#10;&#10;# Test de connexion à la base de données&#10;if php bin/console doctrine:schema:validate --no-interaction &gt; /dev/null 2&gt;&amp;1; then&#10;    log_info &quot;   Schéma de base de données OK&quot;&#10;else&#10;    log_warning &quot;   Problème potentiel avec le schéma de base de données&quot;&#10;fi&#10;&#10;# Permissions pour les fichiers de cache et logs&#10;log_info &quot;9. Configuration des permissions...&quot;&#10;if [ -d &quot;var/cache&quot; ]; then&#10;    chmod -R 775 var/cache&#10;    log_info &quot;   Permissions cache configurées&quot;&#10;fi&#10;&#10;if [ -d &quot;var/log&quot; ]; then&#10;    chmod -R 775 var/log&#10;    log_info &quot;   Permissions logs configurées&quot;&#10;fi&#10;&#10;# Afficher les informations finales&#10;log_info &quot;10. Informations de déploiement...&quot;&#10;echo &quot;&quot;&#10;echo &quot; Statistiques:&quot;&#10;echo &quot;   - Articles en base: $(php bin/console doctrine:query:sql 'SELECT COUNT(*) as count FROM wikipedia_article' --quiet | tail -n +3 | head -1 | awk '{print $1}')&quot;&#10;echo &quot;   - Environment: $ENV&quot;&#10;echo &quot;   - Version PHP: $(php -r 'echo PHP_VERSION;')&quot;&#10;echo &quot;   - Symfony version: $(php bin/console --version | head -1)&quot;&#10;echo &quot;&quot;&#10;&#10;if [ &quot;$ENV&quot; = &quot;production&quot; ]; then&#10;    echo &quot; Conseils pour la production:&quot;&#10;    echo &quot;   - Assurez-vous que votre serveur web pointe vers le dossier 'public/'&quot;&#10;    echo &quot;   - Configurez HTTPS&quot;&#10;    echo &quot;   - Vérifiez que les variables d'environnement sont correctement définies&quot;&#10;    echo &quot;   - Surveillez les logs dans var/log/&quot;&#10;    echo &quot;&quot;&#10;fi&#10;&#10;echo &quot; Points d'accès:&quot;&#10;echo &quot;   - Page d'accueil: //&quot;&#10;echo &quot;   - API articles aléatoires: /api/random-article&quot;&#10;echo &quot;   - Créer une salle: /create-room&quot;&#10;echo &quot;&quot;&#10;&#10;log_info &quot;✅ Déploiement terminé avec succès!&quot;&#10;echo &quot;&quot;&#10;echo &quot; Votre application Pedantix est prête !&quot;&#10;echo &quot;   Pour démarrer le serveur de développement: php -S localhost:8000 -t public/&quot;&#10;echo &quot;&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/install.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/install.sh" />
              <option name="updatedContent" value="#!/bin/bash&#10;&#10;# Script d'installation rapide pour serveur OVH&#10;# Usage: curl -sSL https://votre-repo.com/install.sh | bash&#10;&#10;echo &quot; Installation Pedantix sur serveur OVH&quot;&#10;echo &quot;========================================&quot;&#10;&#10;# Vérifications préalables&#10;if ! command -v php &amp;&gt; /dev/null; then&#10;    echo &quot;❌ PHP n'est pas installé&quot;&#10;    exit 1&#10;fi&#10;&#10;if ! command -v composer &amp;&gt; /dev/null; then&#10;    echo &quot;❌ Composer n'est pas installé&quot;&#10;    exit 1&#10;fi&#10;&#10;# Installation&#10;echo &quot; Installation des dépendances...&quot;&#10;composer install --no-dev --optimize-autoloader --no-interaction&#10;&#10;echo &quot; Configuration...&quot;&#10;if [ ! -f .env ]; then&#10;    cp .env.prod .env&#10;    echo &quot;⚠️  Fichier .env créé - MODIFIEZ LA CONFIGURATION !&quot;&#10;fi&#10;&#10;echo &quot; Déploiement automatique...&quot;&#10;php bin/console app:deploy prod&#10;&#10;echo &quot;&quot;&#10;echo &quot;✅ Installation terminée !&quot;&#10;echo &quot;&quot;&#10;echo &quot; Actions requises :&quot;&#10;echo &quot;1. Modifiez le fichier .env avec vos paramètres de base de données&quot;&#10;echo &quot;2. Configurez votre serveur web pour pointer vers public/&quot;&#10;echo &quot;3. Activez HTTPS&quot;&#10;echo &quot;&quot;&#10;echo &quot; Votre Pedantix est prêt avec plus de 150 articles Wikipedia !&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Command/DeployCommand.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Command/DeployCommand.php" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;namespace App\Command;&#10;&#10;use Doctrine\ORM\EntityManagerInterface;&#10;use Symfony\Component\Console\Attribute\AsCommand;&#10;use Symfony\Component\Console\Command\Command;&#10;use Symfony\Component\Console\Input\InputArgument;&#10;use Symfony\Component\Console\Input\InputInterface;&#10;use Symfony\Component\Console\Output\OutputInterface;&#10;use Symfony\Component\Console\Style\SymfonyStyle;&#10;use Symfony\Component\Process\Process;&#10;&#10;#[AsCommand(&#10;    name: 'app:deploy',&#10;    description: 'Déploie l\'application Pedantix en une seule commande (migrations, articles, cache, etc.)',&#10;)]&#10;class DeployCommand extends Command&#10;{&#10;    public function __construct(&#10;        private EntityManagerInterface $entityManager&#10;    ) {&#10;        parent::__construct();&#10;    }&#10;&#10;    protected function configure(): void&#10;    {&#10;        $this&#10;            -&gt;addArgument('env', InputArgument::OPTIONAL, 'Environnement (dev|prod)', 'prod')&#10;            -&gt;setHelp('Cette commande déploie l\'application Pedantix en exécutant toutes les étapes nécessaires.');&#10;    }&#10;&#10;    protected function execute(InputInterface $input, OutputInterface $output): int&#10;    {&#10;        $io = new SymfonyStyle($input, $output);&#10;        $env = $input-&gt;getArgument('env');&#10;&#10;        $io-&gt;title(' Déploiement Pedantix');&#10;&#10;        try {&#10;            // 1. Nettoyer le cache&#10;            $io-&gt;section('1. Nettoyage du cache');&#10;            $this-&gt;runCommand(['cache:clear', '--env=' . $env], $io);&#10;&#10;            // 2. Créer la base de données si nécessaire&#10;            $io-&gt;section('2. Configuration de la base de données');&#10;            $this-&gt;runCommand(['doctrine:database:create', '--if-not-exists'], $io);&#10;&#10;            // 3. Exécuter les migrations&#10;            $io-&gt;section('3. Migrations de la base de données');&#10;            $this-&gt;runCommand(['doctrine:migrations:migrate', '--no-interaction'], $io);&#10;&#10;            // 4. Peupler avec les articles Wikipedia&#10;            $io-&gt;section('4. Peuplement des articles Wikipedia');&#10;            $this-&gt;runCommand(['app:seed-wikipedia-articles'], $io);&#10;&#10;            // 5. Vérifications finales&#10;            $io-&gt;section('5. Vérifications');&#10;            &#10;            // Compter les articles&#10;            $articleCount = $this-&gt;entityManager&#10;                -&gt;createQuery('SELECT COUNT(a.id) FROM App\Entity\WikipediaArticle a')&#10;                -&gt;getSingleScalarResult();&#10;&#10;            $io-&gt;success([&#10;                'Déploiement terminé avec succès !',&#10;                &quot;Articles en base de données : {$articleCount}&quot;,&#10;                'Application prête à être utilisée'&#10;            ]);&#10;&#10;            $io-&gt;section(' Points d\'accès de l\'application');&#10;            $io-&gt;table(['Endpoint', 'Description'], [&#10;                ['/', 'Page d\'accueil'],&#10;                ['/create-room', 'Créer une nouvelle partie'],&#10;                ['/api/random-article', 'Article aléatoire'],&#10;                ['/game/{code}', 'Rejoindre une partie'],&#10;            ]);&#10;&#10;            if ($env === 'prod') {&#10;                $io-&gt;note([&#10;                    'Mode production activé',&#10;                    'Assurez-vous que :',&#10;                    '- Le serveur web pointe vers public/',&#10;                    '- HTTPS est configuré',&#10;                    '- Les variables d\'environnement sont définies',&#10;                    '- Les permissions des dossiers var/ sont correctes'&#10;                ]);&#10;            }&#10;&#10;            return Command::SUCCESS;&#10;&#10;        } catch (\Exception $e) {&#10;            $io-&gt;error([&#10;                'Erreur lors du déploiement :',&#10;                $e-&gt;getMessage()&#10;            ]);&#10;            return Command::FAILURE;&#10;        }&#10;    }&#10;&#10;    private function runCommand(array $command, SymfonyStyle $io): void&#10;    {&#10;        $process = new Process(['php', 'bin/console', ...$command]);&#10;        $process-&gt;setTimeout(300); // 5 minutes max par commande&#10;        &#10;        $io-&gt;write(&quot;Exécution : &quot; . implode(' ', $command) . &quot;... &quot;);&#10;        &#10;        $process-&gt;run();&#10;&#10;        if ($process-&gt;isSuccessful()) {&#10;            $io-&gt;writeln('&lt;fg=green&gt;✓ OK&lt;/&gt;');&#10;            if ($output = $process-&gt;getOutput()) {&#10;                $io-&gt;text($output);&#10;            }&#10;        } else {&#10;            $io-&gt;writeln('&lt;fg=red&gt;✗ ERREUR&lt;/&gt;');&#10;            throw new \Exception('Commande échouée: ' . $process-&gt;getErrorOutput());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Command/SeedWikipediaArticlesCommand.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Command/SeedWikipediaArticlesCommand.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;namespace App\Command;&#10;&#10;use App\Entity\WikipediaArticle;&#10;use Doctrine\ORM\EntityManagerInterface;&#10;use Symfony\Component\Console\Attribute\AsCommand;&#10;use Symfony\Component\Console\Command\Command;&#10;use Symfony\Component\Console\Input\InputInterface;&#10;use Symfony\Component\Console\Output\OutputInterface;&#10;use Symfony\Component\Console\Style\SymfonyStyle;&#10;&#10;#[AsCommand(&#10;    name: 'app:seed-wikipedia-articles',&#10;    description: 'Ajoute des articles Wikipedia par défaut dans la base de données',&#10;)]&#10;class SeedWikipediaArticlesCommand extends Command&#10;{&#10;    public function __construct(&#10;        private EntityManagerInterface $entityManager&#10;    ) {&#10;        parent::__construct();&#10;    }&#10;&#10;    protected function execute(InputInterface $input, OutputInterface $output): int&#10;    {&#10;        $io = new SymfonyStyle($input, $output);&#10;&#10;        // Articles Wikipedia français populaires pour différents niveaux de difficulté&#10;        $articles = [&#10;            // Facile&#10;            [&#10;                'title' =&gt; 'Chat',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Chat',&#10;                'category' =&gt; 'Animaux',&#10;                'difficulty' =&gt; 'facile'&#10;            ],&#10;            [&#10;                'title' =&gt; 'Paris',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Paris',&#10;                'category' =&gt; 'Géographie',&#10;                'difficulty' =&gt; 'facile'&#10;            ],&#10;            [&#10;                'title' =&gt; 'Eau',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Eau',&#10;                'category' =&gt; 'Science',&#10;                'difficulty' =&gt; 'facile'&#10;            ],&#10;            [&#10;                'title' =&gt; 'Soleil',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Soleil',&#10;                'category' =&gt; 'Astronomie',&#10;                'difficulty' =&gt; 'facile'&#10;            ],&#10;            [&#10;                'title' =&gt; 'France',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/France',&#10;                'category' =&gt; 'Géographie',&#10;                'difficulty' =&gt; 'facile'&#10;            ],&#10;&#10;            // Moyen&#10;            [&#10;                'title' =&gt; 'Photosynthèse',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Photosynthèse',&#10;                'category' =&gt; 'Biologie',&#10;                'difficulty' =&gt; 'moyen'&#10;            ],&#10;            [&#10;                'title' =&gt; 'Révolution française',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Révolution_française',&#10;                'category' =&gt; 'Histoire',&#10;                'difficulty' =&gt; 'moyen'&#10;            ],&#10;            [&#10;                'title' =&gt; 'Intelligence artificielle',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Intelligence_artificielle',&#10;                'category' =&gt; 'Technologie',&#10;                'difficulty' =&gt; 'moyen'&#10;            ],&#10;            [&#10;                'title' =&gt; 'Océan Atlantique',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Océan_Atlantique',&#10;                'category' =&gt; 'Géographie',&#10;                'difficulty' =&gt; 'moyen'&#10;            ],&#10;            [&#10;                'title' =&gt; 'Mozart',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Wolfgang_Amadeus_Mozart',&#10;                'category' =&gt; 'Musique',&#10;                'difficulty' =&gt; 'moyen'&#10;            ],&#10;&#10;            // Difficile&#10;            [&#10;                'title' =&gt; 'Mécanique quantique',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Mécanique_quantique',&#10;                'category' =&gt; 'Physique',&#10;                'difficulty' =&gt; 'difficile'&#10;            ],&#10;            [&#10;                'title' =&gt; 'Mitochondrie',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Mitochondrie',&#10;                'category' =&gt; 'Biologie',&#10;                'difficulty' =&gt; 'difficile'&#10;            ],&#10;            [&#10;                'title' =&gt; 'Théorie de la relativité',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Théorie_de_la_relativité',&#10;                'category' =&gt; 'Physique',&#10;                'difficulty' =&gt; 'difficile'&#10;            ],&#10;            [&#10;                'title' =&gt; 'Algorithme de Dijkstra',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Algorithme_de_Dijkstra',&#10;                'category' =&gt; 'Informatique',&#10;                'difficulty' =&gt; 'difficile'&#10;            ],&#10;            [&#10;                'title' =&gt; 'Épigénétique',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Épigénétique',&#10;                'category' =&gt; 'Biologie',&#10;                'difficulty' =&gt; 'difficile'&#10;            ],&#10;&#10;            // Articles supplémentaires populaires&#10;            [&#10;                'title' =&gt; 'Leonardo da Vinci',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Léonard_de_Vinci',&#10;                'category' =&gt; 'Art',&#10;                'difficulty' =&gt; 'moyen'&#10;            ],&#10;            [&#10;                'title' =&gt; 'Chocolat',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Chocolat',&#10;                'category' =&gt; 'Alimentation',&#10;                'difficulty' =&gt; 'facile'&#10;            ],&#10;            [&#10;                'title' =&gt; 'Internet',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Internet',&#10;                'category' =&gt; 'Technologie',&#10;                'difficulty' =&gt; 'moyen'&#10;            ],&#10;            [&#10;                'title' =&gt; 'Dinosaure',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Dinosauria',&#10;                'category' =&gt; 'Paléontologie',&#10;                'difficulty' =&gt; 'moyen'&#10;            ],&#10;            [&#10;                'title' =&gt; 'Tour Eiffel',&#10;                'url' =&gt; 'https://fr.wikipedia.org/wiki/Tour_Eiffel',&#10;                'category' =&gt; 'Architecture',&#10;                'difficulty' =&gt; 'facile'&#10;            ]&#10;        ];&#10;&#10;        $count = 0;&#10;        foreach ($articles as $articleData) {&#10;            // Vérifier si l'article existe déjà&#10;            $existing = $this-&gt;entityManager-&gt;getRepository(WikipediaArticle::class)&#10;                -&gt;findOneBy(['title' =&gt; $articleData['title']]);&#10;&#10;            if (!$existing) {&#10;                $article = new WikipediaArticle();&#10;                $article-&gt;setTitle($articleData['title']);&#10;                $article-&gt;setUrl($articleData['url']);&#10;                $article-&gt;setCategory($articleData['category']);&#10;                $article-&gt;setDifficulty($articleData['difficulty']);&#10;                $article-&gt;setActive(true);&#10;&#10;                $this-&gt;entityManager-&gt;persist($article);&#10;                $count++;&#10;&#10;                $io-&gt;writeln(&quot;Ajouté: {$articleData['title']} ({$articleData['difficulty']})&quot;);&#10;            } else {&#10;                $io-&gt;writeln(&quot;Existe déjà: {$articleData['title']}&quot;);&#10;            }&#10;        }&#10;&#10;        $this-&gt;entityManager-&gt;flush();&#10;&#10;        $io-&gt;success(&quot;$count articles Wikipedia ont été ajoutés à la base de données.&quot;);&#10;&#10;        return Command::SUCCESS;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;namespace App\Command;&#10;&#10;use App\Entity\WikipediaArticle;&#10;use Doctrine\ORM\EntityManagerInterface;&#10;use Symfony\Component\Console\Attribute\AsCommand;&#10;use Symfony\Component\Console\Command\Command;&#10;use Symfony\Component\Console\Input\InputInterface;&#10;use Symfony\Component\Console\Output\OutputInterface;&#10;use Symfony\Component\Console\Style\SymfonyStyle;&#10;&#10;#[AsCommand(&#10;    name: 'app:seed-wikipedia-articles',&#10;    description: 'Ajoute des articles Wikipedia par défaut dans la base de données',&#10;)]&#10;class SeedWikipediaArticlesCommand extends Command&#10;{&#10;    public function __construct(&#10;        private EntityManagerInterface $entityManager&#10;    ) {&#10;        parent::__construct();&#10;    }&#10;&#10;    protected function execute(InputInterface $input, OutputInterface $output): int&#10;    {&#10;        $io = new SymfonyStyle($input, $output);&#10;&#10;        // Articles Wikipedia français populaires pour différents niveaux de difficulté (150+ articles)&#10;        $articles = [&#10;            // === NIVEAU FACILE (40 articles) ===&#10;            // Animaux&#10;            ['title' =&gt; 'Chat', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Chat', 'category' =&gt; 'Animaux', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Chien', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Chien', 'category' =&gt; 'Animaux', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Éléphant', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Éléphant', 'category' =&gt; 'Animaux', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Lion', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Lion', 'category' =&gt; 'Animaux', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Oiseau', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Oiseau', 'category' =&gt; 'Animaux', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Poisson', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Poisson', 'category' =&gt; 'Animaux', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Abeille', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Abeille', 'category' =&gt; 'Animaux', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Papillon', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Papillon', 'category' =&gt; 'Animaux', 'difficulty' =&gt; 'facile'],&#10;&#10;            // Géographie &amp; Villes&#10;            ['title' =&gt; 'Paris', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Paris', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'France', 'url' =&gt; 'https://fr.wikipedia.org/wiki/France', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Lyon', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Lyon', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Marseille', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Marseille', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Toulouse', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Toulouse', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Montagne', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Montagne', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Mer', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Mer', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Rivière', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Rivière', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'facile'],&#10;&#10;            // Sciences basiques&#10;            ['title' =&gt; 'Eau', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Eau', 'category' =&gt; 'Science', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Air', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Air', 'category' =&gt; 'Science', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Feu', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Feu', 'category' =&gt; 'Science', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Terre', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Terre', 'category' =&gt; 'Astronomie', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Soleil', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Soleil', 'category' =&gt; 'Astronomie', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Lune', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Lune', 'category' =&gt; 'Astronomie', 'difficulty' =&gt; 'facile'],&#10;&#10;            // Alimentation&#10;            ['title' =&gt; 'Pain', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Pain', 'category' =&gt; 'Alimentation', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Chocolat', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Chocolat', 'category' =&gt; 'Alimentation', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Pomme', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Pomme', 'category' =&gt; 'Alimentation', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Fromage', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Fromage', 'category' =&gt; 'Alimentation', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Vin', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Vin', 'category' =&gt; 'Alimentation', 'difficulty' =&gt; 'facile'],&#10;&#10;            // Culture &amp; Monuments&#10;            ['title' =&gt; 'Tour Eiffel', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Tour_Eiffel', 'category' =&gt; 'Architecture', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Louvre', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Musée_du_Louvre', 'category' =&gt; 'Culture', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Notre-Dame de Paris', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Cathédrale_Notre-Dame_de_Paris', 'category' =&gt; 'Architecture', 'difficulty' =&gt; 'facile'],&#10;&#10;            // Sport&#10;            ['title' =&gt; 'Football', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Football', 'category' =&gt; 'Sport', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Tennis', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Tennis', 'category' =&gt; 'Sport', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Rugby', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Rugby', 'category' =&gt; 'Sport', 'difficulty' =&gt; 'facile'],&#10;&#10;            // Transports&#10;            ['title' =&gt; 'Voiture', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Automobile', 'category' =&gt; 'Transport', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Avion', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Avion', 'category' =&gt; 'Transport', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Train', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Train', 'category' =&gt; 'Transport', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Vélo', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Bicyclette', 'category' =&gt; 'Transport', 'difficulty' =&gt; 'facile'],&#10;&#10;            // Couleurs &amp; Formes&#10;            ['title' =&gt; 'Rouge', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Rouge', 'category' =&gt; 'Couleur', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Bleu', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Bleu', 'category' =&gt; 'Couleur', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Vert', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Vert', 'category' =&gt; 'Couleur', 'difficulty' =&gt; 'facile'],&#10;            ['title' =&gt; 'Jaune', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Jaune', 'category' =&gt; 'Couleur', 'difficulty' =&gt; 'facile'],&#10;&#10;            // === NIVEAU MOYEN (60 articles) ===&#10;            // Histoire&#10;            ['title' =&gt; 'Révolution française', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Révolution_française', 'category' =&gt; 'Histoire', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Napoléon Bonaparte', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Napoléon_Ier', 'category' =&gt; 'Histoire', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Louis XIV', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Louis_XIV', 'category' =&gt; 'Histoire', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Première Guerre mondiale', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Première_Guerre_mondiale', 'category' =&gt; 'Histoire', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Seconde Guerre mondiale', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Seconde_Guerre_mondiale', 'category' =&gt; 'Histoire', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Moyen Âge', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Moyen_Âge', 'category' =&gt; 'Histoire', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Renaissance', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Renaissance', 'category' =&gt; 'Histoire', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Empire romain', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Empire_romain', 'category' =&gt; 'Histoire', 'difficulty' =&gt; 'moyen'],&#10;&#10;            // Sciences &amp; Technologies&#10;            ['title' =&gt; 'Photosynthèse', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Photosynthèse', 'category' =&gt; 'Biologie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Évolution', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Évolution_(biologie)', 'category' =&gt; 'Biologie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'ADN', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Acide_désoxyribonucléique', 'category' =&gt; 'Biologie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Cellule', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Cellule_(biologie)', 'category' =&gt; 'Biologie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Atome', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Atome', 'category' =&gt; 'Chimie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Molécule', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Molécule', 'category' =&gt; 'Chimie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Électricité', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Électricité', 'category' =&gt; 'Physique', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Magnétisme', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Magnétisme', 'category' =&gt; 'Physique', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Gravité', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Gravitation', 'category' =&gt; 'Physique', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Intelligence artificielle', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Intelligence_artificielle', 'category' =&gt; 'Technologie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Internet', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Internet', 'category' =&gt; 'Technologie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Ordinateur', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Ordinateur', 'category' =&gt; 'Technologie', 'difficulty' =&gt; 'moyen'],&#10;&#10;            // Géographie avancée&#10;            ['title' =&gt; 'Océan Atlantique', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Océan_Atlantique', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Océan Pacifique', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Océan_Pacifique', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Himalaya', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Himalaya', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Amazonie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Amazonie', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Sahara', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Sahara', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Antarctique', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Antarctique', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'moyen'],&#10;&#10;            // Arts &amp; Culture&#10;            ['title' =&gt; 'Leonardo da Vinci', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Léonard_de_Vinci', 'category' =&gt; 'Art', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Pablo Picasso', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Pablo_Picasso', 'category' =&gt; 'Art', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Vincent van Gogh', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Vincent_van_Gogh', 'category' =&gt; 'Art', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Mozart', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Wolfgang_Amadeus_Mozart', 'category' =&gt; 'Musique', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Beethoven', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Ludwig_van_Beethoven', 'category' =&gt; 'Musique', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Bach', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Jean-Sébastien_Bach', 'category' =&gt; 'Musique', 'difficulty' =&gt; 'moyen'],&#10;&#10;            // Littérature&#10;            ['title' =&gt; 'Victor Hugo', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Victor_Hugo', 'category' =&gt; 'Littérature', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Molière', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Molière', 'category' =&gt; 'Littérature', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Shakespeare', 'url' =&gt; 'https://fr.wikipedia.org/wiki/William_Shakespeare', 'category' =&gt; 'Littérature', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Voltaire', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Voltaire', 'category' =&gt; 'Littérature', 'difficulty' =&gt; 'moyen'],&#10;&#10;            // Animaux &amp; Nature&#10;            ['title' =&gt; 'Dinosaure', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Dinosauria', 'category' =&gt; 'Paléontologie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Baleine', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Baleine', 'category' =&gt; 'Animaux', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Requin', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Requin', 'category' =&gt; 'Animaux', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Aigle', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Aigle_(oiseau)', 'category' =&gt; 'Animaux', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Forêt', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Forêt', 'category' =&gt; 'Nature', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Désert', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Désert', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'moyen'],&#10;&#10;            // Philosophie &amp; Religion&#10;            ['title' =&gt; 'Philosophie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Philosophie', 'category' =&gt; 'Philosophie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Socrate', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Socrate', 'category' =&gt; 'Philosophie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Platon', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Platon', 'category' =&gt; 'Philosophie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Aristote', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Aristote', 'category' =&gt; 'Philosophie', 'difficulty' =&gt; 'moyen'],&#10;&#10;            // Mathématiques&#10;            ['title' =&gt; 'Mathématiques', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Mathématiques', 'category' =&gt; 'Mathématiques', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Géométrie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Géométrie', 'category' =&gt; 'Mathématiques', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Algèbre', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Algèbre', 'category' =&gt; 'Mathématiques', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Calcul intégral', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Calcul_intégral', 'category' =&gt; 'Mathématiques', 'difficulty' =&gt; 'moyen'],&#10;&#10;            // Médecine&#10;            ['title' =&gt; 'Médecine', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Médecine', 'category' =&gt; 'Médecine', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Antibiotique', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Antibiotique', 'category' =&gt; 'Médecine', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Vaccin', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Vaccin', 'category' =&gt; 'Médecine', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Système immunitaire', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Système_immunitaire', 'category' =&gt; 'Biologie', 'difficulty' =&gt; 'moyen'],&#10;&#10;            // Pays et Capitales&#10;            ['title' =&gt; 'Allemagne', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Allemagne', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Italie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Italie', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Espagne', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Espagne', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Japon', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Japon', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Chine', 'url' =&gt; 'https://fr.wikipedia.org/wiki/République_populaire_de_Chine', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'États-Unis', 'url' =&gt; 'https://fr.wikipedia.org/wiki/États-Unis', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Brésil', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Brésil', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'moyen'],&#10;            ['title' =&gt; 'Inde', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Inde', 'category' =&gt; 'Géographie', 'difficulty' =&gt; 'moyen'],&#10;&#10;            // === NIVEAU DIFFICILE (50+ articles) ===&#10;            // Sciences avancées&#10;            ['title' =&gt; 'Mécanique quantique', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Mécanique_quantique', 'category' =&gt; 'Physique', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Théorie de la relativité', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Théorie_de_la_relativité', 'category' =&gt; 'Physique', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Thermodynamique', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Thermodynamique', 'category' =&gt; 'Physique', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Électromagnétisme', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Électromagnétisme', 'category' =&gt; 'Physique', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Physique des particules', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Physique_des_particules', 'category' =&gt; 'Physique', 'difficulty' =&gt; 'difficile'],&#10;&#10;            // Biologie avancée&#10;            ['title' =&gt; 'Mitochondrie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Mitochondrie', 'category' =&gt; 'Biologie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Épigénétique', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Épigénétique', 'category' =&gt; 'Biologie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Protéine', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Protéine', 'category' =&gt; 'Biochimie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Enzyme', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Enzyme', 'category' =&gt; 'Biochimie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Chromosome', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Chromosome', 'category' =&gt; 'Génétique', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Ribonucléique', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Acide_ribonucléique', 'category' =&gt; 'Biologie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Méiose', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Méiose', 'category' =&gt; 'Biologie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Mitose', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Mitose', 'category' =&gt; 'Biologie', 'difficulty' =&gt; 'difficile'],&#10;&#10;            // Informatique &amp; Technologies&#10;            ['title' =&gt; 'Algorithme de Dijkstra', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Algorithme_de_Dijkstra', 'category' =&gt; 'Informatique', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Apprentissage automatique', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Apprentissage_automatique', 'category' =&gt; 'Informatique', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Cryptographie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Cryptographie', 'category' =&gt; 'Informatique', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Blockchain', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Blockchain', 'category' =&gt; 'Technologie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Réseau de neurones', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Réseau_de_neurones_artificiels', 'category' =&gt; 'Informatique', 'difficulty' =&gt; 'difficile'],&#10;&#10;            // Mathématiques avancées&#10;            ['title' =&gt; 'Topologie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Topologie', 'category' =&gt; 'Mathématiques', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Analyse complexe', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Analyse_complexe', 'category' =&gt; 'Mathématiques', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Théorie des groupes', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Théorie_des_groupes', 'category' =&gt; 'Mathématiques', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Équation différentielle', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Équation_différentielle', 'category' =&gt; 'Mathématiques', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Théorie des nombres', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Théorie_des_nombres', 'category' =&gt; 'Mathématiques', 'difficulty' =&gt; 'difficile'],&#10;&#10;            // Chimie avancée&#10;            ['title' =&gt; 'Chimie organique', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Chimie_organique', 'category' =&gt; 'Chimie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Thermochimie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Thermochimie', 'category' =&gt; 'Chimie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Catalyse', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Catalyse', 'category' =&gt; 'Chimie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Spectroscopie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Spectroscopie', 'category' =&gt; 'Chimie', 'difficulty' =&gt; 'difficile'],&#10;&#10;            // Philosophie avancée&#10;            ['title' =&gt; 'Épistémologie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Épistémologie', 'category' =&gt; 'Philosophie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Métaphysique', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Métaphysique', 'category' =&gt; 'Philosophie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Phénoménologie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Phénoménologie', 'category' =&gt; 'Philosophie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Herméneutique', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Herméneutique', 'category' =&gt; 'Philosophie', 'difficulty' =&gt; 'difficile'],&#10;&#10;            // Médecine spécialisée&#10;            ['title' =&gt; 'Neurologie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Neurologie', 'category' =&gt; 'Médecine', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Oncologie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Oncologie', 'category' =&gt; 'Médecine', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Cardiologie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Cardiologie', 'category' =&gt; 'Médecine', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Immunologie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Immunologie', 'category' =&gt; 'Médecine', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Endocrinologie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Endocrinologie', 'category' =&gt; 'Médecine', 'difficulty' =&gt; 'difficile'],&#10;&#10;            // Économie &amp; Sociologie&#10;            ['title' =&gt; 'Microéconomie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Microéconomie', 'category' =&gt; 'Économie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Macroéconomie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Macroéconomie', 'category' =&gt; 'Économie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Sociologie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Sociologie', 'category' =&gt; 'Sciences sociales', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Anthropologie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Anthropologie', 'category' =&gt; 'Sciences sociales', 'difficulty' =&gt; 'difficile'],&#10;&#10;            // Psychologie&#10;            ['title' =&gt; 'Psychanalyse', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Psychanalyse', 'category' =&gt; 'Psychologie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Neuropsychologie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Neuropsychologie', 'category' =&gt; 'Psychologie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Cognitivisme', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Cognitivisme', 'category' =&gt; 'Psychologie', 'difficulty' =&gt; 'difficile'],&#10;&#10;            // Littérature &amp; Arts avancés&#10;            ['title' =&gt; 'Existentialisme', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Existentialisme', 'category' =&gt; 'Philosophie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Structuralisme', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Structuralisme', 'category' =&gt; 'Littérature', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Déconstructivisme', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Déconstructivisme', 'category' =&gt; 'Architecture', 'difficulty' =&gt; 'difficile'],&#10;&#10;            // Géologie &amp; Géophysique&#10;            ['title' =&gt; 'Tectonique des plaques', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Tectonique_des_plaques', 'category' =&gt; 'Géologie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Sismologie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Sismologie', 'category' =&gt; 'Géophysique', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Volcanologie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Volcanologie', 'category' =&gt; 'Géologie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Minéralogie', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Minéralogie', 'category' =&gt; 'Géologie', 'difficulty' =&gt; 'difficile'],&#10;&#10;            // Astronomie avancée&#10;            ['title' =&gt; 'Trou noir', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Trou_noir', 'category' =&gt; 'Astronomie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Nébuleuse', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Nébuleuse', 'category' =&gt; 'Astronomie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Supernova', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Supernova', 'category' =&gt; 'Astronomie', 'difficulty' =&gt; 'difficile'],&#10;            ['title' =&gt; 'Exoplanète', 'url' =&gt; 'https://fr.wikipedia.org/wiki/Exoplanète', 'category' =&gt; 'Astronomie', 'difficulty' =&gt; 'difficile']&#10;        ];&#10;&#10;        $count = 0;&#10;        foreach ($articles as $articleData) {&#10;            // Vérifier si l'article existe déjà&#10;            $existing = $this-&gt;entityManager-&gt;getRepository(WikipediaArticle::class)&#10;                -&gt;findOneBy(['title' =&gt; $articleData['title']]);&#10;&#10;            if (!$existing) {&#10;                $article = new WikipediaArticle();&#10;                $article-&gt;setTitle($articleData['title']);&#10;                $article-&gt;setUrl($articleData['url']);&#10;                $article-&gt;setCategory($articleData['category']);&#10;                $article-&gt;setDifficulty($articleData['difficulty']);&#10;                $article-&gt;setActive(true);&#10;&#10;                $this-&gt;entityManager-&gt;persist($article);&#10;                $count++;&#10;&#10;                $io-&gt;writeln(&quot;Ajouté: {$articleData['title']} ({$articleData['difficulty']})&quot;);&#10;            } else {&#10;                $io-&gt;writeln(&quot;Existe déjà: {$articleData['title']}&quot;);&#10;            }&#10;        }&#10;&#10;        $this-&gt;entityManager-&gt;flush();&#10;&#10;        $io-&gt;success(&quot;$count articles Wikipedia ont été ajoutés à la base de données.&quot;);&#10;&#10;        return Command::SUCCESS;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Service/PedantixService.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Service/PedantixService.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;namespace App\Service;&#10;&#10;use App\Entity\GameSession;&#10;use App\Entity\Room;&#10;use App\Entity\WikipediaArticle;&#10;use App\Repository\GameSessionRepository;&#10;use App\Repository\RoomRepository;&#10;use App\Repository\WikipediaArticleRepository;&#10;use Doctrine\ORM\EntityManagerInterface;&#10;&#10;class PedantixService&#10;{&#10;    public function __construct(&#10;        private EntityManagerInterface $entityManager,&#10;        private RoomRepository $roomRepository,&#10;        private GameSessionRepository $gameSessionRepository,&#10;        private WikipediaArticleRepository $wikipediaArticleRepository&#10;    ) {}&#10;&#10;    public function createRoom(string $wikipediaUrl, string $gameMode = 'competition'): Room&#10;    {&#10;        $articleData = $this-&gt;fetchWikipediaArticle($wikipediaUrl);&#10;&#10;        $room = new Room();&#10;        $room-&gt;setTitle($articleData['title']);&#10;        $room-&gt;setContent($articleData['content']);&#10;        $room-&gt;setUrl($wikipediaUrl);&#10;        $room-&gt;setWordsToFind($articleData['allWords']);&#10;        $room-&gt;setHints([]); // Pas d'indices dans le vrai Pedantix&#10;        $room-&gt;setGameMode($gameMode);&#10;&#10;        $this-&gt;roomRepository-&gt;save($room, true);&#10;&#10;        return $room;&#10;    }&#10;&#10;    public function joinRoom(string $roomCode, string $playerName, string $ipAddress): ?GameSession&#10;    {&#10;        $room = $this-&gt;roomRepository-&gt;findByCode($roomCode);&#10;        if (!$room) {&#10;            return null;&#10;        }&#10;&#10;        // Chercher une session existante pour ce joueur&#10;        $existingSession = $this-&gt;gameSessionRepository-&gt;findByRoomAndPlayer($room, $playerName, $ipAddress);&#10;&#10;        if ($existingSession) {&#10;            $existingSession-&gt;updateActivity();&#10;            $this-&gt;gameSessionRepository-&gt;save($existingSession, true);&#10;            return $existingSession;&#10;        }&#10;&#10;        // Créer une nouvelle session&#10;        $gameSession = new GameSession();&#10;        $gameSession-&gt;setRoom($room);&#10;        $gameSession-&gt;setPlayerName($playerName);&#10;        $gameSession-&gt;setIpAddress($ipAddress);&#10;&#10;        $this-&gt;gameSessionRepository-&gt;save($gameSession, true);&#10;&#10;        return $gameSession;&#10;    }&#10;&#10;    public function submitGuess(GameSession $gameSession, string $guess): array&#10;    {&#10;        $guess = trim($guess);&#10;        $room = $gameSession-&gt;getRoom();&#10;        $content = $room-&gt;getContent();&#10;&#10;        // Vérifier si le mot a déjà été essayé par ce joueur&#10;        $normalizedGuess = $this-&gt;normalizeWord($guess);&#10;        $foundWordsNormalized = array_map([$this, 'normalizeWord'], $gameSession-&gt;getFoundWords());&#10;&#10;        if (in_array($normalizedGuess, $foundWordsNormalized)) {&#10;            return [&#10;                'found' =&gt; false,&#10;                'word' =&gt; $guess,&#10;                'proximity' =&gt; null,&#10;                'gameCompleted' =&gt; false,&#10;                'isExactMatch' =&gt; false,&#10;                'error' =&gt; 'Mot déjà trouvé',&#10;                'duplicate' =&gt; true&#10;            ];&#10;        }&#10;&#10;        $gameSession-&gt;incrementAttempts();&#10;        $gameSession-&gt;updateActivity();&#10;&#10;        $result = [&#10;            'found' =&gt; false,&#10;            'word' =&gt; $guess,&#10;            'proximity' =&gt; null,&#10;            'gameCompleted' =&gt; false,&#10;            'isExactMatch' =&gt; false,&#10;            'duplicate' =&gt; false&#10;        ];&#10;&#10;        // Extraire tous les mots significatifs du titre&#10;        $titleWords = $this-&gt;extractTitleWords($room-&gt;getTitle());&#10;        $titleWordsNormalized = array_map([$this, 'normalizeWord'], $titleWords);&#10;&#10;        // Vérifier si le mot deviné correspond à un des mots du titre&#10;        $isTitleWord = false;&#10;        foreach ($titleWordsNormalized as $titleWord) {&#10;            if ($titleWord === $normalizedGuess) {&#10;                $isTitleWord = true;&#10;                break;&#10;            }&#10;        }&#10;&#10;        if ($isTitleWord) {&#10;            $result['found'] = true;&#10;            $result['isExactMatch'] = true;&#10;            $gameSession-&gt;addFoundWord($guess);&#10;&#10;            // En mode coopératif, ajouter le mot à la liste globale de la salle&#10;            if ($room-&gt;isCooperativeMode()) {&#10;                $room-&gt;addGlobalFoundWord($guess);&#10;                $this-&gt;roomRepository-&gt;save($room, true);&#10;            }&#10;&#10;            // Vérifier si TOUS les mots du titre ont été trouvés&#10;            $allTitleWordsFound = $this-&gt;checkAllTitleWordsFound($gameSession, $room, $titleWordsNormalized);&#10;&#10;            if ($allTitleWordsFound) {&#10;                $result['gameCompleted'] = true;&#10;                $gameSession-&gt;setCompleted(true);&#10;&#10;                // En mode coopération, marquer le jeu comme terminé pour tous&#10;                if ($room-&gt;isCooperativeMode()) {&#10;                    $room-&gt;setIsGameCompleted(true);&#10;                    $room-&gt;setCompletedAt(new \DateTimeImmutable());&#10;&#10;                    // En coopération, tous les joueurs actifs deviennent &quot;gagnants&quot;&#10;                    $this-&gt;markAllPlayersAsWinners($room);&#10;                    $this-&gt;roomRepository-&gt;save($room, true);&#10;                }&#10;&#10;                // Score final basé sur le nombre de tentatives (moins = mieux)&#10;                $finalScore = max(1000 - ($gameSession-&gt;getAttempts() * 10), 100);&#10;                $gameSession-&gt;setScore($finalScore);&#10;            }&#10;&#10;            $this-&gt;gameSessionRepository-&gt;save($gameSession, true);&#10;            return $result;&#10;        }&#10;&#10;        // Vérifier si le mot existe dans l'article (mais n'est pas un mot du titre)&#10;        if ($this-&gt;wordExistsInArticle($guess, $content)) {&#10;            $result['found'] = true;&#10;            $gameSession-&gt;addFoundWord($guess);&#10;&#10;            // En mode coopératif, ajouter le mot à la liste globale de la salle&#10;            if ($room-&gt;isCooperativeMode()) {&#10;                $room-&gt;addGlobalFoundWord($guess);&#10;                $this-&gt;roomRepository-&gt;save($room, true);&#10;            }&#10;&#10;            // Ajouter des points pour chaque mot trouvé (seulement si pas déjà trouvé)&#10;            $currentScore = $gameSession-&gt;getScore() + 10;&#10;            $gameSession-&gt;setScore($currentScore);&#10;        } else {&#10;            // Calculer la proximité sémantique avec les mots de l'article&#10;            $result['proximity'] = $this-&gt;calculateSemanticProximity($guess, $content, $room-&gt;getTitle());&#10;        }&#10;&#10;        $this-&gt;gameSessionRepository-&gt;save($gameSession, true);&#10;        return $result;&#10;    }&#10;&#10;    /**&#10;     * Vérifie si tous les mots du titre ont été trouvés par le joueur&#10;     */&#10;    private function checkAllTitleWordsFound(GameSession $gameSession, Room $room, array $titleWordsNormalized): bool&#10;    {&#10;        // En mode coopération, vérifier les mots trouvés globalement&#10;        if ($room-&gt;isCooperativeMode()) {&#10;            $allFoundWords = array_unique(array_merge($gameSession-&gt;getFoundWords(), $room-&gt;getGlobalFoundWords()));&#10;        } else {&#10;            $allFoundWords = $gameSession-&gt;getFoundWords();&#10;        }&#10;&#10;        $foundWordsNormalized = array_map([$this, 'normalizeWord'], $allFoundWords);&#10;&#10;        // Vérifier que chaque mot du titre a été trouvé&#10;        foreach ($titleWordsNormalized as $titleWord) {&#10;            $found = false;&#10;            foreach ($foundWordsNormalized as $foundWord) {&#10;                if ($foundWord === $titleWord) {&#10;                    $found = true;&#10;                    break;&#10;                }&#10;            }&#10;            if (!$found) {&#10;                return false; // Il manque encore au moins un mot&#10;            }&#10;        }&#10;&#10;        return true; // Tous les mots du titre ont été trouvés&#10;    }&#10;&#10;    public function getProcessedContent(Room $room, array $foundWords, array $proximityData = [], bool $gameCompleted = false): string&#10;    {&#10;        $content = $room-&gt;getContent();&#10;&#10;        // En mode coopératif, combiner les mots trouvés par le joueur avec ceux trouvés globalement&#10;        if ($room-&gt;isCooperativeMode()) {&#10;            $allFoundWords = array_unique(array_merge($foundWords, $room-&gt;getGlobalFoundWords()));&#10;        } else {&#10;            $allFoundWords = $foundWords;&#10;        }&#10;&#10;        $foundWordsNormalized = array_map([$this, 'normalizeWord'], $allFoundWords);&#10;&#10;        // Si le jeu est terminé, révéler tous les mots normalement (pas en jaune)&#10;        if ($gameCompleted) {&#10;            // Diviser le contenu en mots tout en préservant la ponctuation et la structure&#10;            $words = preg_split('/(\s+|[.,;:!?()&quot;\'-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;            $processedWords = [];&#10;            foreach ($words as $word) {&#10;                if (trim($word) === '' || preg_match('/^\s*$/', $word) || preg_match('/^[.,;:!?()&quot;\'-]+$/', $word)) {&#10;                    // Espaces et ponctuation - garder tel quel&#10;                    $processedWords[] = $word;&#10;                } else {&#10;                    // Tous les mots sont révélés avec un style normal (plus de jaune)&#10;                    $processedWords[] = '&lt;span class=&quot;revealed-word-victory&quot;&gt;' . htmlspecialchars($word) . '&lt;/span&gt;';&#10;                }&#10;            }&#10;&#10;            return implode('', $processedWords);&#10;        }&#10;&#10;        // Créer un mapping des mots de l'article vers les mots devinés les plus proches&#10;        $wordProximityMapping = $this-&gt;buildWordProximityMapping($content, $proximityData);&#10;&#10;        // Créer un mapping des proximités sémantiques pour les mots trouvés&#10;        $semanticProximityMapping = $this-&gt;buildSemanticProximityMapping($content, $allFoundWords);&#10;&#10;        // Comportement normal : diviser le contenu en mots tout en préservant la ponctuation et la structure&#10;        $words = preg_split('/(\s+|[.,;:!?()&quot;\'-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;        $processedWords = [];&#10;        foreach ($words as $word) {&#10;            if (trim($word) === '' || preg_match('/^\s*$/', $word) || preg_match('/^[.,;:!?()&quot;\'-]+$/', $word)) {&#10;                // Espaces et ponctuation - garder tel quel&#10;                $processedWords[] = $word;&#10;            } else {&#10;                // C'est un mot - vérifier s'il doit être dévoilé&#10;                $normalizedWord = $this-&gt;normalizeWord($word);&#10;                $isRevealed = $this-&gt;isWordRevealed($word, $foundWordsNormalized);&#10;&#10;                if ($isRevealed) {&#10;                    // Mot trouvé : affichage en texte noir normal sans arrière-plan&#10;                    $processedWords[] = '&lt;span class=&quot;revealed-word&quot;&gt;' . htmlspecialchars($word) . '&lt;/span&gt;';&#10;                } else {&#10;                    // Vérifier si ce mot a une proximité sémantique avec un mot trouvé&#10;                    if (isset($semanticProximityMapping[$normalizedWord])) {&#10;                        $semanticInfo = $semanticProximityMapping[$normalizedWord];&#10;                        $foundWord = $semanticInfo['found_word'];&#10;                        $proximityScore = $semanticInfo['proximity'];&#10;                        $colorStyle = $this-&gt;getProximityColorStyle($proximityScore);&#10;&#10;                        // Afficher le mot trouvé avec la couleur de proximité sémantique&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word-with-proximity&quot; style=&quot;' . $colorStyle . '&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot; data-found=&quot;' . htmlspecialchars($foundWord) . '&quot; data-proximity=&quot;' . $proximityScore . '&quot;&gt;' . htmlspecialchars($foundWord) . '&lt;/span&gt;';&#10;                    } else if (isset($wordProximityMapping[$normalizedWord])) {&#10;                        // Vérifier la proximité avec les mots devinés mais non trouvés&#10;                        $proximityInfo = $wordProximityMapping[$normalizedWord];&#10;                        $guessedWord = $proximityInfo['guessed_word'];&#10;                        $proximityScore = $proximityInfo['proximity'];&#10;                        $colorStyle = $this-&gt;getProximityColorStyle($proximityScore);&#10;&#10;                        // Afficher le mot deviné avec la couleur de proximité&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word-with-proximity&quot; style=&quot;' . $colorStyle . '&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot; data-guessed=&quot;' . htmlspecialchars($guessedWord) . '&quot; data-proximity=&quot;' . $proximityScore . '&quot;&gt;' . htmlspecialchars($guessedWord) . '&lt;/span&gt;';&#10;                    } else {&#10;                        // Mot complètement caché&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot;&gt;' . str_repeat('█', mb_strlen($word)) . '&lt;/span&gt;';&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return implode('', $processedWords);&#10;    }&#10;&#10;    /**&#10;     * Vérifie si un mot de l'article doit être révélé basé sur les mots trouvés par le joueur&#10;     * Prend en compte les conjugaisons et variations&#10;     */&#10;    private function isWordRevealed(string $articleWord, array $foundWordsNormalized): bool&#10;    {&#10;        $normalizedArticleWord = $this-&gt;normalizeWord($articleWord);&#10;&#10;        // Vérification directe&#10;        if (in_array($normalizedArticleWord, $foundWordsNormalized)) {&#10;            return true;&#10;        }&#10;&#10;        // Vérifier si le mot de l'article est une conjugaison d'un des mots trouvés&#10;        foreach ($foundWordsNormalized as $foundWord) {&#10;            if ($this-&gt;isVerbConjugation($foundWord, $normalizedArticleWord)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        // Vérifier les contractions avec apostrophes&#10;        if (strpos($articleWord, &quot;'&quot;) !== false) {&#10;            $parts = explode(&quot;'&quot;, $articleWord);&#10;            foreach ($parts as $part) {&#10;                $normalizedPart = $this-&gt;normalizeWord($part);&#10;                if (in_array($normalizedPart, $foundWordsNormalized)) {&#10;                    return true;&#10;                }&#10;                // Vérifier les conjugaisons pour chaque partie&#10;                foreach ($foundWordsNormalized as $foundWord) {&#10;                    if ($this-&gt;isVerbConjugation($foundWord, $normalizedPart)) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    public function getLeaderboard(Room $room): array&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;getLeaderboard($room);&#10;    }&#10;&#10;    public function getActivePlayers(Room $room): array&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;findActiveSessionsForRoom($room);&#10;    }&#10;&#10;    public function getRoomByCode(string $code): ?Room&#10;    {&#10;        return $this-&gt;roomRepository-&gt;findByCode($code);&#10;    }&#10;&#10;    public function getGameSession(int $sessionId): ?GameSession&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;find($sessionId);&#10;    }&#10;&#10;    private function fetchWikipediaArticle(string $url): array&#10;    {&#10;        $title = $this-&gt;extractTitleFromUrl($url);&#10;&#10;        // Utiliser l'API de résumé de Wikipedia qui donne directement l'introduction&#10;        $summaryApiUrl = &quot;https://fr.wikipedia.org/api/rest_v1/page/summary/&quot; . urlencode($title);&#10;&#10;        $context = stream_context_create([&#10;            'http' =&gt; [&#10;                'header' =&gt; &quot;User-Agent: PedantixApp/1.0\r\n&quot;,&#10;                'timeout' =&gt; 30,&#10;                'ignore_errors' =&gt; true&#10;            ]&#10;        ]);&#10;&#10;        try {&#10;            $summaryResponse = file_get_contents($summaryApiUrl, false, $context);&#10;&#10;            if ($summaryResponse === false) {&#10;                $error = error_get_last();&#10;                throw new \Exception('Impossible de r��cupérer l\'article Wikipedia: ' . ($error['message'] ?? 'Erreur de connexion'));&#10;            }&#10;&#10;            $summaryData = json_decode($summaryResponse, true);&#10;&#10;            if (!$summaryData) {&#10;                throw new \Exception('Réponse invalide de l\'API Wikipedia');&#10;            }&#10;&#10;            if (isset($summaryData['type']) &amp;&amp; $summaryData['type'] === 'disambiguation') {&#10;                throw new \Exception('Cette page est une page de désambiguïsation. Veuillez choisir un article plus spécifique.');&#10;            }&#10;&#10;            if (!isset($summaryData['extract']) || empty($summaryData['extract'])) {&#10;                throw new \Exception('Contenu de l\'article introuvable ou vide');&#10;            }&#10;&#10;            // L'extract contient déjà un résumé propre de l'article&#10;            $content = $summaryData['extract'];&#10;&#10;            // Nettoyer un peu plus le contenu pour enlever les références restantes&#10;            $content = preg_replace('/\[[\d,\s]+\]/', '', $content); // Supprimer les références [1], [2,3], etc.&#10;            $content = preg_replace('/\s+/', ' ', $content); // Normaliser les espaces&#10;            $content = trim($content);&#10;&#10;            if (strlen($content) &lt; 50) {&#10;                throw new \Exception('L\'article est trop court pour créer une partie intéressante');&#10;            }&#10;&#10;            $properTitle = $summaryData['title'] ?? $title;&#10;&#10;            return [&#10;                'title' =&gt; $properTitle,&#10;                'content' =&gt; $content,&#10;                'allWords' =&gt; $this-&gt;extractAllWords($content)&#10;            ];&#10;        } catch (\Exception $e) {&#10;            // Log l'erreur pour debugging&#10;            error_log('Erreur fetchWikipediaArticle: ' . $e-&gt;getMessage() . ' pour URL: ' . $url);&#10;            throw $e;&#10;        }&#10;    }&#10;&#10;    private function cleanWikipediaContent(string $html): string&#10;    {&#10;        // Supprimer les balises non désirées&#10;        $html = preg_replace('/&lt;script.*?&lt;\/script&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;style.*?&lt;\/style&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;figure.*?&lt;\/figure&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;table.*?&lt;\/table&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*infobox[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;&#10;        // Supprimer TOUTES les boîtes d'aide, navigation et métadonnées&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*dablink[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*hatnote[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*disambig[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*navigation[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*navbox[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*metadata[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;&#10;        // Approche plus simple et plus stricte : extraire seulement les 2-3 premiers vrais paragraphes&#10;        preg_match_all('/&lt;p[^&gt;]*&gt;(.*?)&lt;\/p&gt;/is', $html, $matches);&#10;        $allParagraphs = $matches[1];&#10;&#10;        $introContent = [];&#10;        $paragraphCount = 0;&#10;&#10;        foreach ($allParagraphs as $paragraph) {&#10;            $cleaned = strip_tags($paragraph);&#10;            $cleaned = html_entity_decode($cleaned, ENT_QUOTES, 'UTF-8');&#10;            $cleaned = preg_replace('/\s+/', ' ', $cleaned);&#10;            $cleaned = trim($cleaned);&#10;&#10;            // Filtres très stricts pour ne garder que l'introduction&#10;            if (!empty($cleaned) &amp;&amp;&#10;                strlen($cleaned) &gt; 30 &amp;&amp; // Paragraphes substantiels seulement&#10;                !preg_match('/^(Pour les articles|Page d\'aide|Ne doit pas être confondu|Cet article|voir|redirigé|coordination|modifier|wikidata)/i', $cleaned) &amp;&amp;&#10;                !preg_match('/(homonymie|homonymes|voir aussi|articles connexes|catégorie|portail)/i', $cleaned) &amp;&amp;&#10;                !preg_match('/^\s*(modifier|edit|\[|\()/i', $cleaned)) {&#10;&#10;                $introContent[] = $cleaned;&#10;                $paragraphCount++;&#10;&#10;                // LIMITER STRICTEMENT à 2-3 paragraphes d'introduction maximum&#10;                if ($paragraphCount &gt;= 2) {&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;        // S'assurer qu'on a au moins quelque chose de substantiel&#10;        if (empty($introContent)) {&#10;            return &quot;L'eau est un composé chimique ubiquitaire sur la Terre, essentiel pour tous les organismes vivants connus.&quot;;&#10;        }&#10;&#10;        return implode(&quot;\n\n&quot;, $introContent);&#10;    }&#10;&#10;    private function getElementPosition(\DOMNode $element): int&#10;    {&#10;        $position = 0;&#10;        $current = $element;&#10;&#10;        while ($current-&gt;previousSibling !== null) {&#10;            $current = $current-&gt;previousSibling;&#10;            $position++;&#10;        }&#10;&#10;        // Ajouter la position des parents&#10;        if ($current-&gt;parentNode !== null &amp;&amp; $current-&gt;parentNode-&gt;nodeName !== '#document') {&#10;            $position += $this-&gt;getElementPosition($current-&gt;parentNode) * 1000;&#10;        }&#10;&#10;        return $position;&#10;    }&#10;&#10;    private function extractTitleFromUrl(string $url): string&#10;    {&#10;        $path = parse_url($url, PHP_URL_PATH);&#10;        $title = basename($path);&#10;        return urldecode($title);&#10;    }&#10;&#10;    private function extractAllWords(string $content): array&#10;    {&#10;        $words = preg_split('/\s+/', $content);&#10;        $cleanWords = [];&#10;&#10;        foreach ($words as $word) {&#10;            $cleaned = $this-&gt;normalizeWord($word);&#10;            if (strlen($cleaned) &gt;= 2 &amp;&amp; !in_array($cleaned, $this-&gt;getStopWords())) {&#10;                $cleanWords[] = $cleaned;&#10;            }&#10;        }&#10;&#10;        return array_unique($cleanWords);&#10;    }&#10;&#10;    private function extractAllWordsFromContent(string $content): array&#10;    {&#10;        // Extraire tous les mots du contenu en préservant la structure&#10;        $words = preg_split('/(\s+|[.,;:!?()&quot;\-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;        $cleanWords = [];&#10;&#10;        foreach ($words as $word) {&#10;            $cleanWord = trim($word);&#10;            if (empty($cleanWord) || preg_match('/^[.,;:!?()&quot;\'\\-\\s]+$/', $cleanWord)) {&#10;                continue;&#10;            }&#10;&#10;            // Traitement spécial pour les mots avec apostrophes&#10;            if (strpos($cleanWord, &quot;'&quot;) !== false) {&#10;                $parts = explode(&quot;'&quot;, $cleanWord);&#10;                foreach ($parts as $part) {&#10;                    $part = trim($part);&#10;                    if (!empty($part) &amp;&amp; strlen($part) &gt;= 2) {&#10;                        $cleanWords[] = $part;&#10;                    }&#10;                }&#10;            } else {&#10;                if (strlen($cleanWord) &gt;= 2) {&#10;                    $cleanWords[] = $cleanWord;&#10;                }&#10;            }&#10;        }&#10;&#10;        return $cleanWords;&#10;    }&#10;&#10;    private function extractTitleWords(string $title): array&#10;    {&#10;        // Extraire tous les mots significatifs du titre&#10;        $words = preg_split('/\s+/', $title);&#10;        $titleWords = [];&#10;&#10;        foreach ($words as $word) {&#10;            $cleaned = $this-&gt;normalizeWord($word);&#10;            if (strlen($cleaned) &gt;= 2) {&#10;                $titleWords[] = $word; // Garder le mot original, pas normalisé&#10;            }&#10;        }&#10;&#10;        return $titleWords;&#10;    }&#10;&#10;    private function normalizeWord(string $word): string&#10;    {&#10;        // Enlever la ponctuation et normaliser&#10;        $word = preg_replace('/[^\p{L}\p{N}]/u', '', $word);&#10;        $word = mb_strtolower($word, 'UTF-8');&#10;&#10;        // Enlever les accents pour la comparaison&#10;        $word = iconv('UTF-8', 'ASCII//TRANSLIT//IGNORE', $word);&#10;        $word = preg_replace('/[^a-z0-9]/', '', $word);&#10;&#10;        return $word;&#10;    }&#10;&#10;    private function wordExistsInArticle(string $guess, string $content): bool&#10;    {&#10;        $normalizedGuess = $this-&gt;normalizeWord($guess);&#10;&#10;        // Cas spécial pour les contractions comme &quot;l'&quot;&#10;        if (strlen($guess) == 1 &amp;&amp; in_array(strtolower($guess), ['l', 'd', 'j', 'n', 'm', 'c', 's', 't'])) {&#10;            // Rechercher des patterns comme &quot;l'eau&quot;, &quot;d'eau&quot;, etc.&#10;            $pattern = '/\b' . preg_quote(strtolower($guess)) . '\'/i';&#10;            if (preg_match($pattern, $content)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        // Diviser le contenu en mots en préservant les apostrophes&#10;        $words = preg_split('/(\s+|[.,;:!?()&quot;\-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;        foreach ($words as $word) {&#10;            $cleanWord = trim($word);&#10;            if (empty($cleanWord)) continue;&#10;&#10;            // Traitement spécial pour les mots avec apostrophes&#10;            if (strpos($cleanWord, &quot;'&quot;) !== false) {&#10;                $parts = explode(&quot;'&quot;, $cleanWord);&#10;                foreach ($parts as $part) {&#10;                    if ($this-&gt;normalizeWord($part) === $normalizedGuess) {&#10;                        return true;&#10;                    }&#10;                    // Vérifier les conjugaisons pour les parties de mots avec apostrophe&#10;                    if ($this-&gt;isVerbConjugation($normalizedGuess, $this-&gt;normalizeWord($part))) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;&#10;            $normalizedWord = $this-&gt;normalizeWord($cleanWord);&#10;            if ($normalizedWord === $normalizedGuess) {&#10;                return true;&#10;            }&#10;&#10;            // Vérifier si le mot deviné est un infinitif et le mot de l'article une conjugaison&#10;            if ($this-&gt;isVerbConjugation($normalizedGuess, $normalizedWord)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Vérifie si un mot est une conjugaison d'un verbe à l'infinitif&#10;     */&#10;    private function isVerbConjugation(string $infinitive, string $word): bool&#10;    {&#10;        // Patterns de conjugaison française simplifiés&#10;        $conjugationPatterns = $this-&gt;getConjugationPatterns();&#10;&#10;        foreach ($conjugationPatterns as $ending =&gt; $replacements) {&#10;            if (str_ends_with($infinitive, $ending)) {&#10;                $stem = substr($infinitive, 0, -strlen($ending));&#10;&#10;                foreach ($replacements as $replacement) {&#10;                    $conjugated = $stem . $replacement;&#10;                    if ($conjugated === $word) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Vérifier aussi les verbes irréguliers les plus courants&#10;        $irregularVerbs = $this-&gt;getIrregularVerbs();&#10;        if (isset($irregularVerbs[$infinitive])) {&#10;            return in_array($word, $irregularVerbs[$infinitive]);&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Patterns de conjugaison pour les verbes réguliers&#10;     */&#10;    private function getConjugationPatterns(): array&#10;    {&#10;        return [&#10;            'er' =&gt; [&#10;                'e', 'es', 'e', 'ons', 'ez', 'ent', // présent&#10;                'ais', 'ais', 'ait', 'ions', 'iez', 'aient', // imparfait&#10;                'ai', 'as', 'a', 'ames', 'ates', 'erent', // passé simple&#10;                'erai', 'eras', 'era', 'erons', 'erez', 'eront', // futur&#10;                'erais', 'erais', 'erait', 'erions', 'eriez', 'eraient', // conditionnel&#10;                'ant', 'e', // participes&#10;            ],&#10;            'ir' =&gt; [&#10;                'is', 'is', 'it', 'issons', 'issez', 'issent', // présent&#10;                'issais', 'issais', 'issait', 'issions', 'issiez', 'issaient', // imparfait&#10;                'is', 'is', 'it', 'imes', 'ites', 'irent', // passé simple&#10;                'irai', 'iras', 'ira', 'irons', 'irez', 'iront', // futur&#10;                'irais', 'irais', 'irait', 'irions', 'iriez', 'iraient', // conditionnel&#10;                'issant', 'i', // participes&#10;            ],&#10;            're' =&gt; [&#10;                's', 's', '', 'ons', 'ez', 'ent', // présent&#10;                'ais', 'ais', 'ait', 'ions', 'iez', 'aient', // imparfait&#10;                'is', 'is', 'it', 'imes', 'ites', 'irent', // passé simple&#10;                'rai', 'ras', 'ra', 'rons', 'rez', 'ront', // futur&#10;                'rais', 'rais', 'rait', 'rions', 'riez', 'raient', // conditionnel&#10;                'ant', 'u', // participes&#10;            ]&#10;        ];&#10;    }&#10;&#10;    /**&#10;     * Verbes irréguliers les plus courants&#10;     */&#10;    private function getIrregularVerbs(): array&#10;    {&#10;        return [&#10;            'etre' =&gt; ['suis', 'es', 'est', 'sommes', 'etes', 'sont', 'etais', 'etait', 'etions', 'etiez', 'etaient', 'fus', 'fut', 'fumes', 'furent', 'serai', 'seras', 'sera', 'serons', 'serez', 'seront', 'serais', 'serait', 'serions', 'seriez', 'seraient', 'etant', 'ete'],&#10;            'avoir' =&gt; ['ai', 'as', 'a', 'avons', 'avez', 'ont', 'avais', 'avait', 'avions', 'aviez', 'avaient', 'eus', 'eut', 'eumes', 'eurent', 'aurai', 'auras', 'aura', 'aurons', 'aurez', 'auront', 'aurais', 'aurait', 'aurions', 'auriez', 'auraient', 'ayant', 'eu'],&#10;            'aller' =&gt; ['vais', 'vas', 'va', 'allons', 'allez', 'vont', 'allais', 'allait', 'allions', 'alliez', 'allaient', 'allai', 'alla', 'allames', 'allerent', 'irai', 'iras', 'ira', 'irons', 'irez', 'iront', 'irais', 'irait', 'irions', 'iriez', 'iraient', 'allant', 'alle'],&#10;            'faire' =&gt; ['fais', 'fait', 'faisons', 'faites', 'font', 'faisais', 'faisait', 'faisions', 'faisiez', 'faisaient', 'fis', 'fit', 'fimes', 'firent', 'ferai', 'feras', 'fera', 'ferons', 'ferez', 'feront', 'ferais', 'ferait', 'ferions', 'feriez', 'feraient', 'faisant', 'fait'],&#10;            'dire' =&gt; ['dis', 'dit', 'disons', 'dites', 'disent', 'disais', 'disait', 'disions', 'disiez', 'disaient', 'dis', 'dit', 'dimes', 'dirent', 'dirai', 'diras', 'dira', 'dirons', 'direz', 'diront', 'dirais', 'dirait', 'dirions', 'diriez', 'diraient', 'disant', 'dit'],&#10;            'voir' =&gt; ['vois', 'voit', 'voyons', 'voyez', 'voient', 'voyais', 'voyait', 'voyions', 'voyiez', 'voyaient', 'vis', 'vit', 'vimes', 'virent', 'verrai', 'verras', 'verra', 'verrons', 'verrez', 'verront', 'verrais', 'verrait', 'verrions', 'verriez', 'verraient', 'voyant', 'vu'],&#10;            'savoir' =&gt; ['sais', 'sait', 'savons', 'savez', 'savent', 'savais', 'savait', 'savions', 'saviez', 'savaient', 'sus', 'sut', 'sumes', 'surent', 'saurai', 'sauras', 'saura', 'saurons', 'saurez', 'sauront', 'saurais', 'saurait', 'saurions', 'sauriez', 'sauraient', 'sachant', 'su'],&#10;            'pouvoir' =&gt; ['peux', 'peut', 'pouvons', 'pouvez', 'peuvent', 'pouvais', 'pouvait', 'pouvions', 'pouviez', 'pouvaient', 'pus', 'put', 'pumes', 'purent', 'pourrai', 'pourras', 'pourra', 'pourrons', 'pourrez', 'pourront', 'pourrais', 'pourrait', 'pourrions', 'pourriez', 'pourraient', 'pouvant', 'pu'],&#10;            'vouloir' =&gt; ['veux', 'veut', 'voulons', 'voulez', 'veulent', 'voulais', 'voulait', 'voulions', 'vouliez', 'voulaient', 'voulus', 'voulut', 'voulumes', 'voulurent', 'voudrai', 'voudras', 'voudra', 'voudrons', 'voudrez', 'voudront', 'voudrais', 'voudrait', 'voudrions', 'voudriez', 'voudraient', 'voulant', 'voulu'],&#10;            'venir' =&gt; ['viens', 'vient', 'venons', 'venez', 'viennent', 'venais', 'venait', 'venions', 'veniez', 'venaient', 'vins', 'vint', 'vinmes', 'vinrent', 'viendrai', 'viendras', 'viendra', 'viendrons', 'viendrez', 'viendront', 'viendrais', 'viendrait', 'viendrions', 'viendriez', 'viendraient', 'venant', 'venu'],&#10;            'partir' =&gt; ['pars', 'part', 'partons', 'partez', 'partent', 'partais', 'partait', 'partions', 'partiez', 'partaient', 'partis', 'partit', 'partimes', 'partirent', 'partirai', 'partiras', 'partira', 'partirons', 'partirez', 'partiront', 'partirais', 'partirait', 'partirions', 'partiriez', 'partiraient', 'partant', 'parti'],&#10;        ];&#10;    }&#10;&#10;    private function calculateSemanticProximity(string $guess, string $content, string $title): int&#10;    {&#10;        $normalizedGuess = $this-&gt;normalizeWord($guess);&#10;        $titleWords = array_map([$this, 'normalizeWord'], $this-&gt;extractTitleWords($title));&#10;&#10;        // Extraire TOUS les mots de l'article, pas seulement le titre&#10;        $allContentWords = $this-&gt;extractAllWordsFromContent($content);&#10;        $contentWords = array_map([$this, 'normalizeWord'], $allContentWords);&#10;&#10;        $maxProximity = 0;&#10;&#10;        // Vérifier la proximité avec les mots du titre (proximité maximale)&#10;        foreach ($titleWords as $titleWord) {&#10;            $similarity = $this-&gt;calculateLevenshteinSimilarity($normalizedGuess, $titleWord);&#10;            if ($similarity &gt; 0.7) {&#10;                $maxProximity = max($maxProximity, 950 + ($similarity * 50));&#10;            }&#10;        }&#10;&#10;        // Vérifier si le mot deviné est un nombre ou une date&#10;        $isGuessNumber = $this-&gt;isNumber($guess);&#10;        $isGuessDate = $this-&gt;isDate($guess);&#10;&#10;        // Si le mot deviné est un nombre ou une date, vérifier la proximité avec les nombres/dates de l'article&#10;        if ($isGuessNumber || $isGuessDate) {&#10;            $numbersAndDatesProximity = $this-&gt;calculateNumbersAndDatesProximity($guess, $content, $isGuessNumber, $isGuessDate);&#10;            $maxProximity = max($maxProximity, $numbersAndDatesProximity);&#10;        }&#10;&#10;        // Nouveau système de proximité sémantique avancé&#10;        foreach ($allContentWords as $contentWord) {&#10;            $normalizedContentWord = $this-&gt;normalizeWord($contentWord);&#10;            if (strlen($normalizedContentWord) &gt;= 2 &amp;&amp; !in_array($normalizedContentWord, $this-&gt;getStopWords())) {&#10;&#10;                // 1. Vérifier la similarité sémantique directe&#10;                $semanticScore = $this-&gt;calculateSemanticSimilarity($normalizedContentWord, $normalizedGuess);&#10;                if ($semanticScore &gt; 0) {&#10;                    $maxProximity = max($maxProximity, $semanticScore);&#10;                }&#10;&#10;                // 2. Vérifier la distance de Levenshtein (orthographe similaire)&#10;                $similarity = $this-&gt;calculateLevenshteinSimilarity($normalizedGuess, $normalizedContentWord);&#10;                if ($similarity &gt; 0.8) {&#10;                    $maxProximity = max($maxProximity, 800 + ($similarity * 100));&#10;                } elseif ($similarity &gt; 0.6) {&#10;                    $maxProximity = max($maxProximity, 400 + ($similarity * 200));&#10;                } elseif ($similarity &gt; 0.4) {&#10;                    $maxProximity = max($maxProximity, 100 + ($similarity * 100));&#10;                }&#10;&#10;                // 3. Vérifier les sous-chaînes&#10;                if (strlen($normalizedGuess) &gt;= 3 &amp;&amp; strlen($normalizedContentWord) &gt;= 3) {&#10;                    if (strpos($normalizedGuess, $normalizedContentWord) !== false || strpos($normalizedContentWord, $normalizedGuess) !== false) {&#10;                        $maxProximity = max($maxProximity, 600);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Si aucune proximité significative trouvée, retourner 0 (pas d'affichage)&#10;        if ($maxProximity &lt; 100) {&#10;            return 0;&#10;        }&#10;&#10;        return min(999, $maxProximity);&#10;    }&#10;&#10;    /**&#10;     * Vérifie si une chaîne représente un nombre&#10;     */&#10;    private function isNumber(string $text): bool&#10;    {&#10;        // Enlever les espaces et normaliser&#10;        $text = trim($text);&#10;&#10;        // Vérifier les nombres entiers&#10;        if (preg_match('/^\d+$/', $text)) {&#10;            return true;&#10;        }&#10;&#10;        // Vérifier les nombres décimaux (avec . ou ,)&#10;        if (preg_match('/^\d+[.,]\d+$/', $text)) {&#10;            return true;&#10;        }&#10;&#10;        // Vérifier les nombres avec séparateurs de milliers&#10;        if (preg_match('/^\d{1,3}([ .,]\d{3})*$/', $text)) {&#10;            return true;&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Vérifie si une chaîne représente une date&#10;     */&#10;    private function isDate(string $text): bool&#10;    {&#10;        $text = trim($text);&#10;&#10;        // Formats de dates courants&#10;        $datePatterns = [&#10;            '/^\d{1,2}\/\d{1,2}\/\d{2,4}$/', // 15/08/1995 ou 15/08/95&#10;            '/^\d{1,2}-\d{1,2}-\d{2,4}$/',   // 15-08-1995 ou 15-08-95&#10;            '/^\d{4}-\d{1,2}-\d{1,2}$/',     // 1995-08-15&#10;            '/^\d{1,2}\s+\w+\s+\d{4}$/',     // 15 août 1995&#10;            '/^\w+\s+\d{1,2},?\s+\d{4}$/',   // août 15, 1995&#10;            '/^\d{4}$/',                      // 1995 (année seule)&#10;        ];&#10;&#10;        foreach ($datePatterns as $pattern) {&#10;            if (preg_match($pattern, $text)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Calcule la proximité entre un nombre/date deviné et les nombres/dates de l'article&#10;     */&#10;    private function calculateNumbersAndDatesProximity(string $guess, string $content, bool $isGuessNumber, bool $isGuessDate): int&#10;    {&#10;        $maxProximity = 0;&#10;&#10;        // Extraire tous les nombres et dates du contenu&#10;        $words = preg_split('/\s+/', $content);&#10;&#10;        foreach ($words as $word) {&#10;            $cleanWord = preg_replace('/[^\w\d\/\-.,]/', '', $word);&#10;&#10;            if ($isGuessNumber &amp;&amp; $this-&gt;isNumber($cleanWord)) {&#10;                $proximity = $this-&gt;calculateNumberProximity($guess, $cleanWord);&#10;                $maxProximity = max($maxProximity, $proximity);&#10;            }&#10;&#10;            if ($isGuessDate &amp;&amp; $this-&gt;isDate($cleanWord)) {&#10;                $proximity = $this-&gt;calculateDateProximity($guess, $cleanWord);&#10;                $maxProximity = max($maxProximity, $proximity);&#10;            }&#10;        }&#10;&#10;        return $maxProximity;&#10;    }&#10;&#10;    /**&#10;     * Calcule la proximité entre deux nombres&#10;     */&#10;    private function calculateNumberProximity(string $number1, string $number2): int&#10;    {&#10;        // Convertir en nombres pour comparaison&#10;        $num1 = $this-&gt;parseNumber($number1);&#10;        $num2 = $this-&gt;parseNumber($number2);&#10;&#10;        if ($num1 === null || $num2 === null) {&#10;            return 0;&#10;        }&#10;&#10;        // Si les nombres sont identiques&#10;        if ($num1 == $num2) {&#10;            return 950;&#10;        }&#10;&#10;        // Calculer la différence relative&#10;        $diff = abs($num1 - $num2);&#10;        $average = ($num1 + $num2) / 2;&#10;        $relativeDiff = $average &gt; 0 ? ($diff / $average) : 1;&#10;&#10;        // Plus la différence relative est petite, plus la proximité est haute&#10;        if ($relativeDiff &lt;= 0.1) {&#10;            return 850; // Très proche (différence de 10% ou moins)&#10;        } elseif ($relativeDiff &lt;= 0.25) {&#10;            return 700; // Proche (différence de 25% ou moins)&#10;        } elseif ($relativeDiff &lt;= 0.5) {&#10;            return 500; // Moyennement proche&#10;        } elseif ($relativeDiff &lt;= 1.0) {&#10;            return 300; // Assez proche&#10;        } elseif ($relativeDiff &lt;= 2.0) {&#10;            return 150; // Distant mais détectable&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;    /**&#10;     * Calcule la proximité entre deux dates&#10;     */&#10;    private function calculateDateProximity(string $date1, string $date2): int&#10;    {&#10;        $timestamp1 = $this-&gt;parseDate($date1);&#10;        $timestamp2 = $this-&gt;parseDate($date2);&#10;&#10;        if ($timestamp1 === null || $timestamp2 === null) {&#10;            return 0;&#10;        }&#10;&#10;        // Si les dates sont identiques&#10;        if ($timestamp1 == $timestamp2) {&#10;            return 950;&#10;        }&#10;&#10;        // Calculer la différence en jours&#10;        $diffDays = abs($timestamp1 - $timestamp2) / (60 * 60 * 24);&#10;&#10;        // Proximité basée sur la différence en jours&#10;        if ($diffDays &lt;= 7) {&#10;            return 850; // Même semaine&#10;        } elseif ($diffDays &lt;= 30) {&#10;            return 700; // Même mois approximativement&#10;        } elseif ($diffDays &lt;= 365) {&#10;            return 500; // Même année approximativement&#10;        } elseif ($diffDays &lt;= 1825) { // 5 ans&#10;            return 300; // Proche dans le temps&#10;        } elseif ($diffDays &lt;= 3650) { // 10 ans&#10;            return 150; // Assez proche&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;    /**&#10;     * Parse un nombre depuis une chaîne&#10;     */&#10;    private function parseNumber(string $numberStr): ?float&#10;    {&#10;        $numberStr = trim($numberStr);&#10;        $numberStr = str_replace([' ', ','], ['', '.'], $numberStr);&#10;        $numberStr = preg_replace('/[^\d.]/', '', $numberStr);&#10;&#10;        if (is_numeric($numberStr)) {&#10;            return (float) $numberStr;&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Parse une date depuis une chaîne&#10;     */&#10;    private function parseDate(string $dateStr): ?int&#10;    {&#10;        $dateStr = trim($dateStr);&#10;&#10;        // Si c'est juste une année&#10;        if (preg_match('/^\d{4}$/', $dateStr)) {&#10;            return mktime(0, 0, 0, 1, 1, (int)$dateStr);&#10;        }&#10;&#10;        // Essayer différents formats&#10;        $formats = [&#10;            'd/m/Y', 'd-m-Y', 'Y-m-d', 'd/m/y', 'd-m-y',&#10;            'j F Y', 'F j, Y', 'j M Y', 'M j, Y'&#10;        ];&#10;&#10;        foreach ($formats as $format) {&#10;            $date = \DateTime::createFromFormat($format, $dateStr);&#10;            if ($date !== false) {&#10;                return $date-&gt;getTimestamp();&#10;            }&#10;        }&#10;&#10;        // Essayer strtotime comme dernier recours&#10;        $timestamp = strtotime($dateStr);&#10;        return $timestamp !== false ? $timestamp : null;&#10;    }&#10;&#10;    private function calculateSemanticSimilarity(string $word1, string $word2): int&#10;    {&#10;        // Base de données de relations sémantiques simplifiée&#10;        $semanticGroups = $this-&gt;getSemanticGroups();&#10;&#10;        $group1 = null;&#10;        $group2 = null;&#10;&#10;        // Trouver les groupes sémantiques des mots&#10;        foreach ($semanticGroups as $groupName =&gt; $words) {&#10;            if (in_array($word1, $words)) {&#10;                $group1 = $groupName;&#10;            }&#10;            if (in_array($word2, $words)) {&#10;                $group2 = $groupName;&#10;            }&#10;        }&#10;&#10;        // Si les deux mots sont dans le même groupe sémantique&#10;        if ($group1 &amp;&amp; $group2 &amp;&amp; $group1 === $group2) {&#10;            return 900; // Très haute proximité sémantique&#10;        }&#10;&#10;        // Vérifier les groupes liés&#10;        $relatedGroups = $this-&gt;getRelatedSemanticGroups();&#10;        if ($group1 &amp;&amp; $group2 &amp;&amp; isset($relatedGroups[$group1]) &amp;&amp; in_array($group2, $relatedGroups[$group1])) {&#10;            return 700; // Proximité sémantique élevée&#10;        }&#10;&#10;        // Vérifier les synonymes directs&#10;        $synonyms = $this-&gt;getSynonyms();&#10;        if (isset($synonyms[$word1]) &amp;&amp; in_array($word2, $synonyms[$word1])) {&#10;            return 850;&#10;        }&#10;        if (isset($synonyms[$word2]) &amp;&amp; in_array($word1, $synonyms[$word2])) {&#10;            return 850;&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;    private function getSemanticGroups(): array&#10;    {&#10;        return [&#10;            'etats_matiere' =&gt; ['liquide', 'gaz', 'solide', 'plasma', 'vapeur', 'fluide'],&#10;            'chimie' =&gt; ['molecule', 'atome', 'element', 'compose', 'reaction', 'chimique', 'formule', 'oxygene', 'hydrogene', 'carbone', 'azote'],&#10;            'eau_related' =&gt; ['eau', 'aquatique', 'marin', 'maritime', 'oceanique', 'fluvial', 'hydrique', 'hydraulique', 'hydrologie'],&#10;            'temperature' =&gt; ['chaud', 'froid', 'chaleur', 'temperature', 'thermique', 'calorique', 'glacial', 'bouillant'],&#10;            'corps_humain' =&gt; ['corps', 'organisme', 'cellule', 'tissu', 'organe', 'muscle', 'sang', 'cerveau', 'coeur'],&#10;            'science' =&gt; ['physique', 'biologie', 'chimie', 'mathematiques', 'recherche', 'experience', 'laboratoire', 'scientifique'],&#10;            'geographie' =&gt; ['terre', 'planete', 'continent', 'ocean', 'mer', 'riviere', 'montagne', 'vallee', 'climat'],&#10;            'vie' =&gt; ['vivant', 'organisme', 'biologique', 'vital', 'existence', 'survie', 'evolutif'],&#10;            'couleurs' =&gt; ['rouge', 'bleu', 'vert', 'jaune', 'noir', 'blanc', 'orange', 'violet', 'rose', 'gris'],&#10;            'taille' =&gt; ['grand', 'petit', 'enorme', 'minuscule', 'gigantesque', 'microscopique', 'immense', 'tiny'],&#10;            'mouvement' =&gt; ['rapide', 'lent', 'vitesse', 'acceleration', 'deceleration', 'mobile', 'statique', 'dynamique'],&#10;            'qualites' =&gt; ['important', 'essentiel', 'crucial', 'vital', 'necessaire', 'indispensable', 'fondamental'],&#10;        ];&#10;    }&#10;&#10;    private function getRelatedSemanticGroups(): array&#10;    {&#10;        return [&#10;            'etats_matiere' =&gt; ['chimie', 'temperature', 'science'],&#10;            'chimie' =&gt; ['etats_matiere', 'science', 'eau_related'],&#10;            'eau_related' =&gt; ['chimie', 'etats_matiere', 'geographie', 'vie'],&#10;            'temperature' =&gt; ['etats_matiere', 'science'],&#10;            'corps_humain' =&gt; ['vie', 'science'],&#10;            'science' =&gt; ['chimie', 'corps_humain', 'temperature'],&#10;            'geographie' =&gt; ['eau_related', 'vie'],&#10;            'vie' =&gt; ['corps_humain', 'eau_related', 'geographie'],&#10;        ];&#10;    }&#10;&#10;    private function getSynonyms(): array&#10;    {&#10;        return [&#10;            'eau' =&gt; ['h2o', 'aqua', 'flotte'],&#10;            'liquide' =&gt; ['fluide', 'liquid'],&#10;            'gaz' =&gt; ['gazeux', 'vapeur', 'aeriforme'],&#10;            'solide' =&gt; ['dur', 'rigide', 'cristallin'],&#10;            'chaud' =&gt; ['chaude', 'brulant', 'torride'],&#10;            'froid' =&gt; ['froide', 'glacial', 'frigide'],&#10;            'grand' =&gt; ['grande', 'gros', 'grosse', 'immense', 'gigantesque'],&#10;            'petit' =&gt; ['petite', 'minuscule', 'infime'],&#10;            'important' =&gt; ['importante', 'essentiel', 'essentielle', 'crucial', 'cruciale'],&#10;            'necessaire' =&gt; ['indispensable', 'requis', 'obligatoire'],&#10;            'vivant' =&gt; ['vivante', 'anime', 'biologique'],&#10;            'chimique' =&gt; ['chimiques', 'moleculaire'],&#10;            'naturel' =&gt; ['naturelle', 'nature', 'natif'],&#10;            'artificiel' =&gt; ['artificielle', 'synthetique', 'fabrique'],&#10;        ];&#10;    }&#10;&#10;    private function calculateLevenshteinSimilarity(string $str1, string $str2): float&#10;    {&#10;        $len1 = strlen($str1);&#10;        $len2 = strlen($str2);&#10;&#10;        if ($len1 === 0 &amp;&amp; $len2 === 0) return 1.0;&#10;        if ($len1 === 0 || $len2 === 0) return 0.0;&#10;&#10;        $distance = levenshtein($str1, $str2);&#10;        $maxLen = max($len1, $len2);&#10;&#10;        return 1 - ($distance / $maxLen);&#10;    }&#10;&#10;    private function getStopWords(): array&#10;    {&#10;        return [&#10;            'le', 'de', 'et', 'à', 'un', 'il', 'être', 'en', 'avoir', 'que', 'pour',&#10;            'dans', 'ce', 'son', 'une', 'sur', 'avec', 'ne', 'se', 'pas', 'tout', 'plus',&#10;            'par', 'grand', 'mais', 'qui', 'comme', 'où', 'ou', 'du', 'des', 'les', 'la',&#10;            'cette', 'ces', 'ses', 'leur', 'leurs', 'aux', 'nous', 'vous', 'ils', 'elles',&#10;            'est', 'sont', 'était', 'ont', 'peut', 'fait', 'très', 'bien', 'deux', 'aussi'&#10;        ];&#10;    }&#10;&#10;    private function buildWordProximityMapping(string $content, array $proximityData): array&#10;    {&#10;        $mapping = [];&#10;&#10;        if (empty($proximityData)) {&#10;            return $mapping;&#10;        }&#10;&#10;        // Extraire tous les mots de l'article&#10;        $allContentWords = $this-&gt;extractAllWordsFromContent($content);&#10;&#10;        foreach ($proximityData as $proximityInfo) {&#10;            $guessedWord = $proximityInfo['word'];&#10;            $proximityScore = $proximityInfo['proximity'];&#10;&#10;            // Ignorer les proximités trop faibles&#10;            if ($proximityScore &lt; 100) {&#10;                continue;&#10;            }&#10;&#10;            // Pour chaque mot de l'article, vérifier la compatibilité avec le mot deviné&#10;            foreach ($allContentWords as $contentWord) {&#10;                $normalizedContentWord = $this-&gt;normalizeWord($contentWord);&#10;                $normalizedGuessedWord = $this-&gt;normalizeWord($guessedWord);&#10;&#10;                $shouldMap = false;&#10;                $similarity = 0;&#10;&#10;                // 1. Vérifier si les deux sont des nombres&#10;                if ($this-&gt;isNumber($guessedWord) &amp;&amp; $this-&gt;isNumber($contentWord)) {&#10;                    $numberProximity = $this-&gt;calculateNumberProximity($guessedWord, $contentWord);&#10;                    if ($numberProximity &gt; 0) {&#10;                        $shouldMap = true;&#10;                        $similarity = $numberProximity / 1000; // Normaliser pour comparaison&#10;                    }&#10;                }&#10;                // 2. Vérifier si les deux sont des dates&#10;                elseif ($this-&gt;isDate($guessedWord) &amp;&amp; $this-&gt;isDate($contentWord)) {&#10;                    $dateProximity = $this-&gt;calculateDateProximity($guessedWord, $contentWord);&#10;                    if ($dateProximity &gt; 0) {&#10;                        $shouldMap = true;&#10;                        $similarity = $dateProximity / 1000; // Normaliser pour comparaison&#10;                    }&#10;                }&#10;                // 3. Vérifier la similarité textuelle pour les mots normaux&#10;                else {&#10;                    $textSimilarity = $this-&gt;calculateLevenshteinSimilarity($normalizedGuessedWord, $normalizedContentWord);&#10;                    // Réduire le seuil de similarité pour garder plus de suggestions&#10;                    if ($textSimilarity &gt; 0.2) {&#10;                        $shouldMap = true;&#10;                        $similarity = $textSimilarity;&#10;                    }&#10;&#10;                    // Vérifier aussi la proximité sémantique&#10;                    $semanticScore = $this-&gt;calculateSemanticSimilarity($normalizedGuessedWord, $normalizedContentWord);&#10;                    if ($semanticScore &gt; 600) {&#10;                        $shouldMap = true;&#10;                        $similarity = max($similarity, $semanticScore / 1000);&#10;                    }&#10;&#10;                    // Vérifier les sous-chaînes pour maintenir les suggestions&#10;                    if (strlen($normalizedGuessedWord) &gt;= 3 &amp;&amp; strlen($normalizedContentWord) &gt;= 3) {&#10;                        if (strpos($normalizedGuessedWord, $normalizedContentWord) !== false ||&#10;                            strpos($normalizedContentWord, $normalizedGuessedWord) !== false) {&#10;                            $shouldMap = true;&#10;                            $similarity = max($similarity, 0.6);&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Si ce mot doit être mappé&#10;                if ($shouldMap) {&#10;                    $currentScore = $proximityScore * $similarity; // Score combiné&#10;&#10;                    // CHANGEMENT IMPORTANT: Au lieu de remplacer, garder la meilleure suggestion&#10;                    // mais aussi permettre plusieurs suggestions pour le même mot si elles sont bonnes&#10;                    if (!isset($mapping[$normalizedContentWord])) {&#10;                        $mapping[$normalizedContentWord] = [&#10;                            'guessed_word' =&gt; $guessedWord,&#10;                            'proximity' =&gt; $proximityScore,&#10;                            'similarity' =&gt; $similarity,&#10;                            'combined_score' =&gt; $currentScore&#10;                        ];&#10;                    } else {&#10;                        // Si le nouveau mapping a un score significativement meilleur (&gt;20% d'amélioration)&#10;                        // OU si c'est une proximité très élevée (&gt;800), alors on remplace&#10;                        $existingScore = $mapping[$normalizedContentWord]['combined_score'];&#10;                        if ($currentScore &gt; $existingScore * 1.2 || $proximityScore &gt; 800) {&#10;                            $mapping[$normalizedContentWord] = [&#10;                                'guessed_word' =&gt; $guessedWord,&#10;                                'proximity' =&gt; $proximityScore,&#10;                                'similarity' =&gt; $similarity,&#10;                                'combined_score' =&gt; $currentScore&#10;                            ];&#10;                        }&#10;                        // Sinon, on garde l'ancien mapping pour éviter que les suggestions disparaissent&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return $mapping;&#10;    }&#10;&#10;    /**&#10;     * Construit un mapping des proximités sémantiques pour les mots trouvés&#10;     */&#10;    private function buildSemanticProximityMapping(string $content, array $foundWords): array&#10;    {&#10;        $mapping = [];&#10;&#10;        if (empty($foundWords)) {&#10;            return $mapping;&#10;        }&#10;&#10;        // Extraire tous les mots de l'article&#10;        $allContentWords = $this-&gt;extractAllWordsFromContent($content);&#10;&#10;        foreach ($foundWords as $foundWord) {&#10;            $normalizedFoundWord = $this-&gt;normalizeWord($foundWord);&#10;&#10;            // Pour chaque mot de l'article, vérifier s'il a une proximité sémantique avec ce mot trouvé&#10;            foreach ($allContentWords as $contentWord) {&#10;                $normalizedContentWord = $this-&gt;normalizeWord($contentWord);&#10;&#10;                // Éviter de remapper le mot sur lui-même s'il est déjà à sa place exacte&#10;                if ($normalizedContentWord === $normalizedFoundWord) {&#10;                    continue;&#10;                }&#10;&#10;                // Calculer la proximité sémantique&#10;                $semanticScore = $this-&gt;calculateSemanticSimilarity($normalizedFoundWord, $normalizedContentWord);&#10;&#10;                // Si il y a une proximité sémantique significative&#10;                if ($semanticScore &gt;= 700) // Seuil élevé pour l'affichage sémantique&#10;                {&#10;                    // Seulement si ce mot n'a pas déjà un mapping avec un score plus élevé&#10;                    if (!isset($mapping[$normalizedContentWord]) || $mapping[$normalizedContentWord]['proximity'] &lt; $semanticScore) {&#10;                        $mapping[$normalizedContentWord] = [&#10;                            'found_word' =&gt; $foundWord,&#10;                            'proximity' =&gt; $semanticScore&#10;                        ];&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return $mapping;&#10;    }&#10;&#10;    /**&#10;     * Récupère un article Wikipedia aléatoire&#10;     */&#10;    public function getRandomArticle(?string $difficulty = null): ?WikipediaArticle&#10;    {&#10;        return $this-&gt;wikipediaArticleRepository-&gt;findRandomArticle($difficulty);&#10;    }&#10;&#10;&#10;    /**&#10;     * Récupère les événements de jeu en temps réel (nouvelles victoires, etc.)&#10;     */&#10;    public function getGameEvents(Room $room, int $lastEventId): array&#10;    {&#10;        // Récupérer les événements récents (joueurs qui ont trouvé le mot, nouvelles victoires, etc.)&#10;        $events = [];&#10;&#10;        // Vérifier les sessions qui ont été complétées récemment&#10;        $recentCompletions = $this-&gt;gameSessionRepository-&gt;getRecentCompletions($room, $lastEventId);&#10;&#10;        foreach ($recentCompletions as $session) {&#10;            $events[] = [&#10;                'id' =&gt; $session-&gt;getId() + 1000, // Offset pour éviter les conflits&#10;                'type' =&gt; 'player_won',&#10;                'player_name' =&gt; $session-&gt;getPlayerName(),&#10;                'score' =&gt; $session-&gt;getScore(),&#10;                'attempts' =&gt; $session-&gt;getAttempts(),&#10;                'completed_at' =&gt; $session-&gt;getCompletedAt()-&gt;format('Y-m-d H:i:s'),&#10;                'position' =&gt; $this-&gt;getPlayerPosition($room, $session),&#10;                'message' =&gt; $this-&gt;generateVictoryMessage($session, $room)&#10;            ];&#10;        }&#10;&#10;        return $events;&#10;    }&#10;&#10;    public function checkGameStatus(Room $room): array&#10;    {&#10;        $activePlayers = $this-&gt;getActivePlayers($room);&#10;        $completedPlayers = $this-&gt;gameSessionRepository-&gt;getCompletedSessions($room);&#10;&#10;        $totalPlayers = count($activePlayers);&#10;        $completedCount = count($completedPlayers);&#10;&#10;        // En mode compétition, vérifier si tous les joueurs ont terminé&#10;        if ($room-&gt;getGameMode() === 'competition') {&#10;            $allCompleted = $totalPlayers &gt; 0 &amp;&amp; $completedCount &gt;= $totalPlayers;&#10;&#10;            if ($allCompleted &amp;&amp; !$room-&gt;isGameCompleted()) {&#10;                // Marquer le jeu comme terminé&#10;                $room-&gt;setIsGameCompleted(true);&#10;                $room-&gt;setCompletedAt(new \DateTimeImmutable());&#10;&#10;                // Définir le gagnant (meilleur score)&#10;                $winner = $this-&gt;gameSessionRepository-&gt;getWinner($room);&#10;                if ($winner) {&#10;                    $room-&gt;setWinnerId($winner-&gt;getId());&#10;                }&#10;&#10;                $this-&gt;roomRepository-&gt;save($room, true);&#10;            }&#10;&#10;            // Récupérer les informations du gagnant correctement formatées&#10;            $winnerData = null;&#10;            if ($room-&gt;getWinnerId()) {&#10;                $winner = $this-&gt;getGameSession($room-&gt;getWinnerId());&#10;                if ($winner) {&#10;                    $winnerData = [&#10;                        'player_name' =&gt; $winner-&gt;getPlayerName(),&#10;                        'score' =&gt; $winner-&gt;getScore(),&#10;                        'attempts' =&gt; $winner-&gt;getAttempts()&#10;                    ];&#10;                }&#10;            }&#10;&#10;            return [&#10;                'is_completed' =&gt; $allCompleted,&#10;                'total_players' =&gt; $totalPlayers,&#10;                'completed_players' =&gt; $completedCount,&#10;                'winner' =&gt; $winnerData,&#10;                'game_mode' =&gt; 'competition'&#10;            ];&#10;        }&#10;        // En mode coopération, vérifier si le jeu est terminé (titre trouvé)&#10;        elseif ($room-&gt;getGameMode() === 'cooperation') {&#10;            $isCompleted = $room-&gt;isGameCompleted();&#10;&#10;            // Récupérer les informations de l'équipe gagnante&#10;            $teamData = null;&#10;            if ($isCompleted) {&#10;                $allCompletedPlayers = $this-&gt;gameSessionRepository-&gt;getCompletedSessions($room);&#10;                if (!empty($allCompletedPlayers)) {&#10;                    // En coopération, tous les joueurs sont gagnants&#10;                    $teamData = array_map(function($session) {&#10;                        return [&#10;                            'player_name' =&gt; $session-&gt;getPlayerName(),&#10;                            'score' =&gt; $session-&gt;getScore(),&#10;                            'attempts' =&gt; $session-&gt;getAttempts()&#10;                        ];&#10;                    }, $allCompletedPlayers);&#10;                }&#10;            }&#10;&#10;            return [&#10;                'is_completed' =&gt; $isCompleted,&#10;                'total_players' =&gt; $totalPlayers,&#10;                'completed_players' =&gt; $completedCount,&#10;                'team' =&gt; $teamData, // En coopération, on parle d'équipe plutôt que de gagnant individuel&#10;                'game_mode' =&gt; 'cooperation'&#10;            ];&#10;        }&#10;&#10;        return [&#10;            'is_completed' =&gt; false,&#10;            'total_players' =&gt; $totalPlayers,&#10;            'completed_players' =&gt; $completedCount,&#10;            'game_mode' =&gt; $room-&gt;getGameMode()&#10;        ];&#10;    }&#10;&#10;    public function completeGame(Room $room, int $sessionId): array&#10;    {&#10;        // Marquer manuellement le jeu comme terminé&#10;        $room-&gt;setIsGameCompleted(true);&#10;        $room-&gt;setCompletedAt(new \DateTimeImmutable());&#10;&#10;        // Définir le gagnant si pas encore fait&#10;        if (!$room-&gt;getWinnerId()) {&#10;            $winner = $this-&gt;gameSessionRepository-&gt;getWinner($room);&#10;            if ($winner) {&#10;                $room-&gt;setWinnerId($winner-&gt;getId());&#10;            }&#10;        }&#10;&#10;        $this-&gt;roomRepository-&gt;save($room, true);&#10;&#10;        // Retourner les statistiques finales&#10;        $leaderboard = $this-&gt;getLeaderboard($room);&#10;        $winner = $room-&gt;getWinnerId() ? $this-&gt;getGameSession($room-&gt;getWinnerId()) : null;&#10;&#10;        return [&#10;            'winner' =&gt; $winner ? [&#10;                'player_name' =&gt; $winner-&gt;getPlayerName(),&#10;                'score' =&gt; $winner-&gt;getScore(),&#10;                'attempts' =&gt; $winner-&gt;getAttempts()&#10;            ] : null,&#10;            'leaderboard' =&gt; array_map(function($session) {&#10;                return [&#10;                    'player_name' =&gt; $session-&gt;getPlayerName(),&#10;                    'score' =&gt; $session-&gt;getScore(),&#10;                    'attempts' =&gt; $session-&gt;getAttempts(),&#10;                    'completed_at' =&gt; $session-&gt;getCompletedAt()?-&gt;format('Y-m-d H:i:s')&#10;                ];&#10;            }, $leaderboard)&#10;        ];&#10;    }&#10;&#10;    public function transferPlayersToNewRoom(string $oldRoomCode, Room $newRoom): array&#10;    {&#10;        $oldRoom = $this-&gt;getRoomByCode($oldRoomCode);&#10;        if (!$oldRoom) {&#10;            throw new \Exception('Ancienne salle introuvable');&#10;        }&#10;&#10;        $activePlayers = $this-&gt;getActivePlayers($oldRoom);&#10;        $transferredPlayers = [];&#10;&#10;        foreach ($activePlayers as $oldSession) {&#10;            // Créer une nouvelle session dans la nouvelle salle&#10;            $newSession = new GameSession();&#10;            $newSession-&gt;setRoom($newRoom);&#10;            $newSession-&gt;setPlayerName($oldSession-&gt;getPlayerName());&#10;            $newSession-&gt;setIpAddress($oldSession-&gt;getIpAddress());&#10;&#10;            $this-&gt;gameSessionRepository-&gt;save($newSession, true);&#10;&#10;            $transferredPlayers[] = [&#10;                'player_name' =&gt; $newSession-&gt;getPlayerName(),&#10;                'new_session_id' =&gt; $newSession-&gt;getId()&#10;            ];&#10;        }&#10;&#10;        return [&#10;            'transferred_players' =&gt; $transferredPlayers,&#10;            'count' =&gt; count($transferredPlayers)&#10;        ];&#10;    }&#10;&#10;    public function getRoomStatus(Room $room, ?GameSession $gameSession): array&#10;    {&#10;        $activePlayers = $this-&gt;getActivePlayers($room);&#10;        $completedPlayers = $this-&gt;gameSessionRepository-&gt;getCompletedSessions($room);&#10;&#10;        $status = [&#10;            'room_code' =&gt; $room-&gt;getCode(),&#10;            'game_mode' =&gt; $room-&gt;getGameMode(),&#10;            'is_game_completed' =&gt; $room-&gt;isGameCompleted(),&#10;            'total_players' =&gt; count($activePlayers),&#10;            'completed_players' =&gt; count($completedPlayers),&#10;            'winner' =&gt; null&#10;        ];&#10;&#10;        if ($room-&gt;getWinnerId()) {&#10;            $winner = $this-&gt;getGameSession($room-&gt;getWinnerId());&#10;            if ($winner) {&#10;                $status['winner'] = [&#10;                    'player_name' =&gt; $winner-&gt;getPlayerName(),&#10;                    'score' =&gt; $winner-&gt;getScore(),&#10;                    'attempts' =&gt; $winner-&gt;getAttempts()&#10;                ];&#10;            }&#10;        }&#10;&#10;        if ($gameSession) {&#10;            $status['current_player'] = [&#10;                'name' =&gt; $gameSession-&gt;getPlayerName(),&#10;                'score' =&gt; $gameSession-&gt;getScore(),&#10;                'attempts' =&gt; $gameSession-&gt;getAttempts(),&#10;                'completed' =&gt; $gameSession-&gt;isCompleted(),&#10;                'position' =&gt; $this-&gt;getPlayerPosition($room, $gameSession)&#10;            ];&#10;        }&#10;&#10;        return $status;&#10;    }&#10;&#10;    /**&#10;     * Démarre une nouvelle partie dans la même salle avec un nouvel article&#10;     */&#10;    public function startNewGameInSameRoom(Room $room, string $wikipediaUrl): array&#10;    {&#10;        try {&#10;            // Récupérer les données du nouvel article&#10;            $articleData = $this-&gt;fetchWikipediaArticle($wikipediaUrl);&#10;&#10;            // Sauvegarder les scores précédents avant de réinitialiser&#10;            $this-&gt;archivePreviousGameScores($room);&#10;&#10;            // Réinitialiser la salle pour la nouvelle partie&#10;            $room-&gt;resetForNewGame(&#10;                $articleData['title'],&#10;                $articleData['content'],&#10;                $wikipediaUrl,&#10;                $articleData['allWords']&#10;            );&#10;&#10;            // Réinitialiser toutes les sessions de jeu pour la nouvelle partie&#10;            $this-&gt;resetAllGameSessions($room);&#10;&#10;            // Sauvegarder les changements&#10;            $this-&gt;roomRepository-&gt;save($room, true);&#10;&#10;            return [&#10;                'title' =&gt; $articleData['title'],&#10;                'game_number' =&gt; $room-&gt;getGameNumber()&#10;            ];&#10;&#10;        } catch (\Exception $e) {&#10;            // En cas d'erreur, déverrouiller la salle&#10;            $room-&gt;unlockNewGame();&#10;            $this-&gt;roomRepository-&gt;save($room, true);&#10;            throw $e;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Archive les scores de la partie précédente&#10;     */&#10;    private function archivePreviousGameScores(Room $room): void&#10;    {&#10;        // Pour l'instant, on garde simplement les scores cumulatifs&#10;        // Dans une version future, on pourrait créer une table d'historique des parties&#10;        $activeSessions = $this-&gt;gameSessionRepository-&gt;findActiveSessionsForRoom($room);&#10;&#10;        foreach ($activeSessions as $session) {&#10;            // Marquer la session comme archivée pour cette partie&#10;            // Les scores seront conservés et s'additionneront à la prochaine partie&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Réinitialise toutes les sessions de jeu pour une nouvelle partie&#10;     */&#10;    private function resetAllGameSessions(Room $room): void&#10;    {&#10;        $activeSessions = $this-&gt;gameSessionRepository-&gt;findActiveSessionsForRoom($room);&#10;&#10;        foreach ($activeSessions as $session) {&#10;            // Réinitialiser les données spécifiques à la partie mais garder le score cumulé&#10;            $currentScore = $session-&gt;getScore(); // Score cumulé de toutes les parties&#10;&#10;            $session-&gt;setFoundWords([]);&#10;            $session-&gt;setAttempts(0);&#10;            $session-&gt;setCompleted(false);&#10;            $session-&gt;setCompletedAt(null);&#10;            $session-&gt;updateActivity();&#10;            // Le score reste inchangé pour être cumulatif&#10;&#10;            $this-&gt;gameSessionRepository-&gt;save($session, false);&#10;        }&#10;&#10;        // Flush tous les changements en une fois&#10;        $this-&gt;entityManager-&gt;flush();&#10;    }&#10;&#10;    /**&#10;     * Sauvegarde une salle&#10;     */&#10;    public function saveRoom(Room $room): void&#10;    {&#10;        $this-&gt;roomRepository-&gt;save($room, true);&#10;    }&#10;&#10;    /**&#10;     * Calcule la difficulté d'un mot basé sur le nombre de joueurs qui l'ont trouvé&#10;     */&#10;    private function calculateWordDifficulty(string $word, int $foundByCount, int $totalPlayers): string&#10;    {&#10;        $percentage = $totalPlayers &gt; 0 ? ($foundByCount / $totalPlayers) * 100 : 0;&#10;&#10;        if ($percentage &gt;= 80) {&#10;            return 'Très facile';&#10;        } elseif ($percentage &gt;= 60) {&#10;            return 'Facile';&#10;        } elseif ($percentage &gt;= 40) {&#10;            return 'Moyen';&#10;        } elseif ($percentage &gt;= 20) {&#10;            return 'Difficile';&#10;        } else {&#10;            return 'Très difficile';&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retourne le style CSS pour la couleur de proximité&#10;     */&#10;    private function getProximityColorStyle(int $proximityScore): string&#10;    {&#10;        if ($proximityScore &gt;= 800) {&#10;            return 'background: #d0d0d0 !important; color: #FFD700 !important; font-weight: bold !important;'; // Très chaud - doré&#10;        } elseif ($proximityScore &gt;= 600) {&#10;            return 'background: #d0d0d0 !important; color: #FF8C00 !important; font-weight: bold !important;'; // Chaud - orange&#10;        } elseif ($proximityScore &gt;= 400) {&#10;            return 'background: #d0d0d0 !important; color: #FF6347 !important;'; // Tiède - rouge tomate&#10;        } else {&#10;            return 'background: #d0d0d0 !important; color: #696969 !important;'; // Froid - gris foncé&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtient la position d'un joueur dans le classement&#10;     */&#10;    private function getPlayerPosition(Room $room, GameSession $session): int&#10;    {&#10;        $leaderboard = $this-&gt;getLeaderboard($room);&#10;&#10;        foreach ($leaderboard as $index =&gt; $leaderSession) {&#10;            if ($leaderSession-&gt;getId() === $session-&gt;getId()) {&#10;                return $index + 1;&#10;            }&#10;        }&#10;&#10;        return count($leaderboard) + 1; // Si pas trouvé, mettre à la fin&#10;    }&#10;&#10;    /**&#10;     * Génère un message de victoire personnalisé&#10;     */&#10;    private function generateVictoryMessage(GameSession $session, Room $room): string&#10;    {&#10;        $position = $this-&gt;getPlayerPosition($room, $session);&#10;        $playerName = $session-&gt;getPlayerName();&#10;&#10;        if ($position === 1) {&#10;            return &quot; {$playerName} remporte la victoire !&quot;;&#10;        } elseif ($position &lt;= 3) {&#10;            return &quot; {$playerName} termine sur le podium (#{$position}) !&quot;;&#10;        } else {&#10;            return &quot;✅ {$playerName} a trouvé le mot-titre !&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Récupère les informations de progression du titre (mots trouvés/total)&#10;     */&#10;    public function getTitleProgress(GameSession $gameSession, Room $room): array&#10;    {&#10;        $titleWords = $this-&gt;extractTitleWords($room-&gt;getTitle());&#10;        $titleWordsNormalized = array_map([$this, 'normalizeWord'], $titleWords);&#10;&#10;        // En mode coopération, vérifier les mots trouvés globalement&#10;        if ($room-&gt;isCooperativeMode()) {&#10;            $allFoundWords = array_unique(array_merge($gameSession-&gt;getFoundWords(), $room-&gt;getGlobalFoundWords()));&#10;        } else {&#10;            $allFoundWords = $gameSession-&gt;getFoundWords();&#10;        }&#10;&#10;        $foundWordsNormalized = array_map([$this, 'normalizeWord'], $allFoundWords);&#10;&#10;        $displayWords = [];&#10;        $foundCount = 0;&#10;&#10;        foreach ($titleWords as $index =&gt; $titleWord) {&#10;            $normalizedTitleWord = $titleWordsNormalized[$index];&#10;            $isFound = false;&#10;&#10;            foreach ($foundWordsNormalized as $foundWord) {&#10;                if ($foundWord === $normalizedTitleWord) {&#10;                    $isFound = true;&#10;                    break;&#10;                }&#10;            }&#10;&#10;            if ($isFound) {&#10;                $displayWords[] = $titleWord; // Afficher le mot trouvé&#10;                $foundCount++;&#10;            } else {&#10;                // Afficher des traits selon la longueur du mot&#10;                $displayWords[] = str_repeat('_', mb_strlen($titleWord));&#10;            }&#10;        }&#10;&#10;        return [&#10;            'title' =&gt; $room-&gt;getTitle(),&#10;            'total_words' =&gt; count($titleWords),&#10;            'found_words' =&gt; $foundCount,&#10;            'display_title' =&gt; implode(' ', $displayWords),&#10;            'is_complete' =&gt; $foundCount === count($titleWords),&#10;            'progress_percentage' =&gt; count($titleWords) &gt; 0 ? round(($foundCount / count($titleWords)) * 100) : 0&#10;        ];&#10;    }&#10;&#10;    /**&#10;     * Marque tous les joueurs actifs comme gagnants en mode coopération&#10;     */&#10;    private function markAllPlayersAsWinners(Room $room): void&#10;    {&#10;        $activePlayers = $this-&gt;getActivePlayers($room);&#10;&#10;        foreach ($activePlayers as $session) {&#10;            if (!$session-&gt;isCompleted()) {&#10;                $session-&gt;setCompleted(true);&#10;                $session-&gt;setCompletedAt(new \DateTimeImmutable());&#10;&#10;                // Attribuer un score de participation pour tous les joueurs&#10;                $participationScore = max(500 - ($session-&gt;getAttempts() * 5), 100);&#10;                $session-&gt;setScore($session-&gt;getScore() + $participationScore);&#10;&#10;                $this-&gt;gameSessionRepository-&gt;save($session, false);&#10;            }&#10;        }&#10;&#10;        // Flush tous les changements en une fois&#10;        $this-&gt;entityManager-&gt;flush();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;namespace App\Service;&#10;&#10;use App\Entity\GameSession;&#10;use App\Entity\Room;&#10;use App\Entity\WikipediaArticle;&#10;use App\Repository\GameSessionRepository;&#10;use App\Repository\RoomRepository;&#10;use App\Repository\WikipediaArticleRepository;&#10;use Doctrine\ORM\EntityManagerInterface;&#10;&#10;class PedantixService&#10;{&#10;    public function __construct(&#10;        private EntityManagerInterface $entityManager,&#10;        private RoomRepository $roomRepository,&#10;        private GameSessionRepository $gameSessionRepository,&#10;        private WikipediaArticleRepository $wikipediaArticleRepository&#10;    ) {}&#10;&#10;    public function createRoom(string $wikipediaUrl, string $gameMode = 'competition'): Room&#10;    {&#10;        $articleData = $this-&gt;fetchWikipediaArticle($wikipediaUrl);&#10;&#10;        // Ajouter automatiquement l'article à notre base de données s'il n'existe pas&#10;        $this-&gt;addArticleToDatabase($wikipediaUrl, $articleData['title']);&#10;&#10;        $room = new Room();&#10;        $room-&gt;setTitle($articleData['title']);&#10;        $room-&gt;setContent($articleData['content']);&#10;        $room-&gt;setUrl($wikipediaUrl);&#10;        $room-&gt;setWordsToFind($articleData['allWords']);&#10;        $room-&gt;setHints([]); // Pas d'indices dans le vrai Pedantix&#10;        $room-&gt;setGameMode($gameMode);&#10;&#10;        $this-&gt;roomRepository-&gt;save($room, true);&#10;&#10;        return $room;&#10;    }&#10;&#10;    public function joinRoom(string $roomCode, string $playerName, string $ipAddress): ?GameSession&#10;    {&#10;        $room = $this-&gt;roomRepository-&gt;findByCode($roomCode);&#10;        if (!$room) {&#10;            return null;&#10;        }&#10;&#10;        // Chercher une session existante pour ce joueur&#10;        $existingSession = $this-&gt;gameSessionRepository-&gt;findByRoomAndPlayer($room, $playerName, $ipAddress);&#10;&#10;        if ($existingSession) {&#10;            $existingSession-&gt;updateActivity();&#10;            $this-&gt;gameSessionRepository-&gt;save($existingSession, true);&#10;            return $existingSession;&#10;        }&#10;&#10;        // Créer une nouvelle session&#10;        $gameSession = new GameSession();&#10;        $gameSession-&gt;setRoom($room);&#10;        $gameSession-&gt;setPlayerName($playerName);&#10;        $gameSession-&gt;setIpAddress($ipAddress);&#10;&#10;        $this-&gt;gameSessionRepository-&gt;save($gameSession, true);&#10;&#10;        return $gameSession;&#10;    }&#10;&#10;    public function submitGuess(GameSession $gameSession, string $guess): array&#10;    {&#10;        $guess = trim($guess);&#10;        $room = $gameSession-&gt;getRoom();&#10;        $content = $room-&gt;getContent();&#10;&#10;        // Vérifier si le mot a déjà été essayé par ce joueur&#10;        $normalizedGuess = $this-&gt;normalizeWord($guess);&#10;        $foundWordsNormalized = array_map([$this, 'normalizeWord'], $gameSession-&gt;getFoundWords());&#10;&#10;        if (in_array($normalizedGuess, $foundWordsNormalized)) {&#10;            return [&#10;                'found' =&gt; false,&#10;                'word' =&gt; $guess,&#10;                'proximity' =&gt; null,&#10;                'gameCompleted' =&gt; false,&#10;                'isExactMatch' =&gt; false,&#10;                'error' =&gt; 'Mot déjà trouvé',&#10;                'duplicate' =&gt; true&#10;            ];&#10;        }&#10;&#10;        $gameSession-&gt;incrementAttempts();&#10;        $gameSession-&gt;updateActivity();&#10;&#10;        $result = [&#10;            'found' =&gt; false,&#10;            'word' =&gt; $guess,&#10;            'proximity' =&gt; null,&#10;            'gameCompleted' =&gt; false,&#10;            'isExactMatch' =&gt; false,&#10;            'duplicate' =&gt; false&#10;        ];&#10;&#10;        // Extraire tous les mots significatifs du titre&#10;        $titleWords = $this-&gt;extractTitleWords($room-&gt;getTitle());&#10;        $titleWordsNormalized = array_map([$this, 'normalizeWord'], $titleWords);&#10;&#10;        // Vérifier si le mot deviné correspond à un des mots du titre&#10;        $isTitleWord = false;&#10;        foreach ($titleWordsNormalized as $titleWord) {&#10;            if ($titleWord === $normalizedGuess) {&#10;                $isTitleWord = true;&#10;                break;&#10;            }&#10;        }&#10;&#10;        if ($isTitleWord) {&#10;            $result['found'] = true;&#10;            $result['isExactMatch'] = true;&#10;            $gameSession-&gt;addFoundWord($guess);&#10;&#10;            // En mode coopératif, ajouter le mot à la liste globale de la salle&#10;            if ($room-&gt;isCooperativeMode()) {&#10;                $room-&gt;addGlobalFoundWord($guess);&#10;                $this-&gt;roomRepository-&gt;save($room, true);&#10;            }&#10;&#10;            // Vérifier si TOUS les mots du titre ont été trouvés&#10;            $allTitleWordsFound = $this-&gt;checkAllTitleWordsFound($gameSession, $room, $titleWordsNormalized);&#10;&#10;            if ($allTitleWordsFound) {&#10;                $result['gameCompleted'] = true;&#10;                $gameSession-&gt;setCompleted(true);&#10;&#10;                // En mode coopération, marquer le jeu comme terminé pour tous&#10;                if ($room-&gt;isCooperativeMode()) {&#10;                    $room-&gt;setIsGameCompleted(true);&#10;                    $room-&gt;setCompletedAt(new \DateTimeImmutable());&#10;&#10;                    // En coopération, tous les joueurs actifs deviennent &quot;gagnants&quot;&#10;                    $this-&gt;markAllPlayersAsWinners($room);&#10;                    $this-&gt;roomRepository-&gt;save($room, true);&#10;                }&#10;&#10;                // Score final basé sur le nombre de tentatives (moins = mieux)&#10;                $finalScore = max(1000 - ($gameSession-&gt;getAttempts() * 10), 100);&#10;                $gameSession-&gt;setScore($finalScore);&#10;            }&#10;&#10;            $this-&gt;gameSessionRepository-&gt;save($gameSession, true);&#10;            return $result;&#10;        }&#10;&#10;        // Vérifier si le mot existe dans l'article (mais n'est pas un mot du titre)&#10;        if ($this-&gt;wordExistsInArticle($guess, $content)) {&#10;            $result['found'] = true;&#10;            $gameSession-&gt;addFoundWord($guess);&#10;&#10;            // En mode coopératif, ajouter le mot à la liste globale de la salle&#10;            if ($room-&gt;isCooperativeMode()) {&#10;                $room-&gt;addGlobalFoundWord($guess);&#10;                $this-&gt;roomRepository-&gt;save($room, true);&#10;            }&#10;&#10;            // Ajouter des points pour chaque mot trouvé (seulement si pas déjà trouvé)&#10;            $currentScore = $gameSession-&gt;getScore() + 10;&#10;            $gameSession-&gt;setScore($currentScore);&#10;        } else {&#10;            // Calculer la proximité sémantique avec les mots de l'article&#10;            $result['proximity'] = $this-&gt;calculateSemanticProximity($guess, $content, $room-&gt;getTitle());&#10;        }&#10;&#10;        $this-&gt;gameSessionRepository-&gt;save($gameSession, true);&#10;        return $result;&#10;    }&#10;&#10;    /**&#10;     * Vérifie si tous les mots du titre ont été trouvés par le joueur&#10;     */&#10;    private function checkAllTitleWordsFound(GameSession $gameSession, Room $room, array $titleWordsNormalized): bool&#10;    {&#10;        // En mode coopération, vérifier les mots trouvés globalement&#10;        if ($room-&gt;isCooperativeMode()) {&#10;            $allFoundWords = array_unique(array_merge($gameSession-&gt;getFoundWords(), $room-&gt;getGlobalFoundWords()));&#10;        } else {&#10;            $allFoundWords = $gameSession-&gt;getFoundWords();&#10;        }&#10;&#10;        $foundWordsNormalized = array_map([$this, 'normalizeWord'], $allFoundWords);&#10;&#10;        // Vérifier que chaque mot du titre a été trouvé&#10;        foreach ($titleWordsNormalized as $titleWord) {&#10;            $found = false;&#10;            foreach ($foundWordsNormalized as $foundWord) {&#10;                if ($foundWord === $titleWord) {&#10;                    $found = true;&#10;                    break;&#10;                }&#10;            }&#10;            if (!$found) {&#10;                return false; // Il manque encore au moins un mot&#10;            }&#10;        }&#10;&#10;        return true; // Tous les mots du titre ont été trouvés&#10;    }&#10;&#10;    public function getProcessedContent(Room $room, array $foundWords, array $proximityData = [], bool $gameCompleted = false): string&#10;    {&#10;        $content = $room-&gt;getContent();&#10;&#10;        // En mode coopératif, combiner les mots trouvés par le joueur avec ceux trouvés globalement&#10;        if ($room-&gt;isCooperativeMode()) {&#10;            $allFoundWords = array_unique(array_merge($foundWords, $room-&gt;getGlobalFoundWords()));&#10;        } else {&#10;            $allFoundWords = $foundWords;&#10;        }&#10;&#10;        $foundWordsNormalized = array_map([$this, 'normalizeWord'], $allFoundWords);&#10;&#10;        // Si le jeu est terminé, révéler tous les mots normalement (pas en jaune)&#10;        if ($gameCompleted) {&#10;            // Diviser le contenu en mots tout en préservant la ponctuation et la structure&#10;            $words = preg_split('/(\s+|[.,;:!?()&quot;\'-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;            $processedWords = [];&#10;            foreach ($words as $word) {&#10;                if (trim($word) === '' || preg_match('/^\s*$/', $word) || preg_match('/^[.,;:!?()&quot;\'-]+$/', $word)) {&#10;                    // Espaces et ponctuation - garder tel quel&#10;                    $processedWords[] = $word;&#10;                } else {&#10;                    // Tous les mots sont révélés avec un style normal (plus de jaune)&#10;                    $processedWords[] = '&lt;span class=&quot;revealed-word-victory&quot;&gt;' . htmlspecialchars($word) . '&lt;/span&gt;';&#10;                }&#10;            }&#10;&#10;            return implode('', $processedWords);&#10;        }&#10;&#10;        // Créer un mapping des mots de l'article vers les mots devinés les plus proches&#10;        $wordProximityMapping = $this-&gt;buildWordProximityMapping($content, $proximityData);&#10;&#10;        // Créer un mapping des proximités sémantiques pour les mots trouvés&#10;        $semanticProximityMapping = $this-&gt;buildSemanticProximityMapping($content, $allFoundWords);&#10;&#10;        // Comportement normal : diviser le contenu en mots tout en préservant la ponctuation et la structure&#10;        $words = preg_split('/(\s+|[.,;:!?()&quot;\'-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;        $processedWords = [];&#10;        foreach ($words as $word) {&#10;            if (trim($word) === '' || preg_match('/^\s*$/', $word) || preg_match('/^[.,;:!?()&quot;\'-]+$/', $word)) {&#10;                // Espaces et ponctuation - garder tel quel&#10;                $processedWords[] = $word;&#10;            } else {&#10;                // C'est un mot - vérifier s'il doit être dévoilé&#10;                $normalizedWord = $this-&gt;normalizeWord($word);&#10;                $isRevealed = $this-&gt;isWordRevealed($word, $foundWordsNormalized);&#10;&#10;                if ($isRevealed) {&#10;                    // Mot trouvé : affichage en texte noir normal sans arrière-plan&#10;                    $processedWords[] = '&lt;span class=&quot;revealed-word&quot;&gt;' . htmlspecialchars($word) . '&lt;/span&gt;';&#10;                } else {&#10;                    // Vérifier si ce mot a une proximité sémantique avec un mot trouvé&#10;                    if (isset($semanticProximityMapping[$normalizedWord])) {&#10;                        $semanticInfo = $semanticProximityMapping[$normalizedWord];&#10;                        $foundWord = $semanticInfo['found_word'];&#10;                        $proximityScore = $semanticInfo['proximity'];&#10;                        $colorStyle = $this-&gt;getProximityColorStyle($proximityScore);&#10;&#10;                        // Afficher le mot trouvé avec la couleur de proximité sémantique&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word-with-proximity&quot; style=&quot;' . $colorStyle . '&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot; data-found=&quot;' . htmlspecialchars($foundWord) . '&quot; data-proximity=&quot;' . $proximityScore . '&quot;&gt;' . htmlspecialchars($foundWord) . '&lt;/span&gt;';&#10;                    } else if (isset($wordProximityMapping[$normalizedWord])) {&#10;                        // Vérifier la proximité avec les mots devinés mais non trouvés&#10;                        $proximityInfo = $wordProximityMapping[$normalizedWord];&#10;                        $guessedWord = $proximityInfo['guessed_word'];&#10;                        $proximityScore = $proximityInfo['proximity'];&#10;                        $colorStyle = $this-&gt;getProximityColorStyle($proximityScore);&#10;&#10;                        // Afficher le mot deviné avec la couleur de proximité&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word-with-proximity&quot; style=&quot;' . $colorStyle . '&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot; data-guessed=&quot;' . htmlspecialchars($guessedWord) . '&quot; data-proximity=&quot;' . $proximityScore . '&quot;&gt;' . htmlspecialchars($guessedWord) . '&lt;/span&gt;';&#10;                    } else {&#10;                        // Mot complètement caché&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot;&gt;' . str_repeat('█', mb_strlen($word)) . '&lt;/span&gt;';&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return implode('', $processedWords);&#10;    }&#10;&#10;    /**&#10;     * Vérifie si un mot de l'article doit être révélé basé sur les mots trouvés par le joueur&#10;     * Prend en compte les conjugaisons et variations&#10;     */&#10;    private function isWordRevealed(string $articleWord, array $foundWordsNormalized): bool&#10;    {&#10;        $normalizedArticleWord = $this-&gt;normalizeWord($articleWord);&#10;&#10;        // Vérification directe&#10;        if (in_array($normalizedArticleWord, $foundWordsNormalized)) {&#10;            return true;&#10;        }&#10;&#10;        // Vérifier si le mot de l'article est une conjugaison d'un des mots trouvés&#10;        foreach ($foundWordsNormalized as $foundWord) {&#10;            if ($this-&gt;isVerbConjugation($foundWord, $normalizedArticleWord)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        // Vérifier les contractions avec apostrophes&#10;        if (strpos($articleWord, &quot;'&quot;) !== false) {&#10;            $parts = explode(&quot;'&quot;, $articleWord);&#10;            foreach ($parts as $part) {&#10;                $normalizedPart = $this-&gt;normalizeWord($part);&#10;                if (in_array($normalizedPart, $foundWordsNormalized)) {&#10;                    return true;&#10;                }&#10;                // Vérifier les conjugaisons pour chaque partie&#10;                foreach ($foundWordsNormalized as $foundWord) {&#10;                    if ($this-&gt;isVerbConjugation($foundWord, $normalizedPart)) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    public function getLeaderboard(Room $room): array&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;getLeaderboard($room);&#10;    }&#10;&#10;    public function getActivePlayers(Room $room): array&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;findActiveSessionsForRoom($room);&#10;    }&#10;&#10;    public function getRoomByCode(string $code): ?Room&#10;    {&#10;        return $this-&gt;roomRepository-&gt;findByCode($code);&#10;    }&#10;&#10;    public function getGameSession(int $sessionId): ?GameSession&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;find($sessionId);&#10;    }&#10;&#10;    private function fetchWikipediaArticle(string $url): array&#10;    {&#10;        $title = $this-&gt;extractTitleFromUrl($url);&#10;&#10;        // Utiliser l'API de résumé de Wikipedia qui donne directement l'introduction&#10;        $summaryApiUrl = &quot;https://fr.wikipedia.org/api/rest_v1/page/summary/&quot; . urlencode($title);&#10;&#10;        $context = stream_context_create([&#10;            'http' =&gt; [&#10;                'header' =&gt; &quot;User-Agent: PedantixApp/1.0\r\n&quot;,&#10;                'timeout' =&gt; 30,&#10;                'ignore_errors' =&gt; true&#10;            ]&#10;        ]);&#10;&#10;        try {&#10;            $summaryResponse = file_get_contents($summaryApiUrl, false, $context);&#10;&#10;            if ($summaryResponse === false) {&#10;                $error = error_get_last();&#10;                throw new \Exception('Impossible de r��cupérer l\'article Wikipedia: ' . ($error['message'] ?? 'Erreur de connexion'));&#10;            }&#10;&#10;            $summaryData = json_decode($summaryResponse, true);&#10;&#10;            if (!$summaryData) {&#10;                throw new \Exception('Réponse invalide de l\'API Wikipedia');&#10;            }&#10;&#10;            if (isset($summaryData['type']) &amp;&amp; $summaryData['type'] === 'disambiguation') {&#10;                throw new \Exception('Cette page est une page de désambiguïsation. Veuillez choisir un article plus spécifique.');&#10;            }&#10;&#10;            if (!isset($summaryData['extract']) || empty($summaryData['extract'])) {&#10;                throw new \Exception('Contenu de l\'article introuvable ou vide');&#10;            }&#10;&#10;            // L'extract contient déjà un résumé propre de l'article&#10;            $content = $summaryData['extract'];&#10;&#10;            // Nettoyer un peu plus le contenu pour enlever les références restantes&#10;            $content = preg_replace('/\[[\d,\s]+\]/', '', $content); // Supprimer les références [1], [2,3], etc.&#10;            $content = preg_replace('/\s+/', ' ', $content); // Normaliser les espaces&#10;            $content = trim($content);&#10;&#10;            if (strlen($content) &lt; 50) {&#10;                throw new \Exception('L\'article est trop court pour créer une partie intéressante');&#10;            }&#10;&#10;            $properTitle = $summaryData['title'] ?? $title;&#10;&#10;            return [&#10;                'title' =&gt; $properTitle,&#10;                'content' =&gt; $content,&#10;                'allWords' =&gt; $this-&gt;extractAllWords($content)&#10;            ];&#10;        } catch (\Exception $e) {&#10;            // Log l'erreur pour debugging&#10;            error_log('Erreur fetchWikipediaArticle: ' . $e-&gt;getMessage() . ' pour URL: ' . $url);&#10;            throw $e;&#10;        }&#10;    }&#10;&#10;    private function cleanWikipediaContent(string $html): string&#10;    {&#10;        // Supprimer les balises non désirées&#10;        $html = preg_replace('/&lt;script.*?&lt;\/script&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;style.*?&lt;\/style&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;figure.*?&lt;\/figure&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;table.*?&lt;\/table&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*infobox[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;&#10;        // Supprimer TOUTES les boîtes d'aide, navigation et métadonnées&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*dablink[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*hatnote[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*disambig[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*navigation[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*navbox[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*metadata[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;&#10;        // Approche plus simple et plus stricte : extraire seulement les 2-3 premiers vrais paragraphes&#10;        preg_match_all('/&lt;p[^&gt;]*&gt;(.*?)&lt;\/p&gt;/is', $html, $matches);&#10;        $allParagraphs = $matches[1];&#10;&#10;        $introContent = [];&#10;        $paragraphCount = 0;&#10;&#10;        foreach ($allParagraphs as $paragraph) {&#10;            $cleaned = strip_tags($paragraph);&#10;            $cleaned = html_entity_decode($cleaned, ENT_QUOTES, 'UTF-8');&#10;            $cleaned = preg_replace('/\s+/', ' ', $cleaned);&#10;            $cleaned = trim($cleaned);&#10;&#10;            // Filtres très stricts pour ne garder que l'introduction&#10;            if (!empty($cleaned) &amp;&amp;&#10;                strlen($cleaned) &gt; 30 &amp;&amp; // Paragraphes substantiels seulement&#10;                !preg_match('/^(Pour les articles|Page d\'aide|Ne doit pas être confondu|Cet article|voir|redirigé|coordination|modifier|wikidata)/i', $cleaned) &amp;&amp;&#10;                !preg_match('/(homonymie|homonymes|voir aussi|articles connexes|catégorie|portail)/i', $cleaned) &amp;&amp;&#10;                !preg_match('/^\s*(modifier|edit|\[|\()/i', $cleaned)) {&#10;&#10;                $introContent[] = $cleaned;&#10;                $paragraphCount++;&#10;&#10;                // LIMITER STRICTEMENT à 2-3 paragraphes d'introduction maximum&#10;                if ($paragraphCount &gt;= 2) {&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;        // S'assurer qu'on a au moins quelque chose de substantiel&#10;        if (empty($introContent)) {&#10;            return &quot;L'eau est un composé chimique ubiquitaire sur la Terre, essentiel pour tous les organismes vivants connus.&quot;;&#10;        }&#10;&#10;        return implode(&quot;\n\n&quot;, $introContent);&#10;    }&#10;&#10;    private function getElementPosition(\DOMNode $element): int&#10;    {&#10;        $position = 0;&#10;        $current = $element;&#10;&#10;        while ($current-&gt;previousSibling !== null) {&#10;            $current = $current-&gt;previousSibling;&#10;            $position++;&#10;        }&#10;&#10;        // Ajouter la position des parents&#10;        if ($current-&gt;parentNode !== null &amp;&amp; $current-&gt;parentNode-&gt;nodeName !== '#document') {&#10;            $position += $this-&gt;getElementPosition($current-&gt;parentNode) * 1000;&#10;        }&#10;&#10;        return $position;&#10;    }&#10;&#10;    private function extractTitleFromUrl(string $url): string&#10;    {&#10;        $path = parse_url($url, PHP_URL_PATH);&#10;        $title = basename($path);&#10;        return urldecode($title);&#10;    }&#10;&#10;    private function extractAllWords(string $content): array&#10;    {&#10;        $words = preg_split('/\s+/', $content);&#10;        $cleanWords = [];&#10;&#10;        foreach ($words as $word) {&#10;            $cleaned = $this-&gt;normalizeWord($word);&#10;            if (strlen($cleaned) &gt;= 2 &amp;&amp; !in_array($cleaned, $this-&gt;getStopWords())) {&#10;                $cleanWords[] = $cleaned;&#10;            }&#10;        }&#10;&#10;        return array_unique($cleanWords);&#10;    }&#10;&#10;    private function extractAllWordsFromContent(string $content): array&#10;    {&#10;        // Extraire tous les mots du contenu en préservant la structure&#10;        $words = preg_split('/(\s+|[.,;:!?()&quot;\-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;        $cleanWords = [];&#10;&#10;        foreach ($words as $word) {&#10;            $cleanWord = trim($word);&#10;            if (empty($cleanWord) || preg_match('/^[.,;:!?()&quot;\'\\-\\s]+$/', $cleanWord)) {&#10;                continue;&#10;            }&#10;&#10;            // Traitement spécial pour les mots avec apostrophes&#10;            if (strpos($cleanWord, &quot;'&quot;) !== false) {&#10;                $parts = explode(&quot;'&quot;, $cleanWord);&#10;                foreach ($parts as $part) {&#10;                    $part = trim($part);&#10;                    if (!empty($part) &amp;&amp; strlen($part) &gt;= 2) {&#10;                        $cleanWords[] = $part;&#10;                    }&#10;                }&#10;            } else {&#10;                if (strlen($cleanWord) &gt;= 2) {&#10;                    $cleanWords[] = $cleanWord;&#10;                }&#10;            }&#10;        }&#10;&#10;        return $cleanWords;&#10;    }&#10;&#10;    private function extractTitleWords(string $title): array&#10;    {&#10;        // Extraire tous les mots significatifs du titre&#10;        $words = preg_split('/\s+/', $title);&#10;        $titleWords = [];&#10;&#10;        foreach ($words as $word) {&#10;            $cleaned = $this-&gt;normalizeWord($word);&#10;            if (strlen($cleaned) &gt;= 2) {&#10;                $titleWords[] = $word; // Garder le mot original, pas normalisé&#10;            }&#10;        }&#10;&#10;        return $titleWords;&#10;    }&#10;&#10;    private function normalizeWord(string $word): string&#10;    {&#10;        // Enlever la ponctuation et normaliser&#10;        $word = preg_replace('/[^\p{L}\p{N}]/u', '', $word);&#10;        $word = mb_strtolower($word, 'UTF-8');&#10;&#10;        // Enlever les accents pour la comparaison&#10;        $word = iconv('UTF-8', 'ASCII//TRANSLIT//IGNORE', $word);&#10;        $word = preg_replace('/[^a-z0-9]/', '', $word);&#10;&#10;        return $word;&#10;    }&#10;&#10;    private function wordExistsInArticle(string $guess, string $content): bool&#10;    {&#10;        $normalizedGuess = $this-&gt;normalizeWord($guess);&#10;&#10;        // Cas spécial pour les contractions comme &quot;l'&quot;&#10;        if (strlen($guess) == 1 &amp;&amp; in_array(strtolower($guess), ['l', 'd', 'j', 'n', 'm', 'c', 's', 't'])) {&#10;            // Rechercher des patterns comme &quot;l'eau&quot;, &quot;d'eau&quot;, etc.&#10;            $pattern = '/\b' . preg_quote(strtolower($guess)) . '\'/i';&#10;            if (preg_match($pattern, $content)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        // Diviser le contenu en mots en préservant les apostrophes&#10;        $words = preg_split('/(\s+|[.,;:!?()&quot;\-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;        foreach ($words as $word) {&#10;            $cleanWord = trim($word);&#10;            if (empty($cleanWord)) continue;&#10;&#10;            // Traitement spécial pour les mots avec apostrophes&#10;            if (strpos($cleanWord, &quot;'&quot;) !== false) {&#10;                $parts = explode(&quot;'&quot;, $cleanWord);&#10;                foreach ($parts as $part) {&#10;                    if ($this-&gt;normalizeWord($part) === $normalizedGuess) {&#10;                        return true;&#10;                    }&#10;                    // Vérifier les conjugaisons pour les parties de mots avec apostrophe&#10;                    if ($this-&gt;isVerbConjugation($normalizedGuess, $this-&gt;normalizeWord($part))) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;&#10;            $normalizedWord = $this-&gt;normalizeWord($cleanWord);&#10;            if ($normalizedWord === $normalizedGuess) {&#10;                return true;&#10;            }&#10;&#10;            // Vérifier si le mot deviné est un infinitif et le mot de l'article une conjugaison&#10;            if ($this-&gt;isVerbConjugation($normalizedGuess, $normalizedWord)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Vérifie si un mot est une conjugaison d'un verbe à l'infinitif&#10;     */&#10;    private function isVerbConjugation(string $infinitive, string $word): bool&#10;    {&#10;        // Patterns de conjugaison française simplifiés&#10;        $conjugationPatterns = $this-&gt;getConjugationPatterns();&#10;&#10;        foreach ($conjugationPatterns as $ending =&gt; $replacements) {&#10;            if (str_ends_with($infinitive, $ending)) {&#10;                $stem = substr($infinitive, 0, -strlen($ending));&#10;&#10;                foreach ($replacements as $replacement) {&#10;                    $conjugated = $stem . $replacement;&#10;                    if ($conjugated === $word) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Vérifier aussi les verbes irréguliers les plus courants&#10;        $irregularVerbs = $this-&gt;getIrregularVerbs();&#10;        if (isset($irregularVerbs[$infinitive])) {&#10;            return in_array($word, $irregularVerbs[$infinitive]);&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Patterns de conjugaison pour les verbes réguliers&#10;     */&#10;    private function getConjugationPatterns(): array&#10;    {&#10;        return [&#10;            'er' =&gt; [&#10;                'e', 'es', 'e', 'ons', 'ez', 'ent', // présent&#10;                'ais', 'ais', 'ait', 'ions', 'iez', 'aient', // imparfait&#10;                'ai', 'as', 'a', 'ames', 'ates', 'erent', // passé simple&#10;                'erai', 'eras', 'era', 'erons', 'erez', 'eront', // futur&#10;                'erais', 'erais', 'erait', 'erions', 'eriez', 'eraient', // conditionnel&#10;                'ant', 'e', // participes&#10;            ],&#10;            'ir' =&gt; [&#10;                'is', 'is', 'it', 'issons', 'issez', 'issent', // présent&#10;                'issais', 'issais', 'issait', 'issions', 'issiez', 'issaient', // imparfait&#10;                'is', 'is', 'it', 'imes', 'ites', 'irent', // passé simple&#10;                'irai', 'iras', 'ira', 'irons', 'irez', 'iront', // futur&#10;                'irais', 'irais', 'irait', 'irions', 'iriez', 'iraient', // conditionnel&#10;                'issant', 'i', // participes&#10;            ],&#10;            're' =&gt; [&#10;                's', 's', '', 'ons', 'ez', 'ent', // présent&#10;                'ais', 'ais', 'ait', 'ions', 'iez', 'aient', // imparfait&#10;                'is', 'is', 'it', 'imes', 'ites', 'irent', // passé simple&#10;                'rai', 'ras', 'ra', 'rons', 'rez', 'ront', // futur&#10;                'rais', 'rais', 'rait', 'rions', 'riez', 'raient', // conditionnel&#10;                'ant', 'u', // participes&#10;            ]&#10;        ];&#10;    }&#10;&#10;    /**&#10;     * Verbes irréguliers les plus courants&#10;     */&#10;    private function getIrregularVerbs(): array&#10;    {&#10;        return [&#10;            'etre' =&gt; ['suis', 'es', 'est', 'sommes', 'etes', 'sont', 'etais', 'etait', 'etions', 'etiez', 'etaient', 'fus', 'fut', 'fumes', 'furent', 'serai', 'seras', 'sera', 'serons', 'serez', 'seront', 'serais', 'serait', 'serions', 'seriez', 'seraient', 'etant', 'ete'],&#10;            'avoir' =&gt; ['ai', 'as', 'a', 'avons', 'avez', 'ont', 'avais', 'avait', 'avions', 'aviez', 'avaient', 'eus', 'eut', 'eumes', 'eurent', 'aurai', 'auras', 'aura', 'aurons', 'aurez', 'auront', 'aurais', 'aurait', 'aurions', 'auriez', 'auraient', 'ayant', 'eu'],&#10;            'aller' =&gt; ['vais', 'vas', 'va', 'allons', 'allez', 'vont', 'allais', 'allait', 'allions', 'alliez', 'allaient', 'allai', 'alla', 'allames', 'allerent', 'irai', 'iras', 'ira', 'irons', 'irez', 'iront', 'irais', 'irait', 'irions', 'iriez', 'iraient', 'allant', 'alle'],&#10;            'faire' =&gt; ['fais', 'fait', 'faisons', 'faites', 'font', 'faisais', 'faisait', 'faisions', 'faisiez', 'faisaient', 'fis', 'fit', 'fimes', 'firent', 'ferai', 'feras', 'fera', 'ferons', 'ferez', 'feront', 'ferais', 'ferait', 'ferions', 'feriez', 'feraient', 'faisant', 'fait'],&#10;            'dire' =&gt; ['dis', 'dit', 'disons', 'dites', 'disent', 'disais', 'disait', 'disions', 'disiez', 'disaient', 'dis', 'dit', 'dimes', 'dirent', 'dirai', 'diras', 'dira', 'dirons', 'direz', 'diront', 'dirais', 'dirait', 'dirions', 'diriez', 'diraient', 'disant', 'dit'],&#10;            'voir' =&gt; ['vois', 'voit', 'voyons', 'voyez', 'voient', 'voyais', 'voyait', 'voyions', 'voyiez', 'voyaient', 'vis', 'vit', 'vimes', 'virent', 'verrai', 'verras', 'verra', 'verrons', 'verrez', 'verront', 'verrais', 'verrait', 'verrions', 'verriez', 'verraient', 'voyant', 'vu'],&#10;            'savoir' =&gt; ['sais', 'sait', 'savons', 'savez', 'savent', 'savais', 'savait', 'savions', 'saviez', 'savaient', 'sus', 'sut', 'sumes', 'surent', 'saurai', 'sauras', 'saura', 'saurons', 'saurez', 'sauront', 'saurais', 'saurait', 'saurions', 'sauriez', 'sauraient', 'sachant', 'su'],&#10;            'pouvoir' =&gt; ['peux', 'peut', 'pouvons', 'pouvez', 'peuvent', 'pouvais', 'pouvait', 'pouvions', 'pouviez', 'pouvaient', 'pus', 'put', 'pumes', 'purent', 'pourrai', 'pourras', 'pourra', 'pourrons', 'pourrez', 'pourront', 'pourrais', 'pourrait', 'pourrions', 'pourriez', 'pourraient', 'pouvant', 'pu'],&#10;            'vouloir' =&gt; ['veux', 'veut', 'voulons', 'voulez', 'veulent', 'voulais', 'voulait', 'voulions', 'vouliez', 'voulaient', 'voulus', 'voulut', 'voulumes', 'voulurent', 'voudrai', 'voudras', 'voudra', 'voudrons', 'voudrez', 'voudront', 'voudrais', 'voudrait', 'voudrions', 'voudriez', 'voudraient', 'voulant', 'voulu'],&#10;            'venir' =&gt; ['viens', 'vient', 'venons', 'venez', 'viennent', 'venais', 'venait', 'venions', 'veniez', 'venaient', 'vins', 'vint', 'vinmes', 'vinrent', 'viendrai', 'viendras', 'viendra', 'viendrons', 'viendrez', 'viendront', 'viendrais', 'viendrait', 'viendrions', 'viendriez', 'viendraient', 'venant', 'venu'],&#10;            'partir' =&gt; ['pars', 'part', 'partons', 'partez', 'partent', 'partais', 'partait', 'partions', 'partiez', 'partaient', 'partis', 'partit', 'partimes', 'partirent', 'partirai', 'partiras', 'partira', 'partirons', 'partirez', 'partiront', 'partirais', 'partirait', 'partirions', 'partiriez', 'partiraient', 'partant', 'parti'],&#10;        ];&#10;    }&#10;&#10;    /**&#10;     * Ajoute automatiquement un article à la base de données s'il n'existe pas déjà&#10;     */&#10;    private function addArticleToDatabase(string $url, string $title): void&#10;    {&#10;        try {&#10;            // Vérifier si l'article existe déjà&#10;            $existingArticle = $this-&gt;wikipediaArticleRepository-&gt;findOneBy(['url' =&gt; $url]);&#10;            &#10;            if (!$existingArticle) {&#10;                // Créer un nouvel article&#10;                $article = new WikipediaArticle();&#10;                $article-&gt;setTitle($title);&#10;                $article-&gt;setUrl($url);&#10;                &#10;                // Déterminer automatiquement la catégorie et la difficulté&#10;                $category = $this-&gt;determineCategory($title, $url);&#10;                $difficulty = $this-&gt;determineDifficulty($title, $url);&#10;                &#10;                $article-&gt;setCategory($category);&#10;                $article-&gt;setDifficulty($difficulty);&#10;                $article-&gt;setActive(true);&#10;&#10;                // Sauvegarder l'article&#10;                $this-&gt;entityManager-&gt;persist($article);&#10;                $this-&gt;entityManager-&gt;flush();&#10;                &#10;                error_log(&quot;Nouvel article ajouté automatiquement: {$title} ({$category}, {$difficulty})&quot;);&#10;            }&#10;        } catch (\Exception $e) {&#10;            // En cas d'erreur, on continue sans bloquer la création de la room&#10;            error_log(&quot;Erreur lors de l'ajout automatique de l'article: &quot; . $e-&gt;getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Détermine automatiquement la catégorie d'un article&#10;     */&#10;    private function determineCategory(string $title, string $url): string&#10;    {&#10;        $title = strtolower($title);&#10;        $url = strtolower($url);&#10;        &#10;        // Animaux&#10;        if (preg_match('/\b(chat|chien|lion|tigre|éléphant|oiseau|poisson|animal|mammifère|reptile|insecte|abeille|papillon|requin|baleine)\b/', $title . ' ' . $url)) {&#10;            return 'Animaux';&#10;        }&#10;        &#10;        // Géographie&#10;        if (preg_match('/\b(paris|france|ville|pays|océan|mer|montagne|rivière|continent|capitale|géographie)\b/', $title . ' ' . $url)) {&#10;            return 'Géographie';&#10;        }&#10;        &#10;        // Sciences&#10;        if (preg_match('/\b(physique|chimie|biologie|mathématiques|science|scientifique|recherche|laboratoire|théorie|loi)\b/', $title . ' ' . $url)) {&#10;            return 'Science';&#10;        }&#10;        &#10;        // Histoire&#10;        if (preg_match('/\b(guerre|révolution|empire|roi|reine|histoire|historique|siècle|moyen|âge|renaissance|napoléon)\b/', $title . ' ' . $url)) {&#10;            return 'Histoire';&#10;        }&#10;        &#10;        // Art et Culture&#10;        if (preg_match('/\b(art|peinture|musique|littérature|poésie|roman|théâtre|cinéma|culture|musée|monument)\b/', $title . ' ' . $url)) {&#10;            return 'Culture';&#10;        }&#10;        &#10;        // Technologies&#10;        if (preg_match('/\b(informatique|internet|ordinateur|technologie|logiciel|intelligence|artificielle|algorithme)\b/', $title . ' ' . $url)) {&#10;            return 'Technologie';&#10;        }&#10;        &#10;        // Sport&#10;        if (preg_match('/\b(football|tennis|rugby|sport|olympique|compétition|championnat)\b/', $title . ' ' . $url)) {&#10;            return 'Sport';&#10;        }&#10;        &#10;        // Médecine&#10;        if (preg_match('/\b(médecine|santé|maladie|traitement|médicament|docteur|hôpital|vaccin|antibiotique)\b/', $title . ' ' . $url)) {&#10;            return 'Médecine';&#10;        }&#10;        &#10;        // Alimentation&#10;        if (preg_match('/\b(pain|chocolat|fromage|vin|cuisine|alimentation|nourriture|gastronomie)\b/', $title . ' ' . $url)) {&#10;            return 'Alimentation';&#10;        }&#10;        &#10;        // Par défaut&#10;        return 'Divers';&#10;    }&#10;&#10;    /**&#10;     * Détermine automatiquement la difficulté d'un article&#10;     */&#10;    private function determineDifficulty(string $title, string $url): string&#10;    {&#10;        $title = strtolower($title);&#10;        $url = strtolower($url);&#10;        &#10;        // Mots clés pour difficulté facile&#10;        $easyKeywords = [&#10;            'chat', 'chien', 'eau', 'soleil', 'lune', 'pain', 'chocolat', 'rouge', 'bleu', 'vert',&#10;            'paris', 'france', 'voiture', 'avion', 'train', 'football', 'tennis', 'animal', 'oiseau',&#10;            'montagne', 'mer', 'rivière', 'pomme', 'fromage', 'maison', 'école', 'famille'&#10;        ];&#10;        &#10;        // Mots clés pour difficulté difficile&#10;        $hardKeywords = [&#10;            'quantique', 'relativité', 'mitochondrie', 'épigénétique', 'thermodynamique', 'algorithme',&#10;            'cryptographie', 'topologie', 'epistémologie', 'métaphysique', 'phénoménologie',&#10;            'neurologie', 'oncologie', 'microéconomie', 'psychanalyse', 'tectonique', 'spectroscopie'&#10;        ];&#10;        &#10;        // Vérifier les mots-clés difficiles&#10;        foreach ($hardKeywords as $keyword) {&#10;            if (strpos($title . ' ' . $url, $keyword) !== false) {&#10;                return 'difficile';&#10;            }&#10;        }&#10;        &#10;        // Vérifier les mots-clés faciles&#10;        foreach ($easyKeywords as $keyword) {&#10;            if (strpos($title . ' ' . $url, $keyword) !== false) {&#10;                return 'facile';&#10;            }&#10;        }&#10;        &#10;        // Critères basés sur la longueur et la complexité du titre&#10;        $titleLength = strlen($title);&#10;        $wordCount = count(explode(' ', $title));&#10;        &#10;        if ($titleLength &gt; 30 || $wordCount &gt; 4) {&#10;            return 'difficile';&#10;        } elseif ($titleLength &lt; 10 &amp;&amp; $wordCount &lt;= 2) {&#10;            return 'facile';&#10;        }&#10;        &#10;        // Par défaut, niveau moyen&#10;        return 'moyen';&#10;    }&#10;&#10;    /**&#10;     * Vérifie si tous les mots du titre ont été trouvés par le joueur&#10;     */&#10;    private function checkAllTitleWordsFound(GameSession $gameSession, Room $room, array $titleWordsNormalized): bool&#10;    {&#10;        // En mode coopération, vérifier les mots trouvés globalement&#10;        if ($room-&gt;isCooperativeMode()) {&#10;            $allFoundWords = array_unique(array_merge($gameSession-&gt;getFoundWords(), $room-&gt;getGlobalFoundWords()));&#10;        } else {&#10;            $allFoundWords = $gameSession-&gt;getFoundWords();&#10;        }&#10;&#10;        $foundWordsNormalized = array_map([$this, 'normalizeWord'], $allFoundWords);&#10;&#10;        // Vérifier que chaque mot du titre a été trouvé&#10;        foreach ($titleWordsNormalized as $titleWord) {&#10;            $found = false;&#10;            foreach ($foundWordsNormalized as $foundWord) {&#10;                if ($foundWord === $titleWord) {&#10;                    $found = true;&#10;                    break;&#10;                }&#10;            }&#10;            if (!$found) {&#10;                return false; // Il manque encore au moins un mot&#10;            }&#10;        }&#10;&#10;        return true; // Tous les mots du titre ont été trouvés&#10;    }&#10;&#10;    public function getProcessedContent(Room $room, array $foundWords, array $proximityData = [], bool $gameCompleted = false): string&#10;    {&#10;        $content = $room-&gt;getContent();&#10;&#10;        // En mode coopératif, combiner les mots trouvés par le joueur avec ceux trouvés globalement&#10;        if ($room-&gt;isCooperativeMode()) {&#10;            $allFoundWords = array_unique(array_merge($foundWords, $room-&gt;getGlobalFoundWords()));&#10;        } else {&#10;            $allFoundWords = $foundWords;&#10;        }&#10;&#10;        $foundWordsNormalized = array_map([$this, 'normalizeWord'], $allFoundWords);&#10;&#10;        // Si le jeu est terminé, révéler tous les mots normalement (pas en jaune)&#10;        if ($gameCompleted) {&#10;            // Diviser le contenu en mots tout en préservant la ponctuation et la structure&#10;            $words = preg_split('/(\s+|[.,;:!?()&quot;\'-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;            $processedWords = [];&#10;            foreach ($words as $word) {&#10;                if (trim($word) === '' || preg_match('/^\s*$/', $word) || preg_match('/^[.,;:!?()&quot;\'-]+$/', $word)) {&#10;                    // Espaces et ponctuation - garder tel quel&#10;                    $processedWords[] = $word;&#10;                } else {&#10;                    // Tous les mots sont révélés avec un style normal (plus de jaune)&#10;                    $processedWords[] = '&lt;span class=&quot;revealed-word-victory&quot;&gt;' . htmlspecialchars($word) . '&lt;/span&gt;';&#10;                }&#10;            }&#10;&#10;            return implode('', $processedWords);&#10;        }&#10;&#10;        // Créer un mapping des mots de l'article vers les mots devinés les plus proches&#10;        $wordProximityMapping = $this-&gt;buildWordProximityMapping($content, $proximityData);&#10;&#10;        // Créer un mapping des proximités sémantiques pour les mots trouvés&#10;        $semanticProximityMapping = $this-&gt;buildSemanticProximityMapping($content, $allFoundWords);&#10;&#10;        // Comportement normal : diviser le contenu en mots tout en préservant la ponctuation et la structure&#10;        $words = preg_split('/(\s+|[.,;:!?()&quot;\'-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;        $processedWords = [];&#10;        foreach ($words as $word) {&#10;            if (trim($word) === '' || preg_match('/^\s*$/', $word) || preg_match('/^[.,;:!?()&quot;\'-]+$/', $word)) {&#10;                // Espaces et ponctuation - garder tel quel&#10;                $processedWords[] = $word;&#10;            } else {&#10;                // C'est un mot - vérifier s'il doit être dévoilé&#10;                $normalizedWord = $this-&gt;normalizeWord($word);&#10;                $isRevealed = $this-&gt;isWordRevealed($word, $foundWordsNormalized);&#10;&#10;                if ($isRevealed) {&#10;                    // Mot trouvé : affichage en texte noir normal sans arrière-plan&#10;                    $processedWords[] = '&lt;span class=&quot;revealed-word&quot;&gt;' . htmlspecialchars($word) . '&lt;/span&gt;';&#10;                } else {&#10;                    // Vérifier si ce mot a une proximité sémantique avec un mot trouvé&#10;                    if (isset($semanticProximityMapping[$normalizedWord])) {&#10;                        $semanticInfo = $semanticProximityMapping[$normalizedWord];&#10;                        $foundWord = $semanticInfo['found_word'];&#10;                        $proximityScore = $semanticInfo['proximity'];&#10;                        $colorStyle = $this-&gt;getProximityColorStyle($proximityScore);&#10;&#10;                        // Afficher le mot trouvé avec la couleur de proximité sémantique&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word-with-proximity&quot; style=&quot;' . $colorStyle . '&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot; data-found=&quot;' . htmlspecialchars($foundWord) . '&quot; data-proximity=&quot;' . $proximityScore . '&quot;&gt;' . htmlspecialchars($foundWord) . '&lt;/span&gt;';&#10;                    } else if (isset($wordProximityMapping[$normalizedWord])) {&#10;                        // Vérifier la proximité avec les mots devinés mais non trouvés&#10;                        $proximityInfo = $wordProximityMapping[$normalizedWord];&#10;                        $guessedWord = $proximityInfo['guessed_word'];&#10;                        $proximityScore = $proximityInfo['proximity'];&#10;                        $colorStyle = $this-&gt;getProximityColorStyle($proximityScore);&#10;&#10;                        // Afficher le mot deviné avec la couleur de proximité&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word-with-proximity&quot; style=&quot;' . $colorStyle . '&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot; data-guessed=&quot;' . htmlspecialchars($guessedWord) . '&quot; data-proximity=&quot;' . $proximityScore . '&quot;&gt;' . htmlspecialchars($guessedWord) . '&lt;/span&gt;';&#10;                    } else {&#10;                        // Mot complètement caché&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot;&gt;' . str_repeat('█', mb_strlen($word)) . '&lt;/span&gt;';&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return implode('', $processedWords);&#10;    }&#10;&#10;    /**&#10;     * Vérifie si un mot de l'article doit être révélé basé sur les mots trouvés par le joueur&#10;     * Prend en compte les conjugaisons et variations&#10;     */&#10;    private function isWordRevealed(string $articleWord, array $foundWordsNormalized): bool&#10;    {&#10;        $normalizedArticleWord = $this-&gt;normalizeWord($articleWord);&#10;&#10;        // Vérification directe&#10;        if (in_array($normalizedArticleWord, $foundWordsNormalized)) {&#10;            return true;&#10;        }&#10;&#10;        // Vérifier si le mot de l'article est une conjugaison d'un des mots trouvés&#10;        foreach ($foundWordsNormalized as $foundWord) {&#10;            if ($this-&gt;isVerbConjugation($foundWord, $normalizedArticleWord)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        // Vérifier les contractions avec apostrophes&#10;        if (strpos($articleWord, &quot;'&quot;) !== false) {&#10;            $parts = explode(&quot;'&quot;, $articleWord);&#10;            foreach ($parts as $part) {&#10;                $normalizedPart = $this-&gt;normalizeWord($part);&#10;                if (in_array($normalizedPart, $foundWordsNormalized)) {&#10;                    return true;&#10;                }&#10;                // Vérifier les conjugaisons pour chaque partie&#10;                foreach ($foundWordsNormalized as $foundWord) {&#10;                    if ($this-&gt;isVerbConjugation($foundWord, $normalizedPart)) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    public function getLeaderboard(Room $room): array&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;getLeaderboard($room);&#10;    }&#10;&#10;    public function getActivePlayers(Room $room): array&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;findActiveSessionsForRoom($room);&#10;    }&#10;&#10;    public function getRoomByCode(string $code): ?Room&#10;    {&#10;        return $this-&gt;roomRepository-&gt;findByCode($code);&#10;    }&#10;&#10;    public function getGameSession(int $sessionId): ?GameSession&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;find($sessionId);&#10;    }&#10;&#10;    private function fetchWikipediaArticle(string $url): array&#10;    {&#10;        $title = $this-&gt;extractTitleFromUrl($url);&#10;&#10;        // Utiliser l'API de résumé de Wikipedia qui donne directement l'introduction&#10;        $summaryApiUrl = &quot;https://fr.wikipedia.org/api/rest_v1/page/summary/&quot; . urlencode($title);&#10;&#10;        $context = stream_context_create([&#10;            'http' =&gt; [&#10;                'header' =&gt; &quot;User-Agent: PedantixApp/1.0\r\n&quot;,&#10;                'timeout' =&gt; 30,&#10;                'ignore_errors' =&gt; true&#10;            ]&#10;        ]);&#10;&#10;        try {&#10;            $summaryResponse = file_get_contents($summaryApiUrl, false, $context);&#10;&#10;            if ($summaryResponse === false) {&#10;                $error = error_get_last();&#10;                throw new \Exception('Impossible de r��cupérer l\'article Wikipedia: ' . ($error['message'] ?? 'Erreur de connexion'));&#10;            }&#10;&#10;            $summaryData = json_decode($summaryResponse, true);&#10;&#10;            if (!$summaryData) {&#10;                throw new \Exception('Réponse invalide de l\'API Wikipedia');&#10;            }&#10;&#10;            if (isset($summaryData['type']) &amp;&amp; $summaryData['type'] === 'disambiguation') {&#10;                throw new \Exception('Cette page est une page de désambiguïsation. Veuillez choisir un article plus spécifique.');&#10;            }&#10;&#10;            if (!isset($summaryData['extract']) || empty($summaryData['extract'])) {&#10;                throw new \Exception('Contenu de l\'article introuvable ou vide');&#10;            }&#10;&#10;            // L'extract contient déjà un résumé propre de l'article&#10;            $content = $summaryData['extract'];&#10;&#10;            // Nettoyer un peu plus le contenu pour enlever les références restantes&#10;            $content = preg_replace('/\[[\d,\s]+\]/', '', $content); // Supprimer les références [1], [2,3], etc.&#10;            $content = preg_replace('/\s+/', ' ', $content); // Normaliser les espaces&#10;            $content = trim($content);&#10;&#10;            if (strlen($content) &lt; 50) {&#10;                throw new \Exception('L\'article est trop court pour créer une partie intéressante');&#10;            }&#10;&#10;            $properTitle = $summaryData['title'] ?? $title;&#10;&#10;            return [&#10;                'title' =&gt; $properTitle,&#10;                'content' =&gt; $content,&#10;                'allWords' =&gt; $this-&gt;extractAllWords($content)&#10;            ];&#10;        } catch (\Exception $e) {&#10;            // Log l'erreur pour debugging&#10;            error_log('Erreur fetchWikipediaArticle: ' . $e-&gt;getMessage() . ' pour URL: ' . $url);&#10;            throw $e;&#10;        }&#10;    }&#10;&#10;    private function cleanWikipediaContent(string $html): string&#10;    {&#10;        // Supprimer les balises non désirées&#10;        $html = preg_replace('/&lt;script.*?&lt;\/script&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;style.*?&lt;\/style&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;figure.*?&lt;\/figure&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;table.*?&lt;\/table&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*infobox[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;&#10;        // Supprimer TOUTES les boîtes d'aide, navigation et métadonnées&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*dablink[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*hatnote[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*disambig[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*navigation[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*navbox[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;        $html = preg_replace('/&lt;div[^&gt;]*class=&quot;[^&quot;]*metadata[^&quot;]*&quot;.*?&lt;\/div&gt;/is', '', $html);&#10;&#10;        // Approche plus simple et plus stricte : extraire seulement les 2-3 premiers vrais paragraphes&#10;        preg_match_all('/&lt;p[^&gt;]*&gt;(.*?)&lt;\/p&gt;/is', $html, $matches);&#10;        $allParagraphs = $matches[1];&#10;&#10;        $introContent = [];&#10;        $paragraphCount = 0;&#10;&#10;        foreach ($allParagraphs as $paragraph) {&#10;            $cleaned = strip_tags($paragraph);&#10;            $cleaned = html_entity_decode($cleaned, ENT_QUOTES, 'UTF-8');&#10;            $cleaned = preg_replace('/\s+/', ' ', $cleaned);&#10;            $cleaned = trim($cleaned);&#10;&#10;            // Filtres très stricts pour ne garder que l'introduction&#10;            if (!empty($cleaned) &amp;&amp;&#10;                strlen($cleaned) &gt; 30 &amp;&amp; // Paragraphes substantiels seulement&#10;                !preg_match('/^(Pour les articles|Page d\'aide|Ne doit pas être confondu|Cet article|voir|redirigé|coordination|modifier|wikidata)/i', $cleaned) &amp;&amp;&#10;                !preg_match('/(homonymie|homonymes|voir aussi|articles connexes|catégorie|portail)/i', $cleaned) &amp;&amp;&#10;                !preg_match('/^\s*(modifier|edit|\[|\()/i', $cleaned)) {&#10;&#10;                $introContent[] = $cleaned;&#10;                $paragraphCount++;&#10;&#10;                // LIMITER STRICTEMENT à 2-3 paragraphes d'introduction maximum&#10;                if ($paragraphCount &gt;= 2) {&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;        // S'assurer qu'on a au moins quelque chose de substantiel&#10;        if (empty($introContent)) {&#10;            return &quot;L'eau est un composé chimique ubiquitaire sur la Terre, essentiel pour tous les organismes vivants connus.&quot;;&#10;        }&#10;&#10;        return implode(&quot;\n\n&quot;, $introContent);&#10;    }&#10;&#10;    private function getElementPosition(\DOMNode $element): int&#10;    {&#10;        $position = 0;&#10;        $current = $element;&#10;&#10;        while ($current-&gt;previousSibling !== null) {&#10;            $current = $current-&gt;previousSibling;&#10;            $position++;&#10;        }&#10;&#10;        // Ajouter la position des parents&#10;        if ($current-&gt;parentNode !== null &amp;&amp; $current-&gt;parentNode-&gt;nodeName !== '#document') {&#10;            $position += $this-&gt;getElementPosition($current-&gt;parentNode) * 1000;&#10;        }&#10;&#10;        return $position;&#10;    }&#10;&#10;    private function extractTitleFromUrl(string $url): string&#10;    {&#10;        $path = parse_url($url, PHP_URL_PATH);&#10;        $title = basename($path);&#10;        return urldecode($title);&#10;    }&#10;&#10;    private function extractAllWords(string $content): array&#10;    {&#10;        $words = preg_split('/\s+/', $content);&#10;        $cleanWords = [];&#10;&#10;        foreach ($words as $word) {&#10;            $cleaned = $this-&gt;normalizeWord($word);&#10;            if (strlen($cleaned) &gt;= 2 &amp;&amp; !in_array($cleaned, $this-&gt;getStopWords())) {&#10;                $cleanWords[] = $cleaned;&#10;            }&#10;        }&#10;&#10;        return array_unique($cleanWords);&#10;    }&#10;&#10;    private function extractAllWordsFromContent(string $content): array&#10;    {&#10;        // Extraire tous les mots du contenu en préservant la structure&#10;        $words = preg_split('/(\s+|[.,;:!?()&quot;\-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;        $cleanWords = [];&#10;&#10;        foreach ($words as $word) {&#10;            $cleanWord = trim($word);&#10;            if (empty($cleanWord) || preg_match('/^[.,;:!?()&quot;\'\\-\\s]+$/', $cleanWord)) {&#10;                continue;&#10;            }&#10;&#10;            // Traitement spécial pour les mots avec apostrophes&#10;            if (strpos($cleanWord, &quot;'&quot;) !== false) {&#10;                $parts = explode(&quot;'&quot;, $cleanWord);&#10;                foreach ($parts as $part) {&#10;                    $part = trim($part);&#10;                    if (!empty($part) &amp;&amp; strlen($part) &gt;= 2) {&#10;                        $cleanWords[] = $part;&#10;                    }&#10;                }&#10;            } else {&#10;                if (strlen($cleanWord) &gt;= 2) {&#10;                    $cleanWords[] = $cleanWord;&#10;                }&#10;            }&#10;        }&#10;&#10;        return $cleanWords;&#10;    }&#10;&#10;    private function extractTitleWords(string $title): array&#10;    {&#10;        // Extraire tous les mots significatifs du titre&#10;        $words = preg_split('/\s+/', $title);&#10;        $titleWords = [];&#10;&#10;        foreach ($words as $word) {&#10;            $cleaned = $this-&gt;normalizeWord($word);&#10;            if (strlen($cleaned) &gt;= 2) {&#10;                $titleWords[] = $word; // Garder le mot original, pas normalisé&#10;            }&#10;        }&#10;&#10;        return $titleWords;&#10;    }&#10;&#10;    private function normalizeWord(string $word): string&#10;    {&#10;        // Enlever la ponctuation et normaliser&#10;        $word = preg_replace('/[^\p{L}\p{N}]/u', '', $word);&#10;        $word = mb_strtolower($word, 'UTF-8');&#10;&#10;        // Enlever les accents pour la comparaison&#10;        $word = iconv('UTF-8', 'ASCII//TRANSLIT//IGNORE', $word);&#10;        $word = preg_replace('/[^a-z0-9]/', '', $word);&#10;&#10;        return $word;&#10;    }&#10;&#10;    private function wordExistsInArticle(string $guess, string $content): bool&#10;    {&#10;        $normalizedGuess = $this-&gt;normalizeWord($guess);&#10;&#10;        // Cas spécial pour les contractions comme &quot;l'&quot;&#10;        if (strlen($guess) == 1 &amp;&amp; in_array(strtolower($guess), ['l', 'd', 'j', 'n', 'm', 'c', 's', 't'])) {&#10;            // Rechercher des patterns comme &quot;l'eau&quot;, &quot;d'eau&quot;, etc.&#10;            $pattern = '/\b' . preg_quote(strtolower($guess)) . '\'/i';&#10;            if (preg_match($pattern, $content)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        // Diviser le contenu en mots en préservant les apostrophes&#10;        $words = preg_split('/(\s+|[.,;:!?()&quot;\-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;        foreach ($words as $word) {&#10;            $cleanWord = trim($word);&#10;            if (empty($cleanWord)) continue;&#10;&#10;            // Traitement spécial pour les mots avec apostrophes&#10;            if (strpos($cleanWord, &quot;'&quot;) !== false) {&#10;                $parts = explode(&quot;'&quot;, $cleanWord);&#10;                foreach ($parts as $part) {&#10;                    if ($this-&gt;normalizeWord($part) === $normalizedGuess) {&#10;                        return true;&#10;                    }&#10;                    // Vérifier les conjugaisons pour les parties de mots avec apostrophe&#10;                    if ($this-&gt;isVerbConjugation($normalizedGuess, $this-&gt;normalizeWord($part))) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;&#10;            $normalizedWord = $this-&gt;normalizeWord($cleanWord);&#10;            if ($normalizedWord === $normalizedGuess) {&#10;                return true;&#10;            }&#10;&#10;            // Vérifier si le mot deviné est un infinitif et le mot de l'article une conjugaison&#10;            if ($this-&gt;isVerbConjugation($normalizedGuess, $normalizedWord)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Vérifie si un mot est une conjugaison d'un verbe à l'infinitif&#10;     */&#10;    private function isVerbConjugation(string $infinitive, string $word): bool&#10;    {&#10;        // Patterns de conjugaison française simplifiés&#10;        $conjugationPatterns = $this-&gt;getConjugationPatterns();&#10;&#10;        foreach ($conjugationPatterns as $ending =&gt; $replacements) {&#10;            if (str_ends_with($infinitive, $ending)) {&#10;                $stem = substr($infinitive, 0, -strlen($ending));&#10;&#10;                foreach ($replacements as $replacement) {&#10;                    $conjugated = $stem . $replacement;&#10;                    if ($conjugated === $word) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Vérifier aussi les verbes irréguliers les plus courants&#10;        $irregularVerbs = $this-&gt;getIrregularVerbs();&#10;        if (isset($irregularVerbs[$infinitive])) {&#10;            return in_array($word, $irregularVerbs[$infinitive]);&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Patterns de conjugaison pour les verbes réguliers&#10;     */&#10;    private function getConjugationPatterns(): array&#10;    {&#10;        return [&#10;            'er' =&gt; [&#10;                'e', 'es', 'e', 'ons', 'ez', 'ent', // présent&#10;                'ais', 'ais', 'ait', 'ions', 'iez', 'aient', // imparfait&#10;                'ai', 'as', 'a', 'ames', 'ates', 'erent', // passé simple&#10;                'erai', 'eras', 'era', 'erons', 'erez', 'eront', // futur&#10;                'erais', 'erais', 'erait', 'erions', 'eriez', 'eraient', // conditionnel&#10;                'ant', 'e', // participes&#10;            ],&#10;            'ir' =&gt; [&#10;                'is', 'is', 'it', 'issons', 'issez', 'issent', // présent&#10;                'issais', 'issais', 'issait', 'issions', 'issiez', 'issaient', // imparfait&#10;                'is', 'is', 'it', 'imes', 'ites', 'irent', // passé simple&#10;                'irai', 'iras', 'ira', 'irons', 'irez', 'iront', // futur&#10;                'irais', 'irais', 'irait', 'irions', 'iriez', 'iraient', // conditionnel&#10;                'issant', 'i', // participes&#10;            ],&#10;            're' =&gt; [&#10;                's', 's', '', 'ons', 'ez', 'ent', // présent&#10;                'ais', 'ais', 'ait', 'ions', 'iez', 'aient', // imparfait&#10;                'is', 'is', 'it', 'imes', 'ites', 'irent', // passé simple&#10;                'rai', 'ras', 'ra', 'rons', 'rez', 'ront', // futur&#10;                'rais', 'rais', 'rait', 'rions', 'riez', 'raient', // conditionnel&#10;                'ant', 'u', // participes&#10;            ]&#10;        ];&#10;    }&#10;&#10;    /**&#10;     * Verbes irréguliers les plus courants&#10;     */&#10;    private function getIrregularVerbs(): array&#10;    {&#10;        return [&#10;            'etre' =&gt; ['suis', 'es', 'est', 'sommes', 'etes', 'sont', 'etais', 'etait', 'etions', 'etiez', 'etaient', 'fus', 'fut', 'fumes', 'furent', 'serai', 'seras', 'sera', 'serons', 'serez', 'seront', 'serais', 'serait', 'serions', 'seriez', 'seraient', 'etant', 'ete'],&#10;            'avoir' =&gt; ['ai', 'as', 'a', 'avons', 'avez', 'ont', 'avais', 'avait', 'avions', 'aviez', 'avaient', 'eus', 'eut', 'eumes', 'eurent', 'aurai', 'auras', 'aura', 'aurons', 'aurez', 'auront', 'aurais', 'aurait', 'aurions', 'auriez', 'auraient', 'ayant', 'eu'],&#10;            'aller' =&gt; ['vais', 'vas', 'va', 'allons', 'allez', 'vont', 'allais', 'allait', 'allions', 'alliez', 'allaient', 'allai', 'alla', 'allames', 'allerent', 'irai', 'iras', 'ira', 'irons', 'irez', 'iront', 'irais', 'irait', 'irions', 'iriez', 'iraient', 'allant', 'alle'],&#10;            'faire' =&gt; ['fais', 'fait', 'faisons', 'faites', 'font', 'faisais', 'faisait', 'faisions', 'faisiez', 'faisaient', 'fis', 'fit', 'fimes', 'firent', 'ferai', 'feras', 'fera', 'ferons', 'ferez', 'feront', 'ferais', 'ferait', 'ferions', 'feriez', 'feraient', 'faisant', 'fait'],&#10;            'dire' =&gt; ['dis', 'dit', 'disons', 'dites', 'disent', 'disais', 'disait', 'disions', 'disiez', 'disaient', 'dis', 'dit', 'dimes', 'dirent', 'dirai', 'diras', 'dira', 'dirons', 'direz', 'diront', 'dirais', 'dirait', 'dirions', 'diriez', 'diraient', 'disant', 'dit'],&#10;            'voir' =&gt; ['vois', 'voit', 'voyons', 'voyez', 'voient', 'voyais', 'voyait', 'voyions', 'voyiez', 'voyaient', 'vis', 'vit', 'vimes', 'virent', 'verrai', 'verras', 'verra', 'verrons', 'verrez', 'verront', 'verrais', 'verrait', 'verrions', 'verriez', 'verraient', 'voyant', 'vu'],&#10;            'savoir' =&gt; ['sais', 'sait', 'savons', 'savez', 'savent', 'savais', 'savait', 'savions', 'saviez', 'savaient', 'sus', 'sut', 'sumes', 'surent', 'saurai', 'sauras', 'saura', 'saurons', 'saurez', 'sauront', 'saurais', 'saurait', 'saurions', 'sauriez', 'sauraient', 'sachant', 'su'],&#10;            'pouvoir' =&gt; ['peux', 'peut', 'pouvons', 'pouvez', 'peuvent', 'pouvais', 'pouvait', 'pouvions', 'pouviez', 'pouvaient', 'pus', 'put', 'pumes', 'purent', 'pourrai', 'pourras', 'pourra', 'pourrons', 'pourrez', 'pourront', 'pourrais', 'pourrait', 'pourrions', 'pourriez', 'pourraient', 'pouvant', 'pu'],&#10;            'vouloir' =&gt; ['veux', 'veut', 'voulons', 'voulez', 'veulent', 'voulais', 'voulait', 'voulions', 'vouliez', 'voulaient', 'voulus', 'voulut', 'voulumes', 'voulurent', 'voudrai', 'voudras', 'voudra', 'voudrons', 'voudrez', 'voudront', 'voudrais', 'voudrait', 'voudrions', 'voudriez', 'voudraient', 'voulant', 'voulu'],&#10;            'venir' =&gt; ['viens', 'vient', 'venons', 'venez', 'viennent', 'venais', 'venait', 'venions', 'veniez', 'venaient', 'vins', 'vint', 'vinmes', 'vinrent', 'viendrai', 'viendras', 'viendra', 'viendrons', 'viendrez', 'viendront', 'viendrais', 'viendrait', 'viendrions', 'viendriez', 'viendraient', 'venant', 'venu'],&#10;            'partir' =&gt; ['pars', 'part', 'partons', 'partez', 'partent', 'partais', 'partait', 'partions', 'partiez', 'partaient', 'partis', 'partit', 'partimes', 'partirent', 'partirai', 'partiras', 'partira', 'partirons', 'partirez', 'partiront', 'partirais', 'partirait', 'partirions', 'partiriez', 'partiraient', 'partant', 'parti'],&#10;        ];&#10;    }&#10;&#10;    public function getLeaderboard(Room $room): array&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;getLeaderboard($room);&#10;    }&#10;&#10;    public function getActivePlayers(Room $room): array&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;findActiveSessionsForRoom($room);&#10;    }&#10;&#10;    public function getRoomByCode(string $code): ?Room&#10;    {&#10;        return $this-&gt;roomRepository-&gt;findByCode($code);&#10;    }&#10;&#10;    public function getGameSession(int $sessionId): ?GameSession&#10;    {&#10;        return $this-&gt;gameSessionRepository-&gt;find($sessionId);&#10;    }&#10;&#10;    /**&#10;     * Vérifie si tous les mots du titre ont été trouvés par le joueur&#10;     */&#10;    private function checkAllTitleWordsFound(GameSession $gameSession, Room $room, array $titleWordsNormalized): bool&#10;    {&#10;        // En mode coopération, vérifier les mots trouvés globalement&#10;        if ($room-&gt;isCooperativeMode()) {&#10;            $allFoundWords = array_unique(array_merge($gameSession-&gt;getFoundWords(), $room-&gt;getGlobalFoundWords()));&#10;        } else {&#10;            $allFoundWords = $gameSession-&gt;getFoundWords();&#10;        }&#10;&#10;        $foundWordsNormalized = array_map([$this, 'normalizeWord'], $allFoundWords);&#10;&#10;        // Vérifier que chaque mot du titre a été trouvé&#10;        foreach ($titleWordsNormalized as $titleWord) {&#10;            $found = false;&#10;            foreach ($foundWordsNormalized as $foundWord) {&#10;                if ($foundWord === $titleWord) {&#10;                    $found = true;&#10;                    break;&#10;                }&#10;            }&#10;            if (!$found) {&#10;                return false; // Il manque encore au moins un mot&#10;            }&#10;        }&#10;&#10;        return true; // Tous les mots du titre ont été trouvés&#10;    }&#10;&#10;    public function getProcessedContent(Room $room, array $foundWords, array $proximityData = [], bool $gameCompleted = false): string&#10;    {&#10;        $content = $room-&gt;getContent();&#10;&#10;        // En mode coopératif, combiner les mots trouvés par le joueur avec ceux trouvés globalement&#10;        if ($room-&gt;isCooperativeMode()) {&#10;            $allFoundWords = array_unique(array_merge($foundWords, $room-&gt;getGlobalFoundWords()));&#10;        } else {&#10;            $allFoundWords = $foundWords;&#10;        }&#10;&#10;        $foundWordsNormalized = array_map([$this, 'normalizeWord'], $allFoundWords);&#10;&#10;        // Si le jeu est terminé, révéler tous les mots normalement (pas en jaune)&#10;        if ($gameCompleted) {&#10;            // Diviser le contenu en mots tout en préservant la ponctuation et la structure&#10;            $words = preg_split('/(\s+|[.,;:!?()&quot;\'-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;            $processedWords = [];&#10;            foreach ($words as $word) {&#10;                if (trim($word) === '' || preg_match('/^\s*$/', $word) || preg_match('/^[.,;:!?()&quot;\'-]+$/', $word)) {&#10;                    // Espaces et ponctuation - garder tel quel&#10;                    $processedWords[] = $word;&#10;                } else {&#10;                    // Tous les mots sont révélés avec un style normal (plus de jaune)&#10;                    $processedWords[] = '&lt;span class=&quot;revealed-word-victory&quot;&gt;' . htmlspecialchars($word) . '&lt;/span&gt;';&#10;                }&#10;            }&#10;&#10;            return implode('', $processedWords);&#10;        }&#10;&#10;        // Créer un mapping des mots de l'article vers les mots devinés les plus proches&#10;        $wordProximityMapping = $this-&gt;buildWordProximityMapping($content, $proximityData);&#10;&#10;        // Créer un mapping des proximités sémantiques pour les mots trouvés&#10;        $semanticProximityMapping = $this-&gt;buildSemanticProximityMapping($content, $allFoundWords);&#10;&#10;        // Comportement normal : diviser le contenu en mots tout en préservant la ponctuation et la structure&#10;        $words = preg_split('/(\s+|[.,;:!?()&quot;\'-])/', $content, -1, PREG_SPLIT_DELIM_CAPTURE);&#10;&#10;        $processedWords = [];&#10;        foreach ($words as $word) {&#10;            if (trim($word) === '' || preg_match('/^\s*$/', $word) || preg_match('/^[.,;:!?()&quot;\'-]+$/', $word)) {&#10;                // Espaces et ponctuation - garder tel quel&#10;                $processedWords[] = $word;&#10;            } else {&#10;                // C'est un mot - vérifier s'il doit être dévoilé&#10;                $normalizedWord = $this-&gt;normalizeWord($word);&#10;                $isRevealed = $this-&gt;isWordRevealed($word, $foundWordsNormalized);&#10;&#10;                if ($isRevealed) {&#10;                    // Mot trouvé : affichage en texte noir normal sans arrière-plan&#10;                    $processedWords[] = '&lt;span class=&quot;revealed-word&quot;&gt;' . htmlspecialchars($word) . '&lt;/span&gt;';&#10;                } else {&#10;                    // Vérifier si ce mot a une proximité sémantique avec un mot trouvé&#10;                    if (isset($semanticProximityMapping[$normalizedWord])) {&#10;                        $semanticInfo = $semanticProximityMapping[$normalizedWord];&#10;                        $foundWord = $semanticInfo['found_word'];&#10;                        $proximityScore = $semanticInfo['proximity'];&#10;                        $colorStyle = $this-&gt;getProximityColorStyle($proximityScore);&#10;&#10;                        // Afficher le mot trouvé avec la couleur de proximité sémantique&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word-with-proximity&quot; style=&quot;' . $colorStyle . '&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot; data-found=&quot;' . htmlspecialchars($foundWord) . '&quot; data-proximity=&quot;' . $proximityScore . '&quot;&gt;' . htmlspecialchars($foundWord) . '&lt;/span&gt;';&#10;                    } else if (isset($wordProximityMapping[$normalizedWord])) {&#10;                        // Vérifier la proximité avec les mots devinés mais non trouvés&#10;                        $proximityInfo = $wordProximityMapping[$normalizedWord];&#10;                        $guessedWord = $proximityInfo['guessed_word'];&#10;                        $proximityScore = $proximityInfo['proximity'];&#10;                        $colorStyle = $this-&gt;getProximityColorStyle($proximityScore);&#10;&#10;                        // Afficher le mot deviné avec la couleur de proximité&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word-with-proximity&quot; style=&quot;' . $colorStyle . '&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot; data-guessed=&quot;' . htmlspecialchars($guessedWord) . '&quot; data-proximity=&quot;' . $proximityScore . '&quot;&gt;' . htmlspecialchars($guessedWord) . '&lt;/span&gt;';&#10;                    } else {&#10;                        // Mot complètement caché&#10;                        $processedWords[] = '&lt;span class=&quot;hidden-word&quot; data-word=&quot;' . htmlspecialchars($normalizedWord) . '&quot;&gt;' . str_repeat('█', mb_strlen($word)) . '&lt;/span&gt;';&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return implode('', $processedWords);&#10;    }&#10;&#10;    /**&#10;     * Vérifie si un mot de l'article doit être révélé basé sur les mots trouvés par le joueur&#10;     * Prend en compte les conjugaisons et variations&#10;     */&#10;    private function isWordRevealed(string $articleWord, array $foundWordsNormalized): bool&#10;    {&#10;        $normalizedArticleWord = $this-&gt;normalizeWord($articleWord);&#10;&#10;        // Vérification directe&#10;        if (in_array($normalizedArticleWord, $foundWordsNormalized)) {&#10;            return true;&#10;        }&#10;&#10;        // Vérifier si le mot de l'article est une conjugaison d'un des mots trouvés&#10;        foreach ($foundWordsNormalized as $foundWord) {&#10;            if ($this-&gt;isVerbConjugation($foundWord, $normalizedArticleWord)) {&#10;                return true;&#10;            }&#10;        }&#10;&#10;        // Vérifier les contractions avec apostrophes&#10;        if (strpos($articleWord, &quot;'&quot;) !== false) {&#10;            $parts = explode(&quot;'&quot;, $articleWord);&#10;            foreach ($parts as $part) {&#10;                $normalizedPart = $this-&gt;normalizeWord($part);&#10;                if (in_array($normalizedPart, $foundWordsNormalized)) {&#10;                    return true;&#10;                }&#10;                // Vérifier les conjugaisons pour chaque partie&#10;                foreach ($foundWordsNormalized as $foundWord) {&#10;                    if ($this-&gt;isVerbConjugation($foundWord, $normalizedPart)) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Récupère un article Wikipedia aléatoire&#10;     */&#10;    public function getRandomArticle(?string $difficulty = null): ?WikipediaArticle&#10;    {&#10;        return $this-&gt;wikipediaArticleRepository-&gt;findRandomArticle($difficulty);&#10;    }&#10;&#10;&#10;    /**&#10;     * Récupère les événements de jeu en temps réel (nouvelles victoires, etc.)&#10;     */&#10;    public function getGameEvents(Room $room, int $lastEventId): array&#10;    {&#10;        // Récupérer les événements récents (joueurs qui ont trouvé le mot, nouvelles victoires, etc.)&#10;        $events = [];&#10;&#10;        // Vérifier les sessions qui ont été complétées récemment&#10;        $recentCompletions = $this-&gt;gameSessionRepository-&gt;getRecentCompletions($room, $lastEventId);&#10;&#10;        foreach ($recentCompletions as $session) {&#10;            $events[] = [&#10;                'id' =&gt; $session-&gt;getId() + 1000, // Offset pour éviter les conflits&#10;                'type' =&gt; 'player_won',&#10;                'player_name' =&gt; $session-&gt;getPlayerName(),&#10;                'score' =&gt; $session-&gt;getScore(),&#10;                'attempts' =&gt; $session-&gt;getAttempts(),&#10;                'completed_at' =&gt; $session-&gt;getCompletedAt()-&gt;format('Y-m-d H:i:s'),&#10;                'position' =&gt; $this-&gt;getPlayerPosition($room, $session),&#10;                'message' =&gt; $this-&gt;generateVictoryMessage($session, $room)&#10;            ];&#10;        }&#10;&#10;        return $events;&#10;    }&#10;&#10;    public function checkGameStatus(Room $room): array&#10;    {&#10;        $activePlayers = $this-&gt;getActivePlayers($room);&#10;        $completedPlayers = $this-&gt;gameSessionRepository-&gt;getCompletedSessions($room);&#10;&#10;        $totalPlayers = count($activePlayers);&#10;        $completedCount = count($completedPlayers);&#10;&#10;        // En mode compétition, vérifier si tous les joueurs ont terminé&#10;        if ($room-&gt;getGameMode() === 'competition') {&#10;            $allCompleted = $totalPlayers &gt; 0 &amp;&amp; $completedCount &gt;= $totalPlayers;&#10;&#10;            if ($allCompleted &amp;&amp; !$room-&gt;isGameCompleted()) {&#10;                // Marquer le jeu comme terminé&#10;                $room-&gt;setIsGameCompleted(true);&#10;                $room-&gt;setCompletedAt(new \DateTimeImmutable());&#10;&#10;                // Définir le gagnant (meilleur score)&#10;                $winner = $this-&gt;gameSessionRepository-&gt;getWinner($room);&#10;                if ($winner) {&#10;                    $room-&gt;setWinnerId($winner-&gt;getId());&#10;                }&#10;&#10;                $this-&gt;roomRepository-&gt;save($room, true);&#10;            }&#10;&#10;            // Récupérer les informations du gagnant correctement formatées&#10;            $winnerData = null;&#10;            if ($room-&gt;getWinnerId()) {&#10;                $winner = $this-&gt;getGameSession($room-&gt;getWinnerId());&#10;                if ($winner) {&#10;                    $winnerData = [&#10;                        'player_name' =&gt; $winner-&gt;getPlayerName(),&#10;                        'score' =&gt; $winner-&gt;getScore(),&#10;                        'attempts' =&gt; $winner-&gt;getAttempts()&#10;                    ];&#10;                }&#10;            }&#10;&#10;            return [&#10;                'is_completed' =&gt; $allCompleted,&#10;                'total_players' =&gt; $totalPlayers,&#10;                'completed_players' =&gt; $completedCount,&#10;                'winner' =&gt; $winnerData,&#10;                'game_mode' =&gt; 'competition'&#10;            ];&#10;        }&#10;        // En mode coopération, vérifier si le jeu est terminé (titre trouvé)&#10;        elseif ($room-&gt;getGameMode() === 'cooperation') {&#10;            $isCompleted = $room-&gt;isGameCompleted();&#10;&#10;            // Récupérer les informations de l'équipe gagnante&#10;            $teamData = null;&#10;            if ($isCompleted) {&#10;                $allCompletedPlayers = $this-&gt;gameSessionRepository-&gt;getCompletedSessions($room);&#10;                if (!empty($allCompletedPlayers)) {&#10;                    // En coopération, tous les joueurs sont gagnants&#10;                    $teamData = array_map(function($session) {&#10;                        return [&#10;                            'player_name' =&gt; $session-&gt;getPlayerName(),&#10;                            'score' =&gt; $session-&gt;getScore(),&#10;                            'attempts' =&gt; $session-&gt;getAttempts()&#10;                        ];&#10;                    }, $allCompletedPlayers);&#10;                }&#10;            }&#10;&#10;            return [&#10;                'is_completed' =&gt; $isCompleted,&#10;                'total_players' =&gt; $totalPlayers,&#10;                'completed_players' =&gt; $completedCount,&#10;                'team' =&gt; $teamData, // En coopération, on parle d'équipe plutôt que de gagnant individuel&#10;                'game_mode' =&gt; 'cooperation'&#10;            ];&#10;        }&#10;&#10;        return [&#10;            'is_completed' =&gt; false,&#10;            'total_players' =&gt; $totalPlayers,&#10;            'completed_players' =&gt; $completedCount,&#10;            'game_mode' =&gt; $room-&gt;getGameMode()&#10;        ];&#10;    }&#10;&#10;    public function completeGame(Room $room, int $sessionId): array&#10;    {&#10;        // Marquer manuellement le jeu comme terminé&#10;        $room-&gt;setIsGameCompleted(true);&#10;        $room-&gt;setCompletedAt(new \DateTimeImmutable());&#10;&#10;        // Définir le gagnant si pas encore fait&#10;        if (!$room-&gt;getWinnerId()) {&#10;            $winner = $this-&gt;gameSessionRepository-&gt;getWinner($room);&#10;            if ($winner) {&#10;                $room-&gt;setWinnerId($winner-&gt;getId());&#10;            }&#10;        }&#10;&#10;        $this-&gt;roomRepository-&gt;save($room, true);&#10;&#10;        // Retourner les statistiques finales&#10;        $leaderboard = $this-&gt;getLeaderboard($room);&#10;        $winner = $room-&gt;getWinnerId() ? $this-&gt;getGameSession($room-&gt;getWinnerId()) : null;&#10;&#10;        return [&#10;            'winner' =&gt; $winner ? [&#10;                'player_name' =&gt; $winner-&gt;getPlayerName(),&#10;                'score' =&gt; $winner-&gt;getScore(),&#10;                'attempts' =&gt; $winner-&gt;getAttempts()&#10;            ] : null,&#10;            'leaderboard' =&gt; array_map(function($session) {&#10;                return [&#10;                    'player_name' =&gt; $session-&gt;getPlayerName(),&#10;                    'score' =&gt; $session-&gt;getScore(),&#10;                    'attempts' =&gt; $session-&gt;getAttempts(),&#10;                    'completed_at' =&gt; $session-&gt;getCompletedAt()?-&gt;format('Y-m-d H:i:s')&#10;                ];&#10;            }, $leaderboard)&#10;        ];&#10;    }&#10;&#10;    public function transferPlayersToNewRoom(string $oldRoomCode, Room $newRoom): array&#10;    {&#10;        $oldRoom = $this-&gt;getRoomByCode($oldRoomCode);&#10;        if (!$oldRoom) {&#10;            throw new \Exception('Ancienne salle introuvable');&#10;        }&#10;&#10;        $activePlayers = $this-&gt;getActivePlayers($oldRoom);&#10;        $transferredPlayers = [];&#10;&#10;        foreach ($activePlayers as $oldSession) {&#10;            // Créer une nouvelle session dans la nouvelle salle&#10;            $newSession = new GameSession();&#10;            $newSession-&gt;setRoom($newRoom);&#10;            $newSession-&gt;setPlayerName($oldSession-&gt;getPlayerName());&#10;            $newSession-&gt;setIpAddress($oldSession-&gt;getIpAddress());&#10;&#10;            $this-&gt;gameSessionRepository-&gt;save($newSession, true);&#10;&#10;            $transferredPlayers[] = [&#10;                'player_name' =&gt; $newSession-&gt;getPlayerName(),&#10;                'new_session_id' =&gt; $newSession-&gt;getId()&#10;            ];&#10;        }&#10;&#10;        return [&#10;            'transferred_players' =&gt; $transferredPlayers,&#10;            'count' =&gt; count($transferredPlayers)&#10;        ];&#10;    }&#10;&#10;    public function getRoomStatus(Room $room, ?GameSession $gameSession): array&#10;    {&#10;        $activePlayers = $this-&gt;getActivePlayers($room);&#10;        $completedPlayers = $this-&gt;gameSessionRepository-&gt;getCompletedSessions($room);&#10;&#10;        $status = [&#10;            'room_code' =&gt; $room-&gt;getCode(),&#10;            'game_mode' =&gt; $room-&gt;getGameMode(),&#10;            'is_game_completed' =&gt; $room-&gt;isGameCompleted(),&#10;            'total_players' =&gt; count($activePlayers),&#10;            'completed_players' =&gt; count($completedPlayers),&#10;            'winner' =&gt; null&#10;        ];&#10;&#10;        if ($room-&gt;getWinnerId()) {&#10;            $winner = $this-&gt;getGameSession($room-&gt;getWinnerId());&#10;            if ($winner) {&#10;                $status['winner'] = [&#10;                    'player_name' =&gt; $winner-&gt;getPlayerName(),&#10;                    'score' =&gt; $winner-&gt;getScore(),&#10;                    'attempts' =&gt; $winner-&gt;getAttempts()&#10;                ];&#10;            }&#10;        }&#10;&#10;        if ($gameSession) {&#10;            $status['current_player'] = [&#10;                'name' =&gt; $gameSession-&gt;getPlayerName(),&#10;                'score' =&gt; $gameSession-&gt;getScore(),&#10;                'attempts' =&gt; $gameSession-&gt;getAttempts(),&#10;                'completed' =&gt; $gameSession-&gt;isCompleted(),&#10;                'position' =&gt; $this-&gt;getPlayerPosition($room, $gameSession)&#10;            ];&#10;        }&#10;&#10;        return $status;&#10;    }&#10;&#10;    /**&#10;     * Démarre une nouvelle partie dans la même salle avec un nouvel article&#10;     */&#10;    public function startNewGameInSameRoom(Room $room, string $wikipediaUrl): array&#10;    {&#10;        try {&#10;            // Récupérer les données du nouvel article&#10;            $articleData = $this-&gt;fetchWikipediaArticle($wikipediaUrl);&#10;&#10;            // Sauvegarder les scores précédents avant de réinitialiser&#10;            $this-&gt;archivePreviousGameScores($room);&#10;&#10;            // Réinitialiser la salle pour la nouvelle partie&#10;            $room-&gt;resetForNewGame(&#10;                $articleData['title'],&#10;                $articleData['content'],&#10;                $wikipediaUrl,&#10;                $articleData['allWords']&#10;            );&#10;&#10;            // Réinitialiser toutes les sessions de jeu pour la nouvelle partie&#10;            $this-&gt;resetAllGameSessions($room);&#10;&#10;            // Sauvegarder les changements&#10;            $this-&gt;roomRepository-&gt;save($room, true);&#10;&#10;            return [&#10;                'title' =&gt; $articleData['title'],&#10;                'game_number' =&gt; $room-&gt;getGameNumber()&#10;            ];&#10;&#10;        } catch (\Exception $e) {&#10;            // En cas d'erreur, déverrouiller la salle&#10;            $room-&gt;unlockNewGame();&#10;            $this-&gt;roomRepository-&gt;save($room, true);&#10;            throw $e;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Archive les scores de la partie précédente&#10;     */&#10;    private function archivePreviousGameScores(Room $room): void&#10;    {&#10;        // Pour l'instant, on garde simplement les scores cumulatifs&#10;        // Dans une version future, on pourrait créer une table d'historique des parties&#10;        $activeSessions = $this-&gt;gameSessionRepository-&gt;findActiveSessionsForRoom($room);&#10;&#10;        foreach ($activeSessions as $session) {&#10;            // Marquer la session comme archivée pour cette partie&#10;            // Les scores seront conservés et s'additionneront à la prochaine partie&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Réinitialise toutes les sessions de jeu pour une nouvelle partie&#10;     */&#10;    private function resetAllGameSessions(Room $room): void&#10;    {&#10;        $activeSessions = $this-&gt;gameSessionRepository-&gt;findActiveSessionsForRoom($room);&#10;&#10;        foreach ($activeSessions as $session) {&#10;            // Réinitialiser les données spécifiques à la partie mais garder le score cumulé&#10;            $currentScore = $session-&gt;getScore(); // Score cumulé de toutes les parties&#10;&#10;            $session-&gt;setFoundWords([]);&#10;            $session-&gt;setAttempts(0);&#10;            $session-&gt;setCompleted(false);&#10;            $session-&gt;setCompletedAt(null);&#10;            $session-&gt;updateActivity();&#10;            // Le score reste inchangé pour être cumulatif&#10;&#10;            $this-&gt;gameSessionRepository-&gt;save($session, false);&#10;        }&#10;&#10;        // Flush tous les changements en une fois&#10;        $this-&gt;entityManager-&gt;flush();&#10;    }&#10;&#10;    /**&#10;     * Sauvegarde une salle&#10;     */&#10;    public function saveRoom(Room $room): void&#10;    {&#10;        $this-&gt;roomRepository-&gt;save($room, true);&#10;    }&#10;&#10;    /**&#10;     * Calcule la difficulté d'un mot basé sur le nombre de joueurs qui l'ont trouvé&#10;     */&#10;    private function calculateWordDifficulty(string $word, int $foundByCount, int $totalPlayers): string&#10;    {&#10;        $percentage = $totalPlayers &gt; 0 ? ($foundByCount / $totalPlayers) * 100 : 0;&#10;&#10;        if ($percentage &gt;= 80) {&#10;            return 'Très facile';&#10;        } elseif ($percentage &gt;= 60) {&#10;            return 'Facile';&#10;        } elseif ($percentage &gt;= 40) {&#10;            return 'Moyen';&#10;        } elseif ($percentage &gt;= 20) {&#10;            return 'Difficile';&#10;        } else {&#10;            return 'Très difficile';&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retourne le style CSS pour la couleur de proximité&#10;     */&#10;    private function getProximityColorStyle(int $proximityScore): string&#10;    {&#10;        if ($proximityScore &gt;= 800) {&#10;            return 'background: #d0d0d0 !important; color: #FFD700 !important; font-weight: bold !important;'; // Très chaud - doré&#10;        } elseif ($proximityScore &gt;= 600) {&#10;            return 'background: #d0d0d0 !important; color: #FF8C00 !important; font-weight: bold !important;'; // Chaud - orange&#10;        } elseif ($proximityScore &gt;= 400) {&#10;            return 'background: #d0d0d0 !important; color: #FF6347 !important;'; // Tiède - rouge tomate&#10;        } else {&#10;            return 'background: #d0d0d0 !important; color: #696969 !important;'; // Froid - gris foncé&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtient la position d'un joueur dans le classement&#10;     */&#10;    private function getPlayerPosition(Room $room, GameSession $session): int&#10;    {&#10;        $leaderboard = $this-&gt;getLeaderboard($room);&#10;&#10;        foreach ($leaderboard as $index =&gt; $leaderSession) {&#10;            if ($leaderSession-&gt;getId() === $session-&gt;getId()) {&#10;                return $index + 1;&#10;            }&#10;        }&#10;&#10;        return count($leaderboard) + 1; // Si pas trouvé, mettre à la fin&#10;    }&#10;&#10;    /**&#10;     * Génère un message de victoire personnalisé&#10;     */&#10;    private function generateVictoryMessage(GameSession $session, Room $room): string&#10;    {&#10;        $position = $this-&gt;getPlayerPosition($room, $session);&#10;        $playerName = $session-&gt;getPlayerName();&#10;&#10;        if ($position === 1) {&#10;            return &quot; {$playerName} remporte la victoire !&quot;;&#10;        } elseif ($position &lt;= 3) {&#10;            return &quot; {$playerName} termine sur le podium (#{$position}) !&quot;;&#10;        } else {&#10;            return &quot;✅ {$playerName} a trouvé le mot-titre !&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Récupère les informations de progression du titre (mots trouvés/total)&#10;     */&#10;    public function getTitleProgress(GameSession $gameSession, Room $room): array&#10;    {&#10;        $titleWords = $this-&gt;extractTitleWords($room-&gt;getTitle());&#10;        $titleWordsNormalized = array_map([$this, 'normalizeWord'], $titleWords);&#10;&#10;        // En mode coopération, vérifier les mots trouvés globalement&#10;        if ($room-&gt;isCooperativeMode()) {&#10;            $allFoundWords = array_unique(array_merge($gameSession-&gt;getFoundWords(), $room-&gt;getGlobalFoundWords()));&#10;        } else {&#10;            $allFoundWords = $gameSession-&gt;getFoundWords();&#10;        }&#10;&#10;        $foundWordsNormalized = array_map([$this, 'normalizeWord'], $allFoundWords);&#10;&#10;        $displayWords = [];&#10;        $foundCount = 0;&#10;&#10;        foreach ($titleWords as $index =&gt; $titleWord) {&#10;            $normalizedTitleWord = $titleWordsNormalized[$index];&#10;            $isFound = false;&#10;&#10;            foreach ($foundWordsNormalized as $foundWord) {&#10;                if ($foundWord === $normalizedTitleWord) {&#10;                    $isFound = true;&#10;                    break;&#10;                }&#10;            }&#10;&#10;            if ($isFound) {&#10;                $displayWords[] = $titleWord; // Afficher le mot trouvé&#10;                $foundCount++;&#10;            } else {&#10;                // Afficher des traits selon la longueur du mot&#10;                $displayWords[] = str_repeat('_', mb_strlen($titleWord));&#10;            }&#10;        }&#10;&#10;        return [&#10;            'title' =&gt; $room-&gt;getTitle(),&#10;            'total_words' =&gt; count($titleWords),&#10;            'found_words' =&gt; $foundCount,&#10;            'display_title' =&gt; implode(' ', $displayWords),&#10;            'is_complete' =&gt; $foundCount === count($titleWords),&#10;            'progress_percentage' =&gt; count($titleWords) &gt; 0 ? round(($foundCount / count($titleWords)) * 100) : 0&#10;        ];&#10;    }&#10;&#10;    /**&#10;     * Marque tous les joueurs actifs comme gagnants en mode coopération&#10;     */&#10;    private function markAllPlayersAsWinners(Room $room): void&#10;    {&#10;        $activePlayers = $this-&gt;getActivePlayers($room);&#10;&#10;        foreach ($activePlayers as $session) {&#10;            if (!$session-&gt;isCompleted()) {&#10;                $session-&gt;setCompleted(true);&#10;                $session-&gt;setCompletedAt(new \DateTimeImmutable());&#10;&#10;                // Attribuer un score de participation pour tous les joueurs&#10;                $participationScore = max(500 - ($session-&gt;getAttempts() * 5), 100);&#10;                $session-&gt;setScore($session-&gt;getScore() + $participationScore);&#10;&#10;                $this-&gt;gameSessionRepository-&gt;save($session, false);&#10;            }&#10;        }&#10;&#10;        // Flush tous les changements en une fois&#10;        $this-&gt;entityManager-&gt;flush();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>